<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Donate to Campaign</title>
  <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"> -->
  <!-- <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css"> -->
  <link rel="stylesheet" href="css/pico.min.css">

  <style>
      :root {
          --font: white;
          --bk: linear-gradient(var(--c0), var(--c0b));
          --bckmodal: #262626;
          --mainBk: #2996b4;
        }
        

   
         /* Custom styles for themes */
    body.light-theme, html {
      background-color: #ffffff;
      color: #000000;
    }
    body.dark-theme, html{
      background-color: #121212;
            background-image: radial-gradient(circle, var(--mainBk) 0%, var(--bckmodal) 100%);

      color: #ffffff;
    }
        /* h1,h2,h3,h4,p{
            color: var(--font)!important;

        } */


    .progress-bar {
      width: 100%;
      background-color: #e0e0e0;
      border-radius: 5px;
      overflow: hidden;
      margin-top: 1rem;
    }

    .progress-bar-fill {
      height: 20px;
      background-color: #4caf50;
      width: 0%;
      transition: width 0.3s ease;
    }

    /* #walletModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    } */

    /* #walletModalContent {
      background: white;
      padding: 2rem;
      border-radius: 10px;
      text-align: center;
      max-width: 400px;
      width: 100%;
    } */

    .wallet-option {
      display: flex;
      align-items: center;
      margin: 1rem 0;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 5px;
      transition: background 0.3s ease;
    }

    .wallet-option:hover {
      background: #f0f0f0;
    }

    .wallet-icon {
      width: 32px;
      height: 32px;
      margin-right: 1rem;
    }

    .connect-wallet-container {
      position: absolute;
      top: 1rem;
      right: 1rem;
      z-index: 100;
    }

    .connect-wallet-btn {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1rem;
      transition: background-color 0.3s ease;
    }

    .connect-wallet-btn:hover {
      background-color: #0056b3;
    }

 .success-icon {
      width: 8rem;
      height: 8rem;
      color: #28a745; 
      animation: fadeInScale .33s ease-in-out;
    }

    @keyframes fadeInScale {
      0% {
        opacity: 0;
        transform: scale(0.5);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }

    .success-section {
      display: none;
    flex-direction: column;
    align-items: center;
    }

    #successMessage{
      word-break: break-all;
    }

    #paymentModalTitle{
      font-size: small;
      text-align: center;
    }
    .copy2clipboard{
      cursor: pointer;
    }

    .modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--background-color); padding: 1rem; border-radius: 10px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1); width: 90%; max-width: 400px; }
    .modal.active { display: block; }

    .walletWith{
        max-width: 400px;
    }


    /* Checkbox styling */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px !important;
      height: 24px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.4s;
      border-radius: 34px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: 0.4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #2196f3;
    }
    input:checked + .slider:before {
      transform: translateX(26px);
    }

      /* Define the blinking animation */
      @keyframes errorblink {
      0%, 100% { opacity: 1; } /* Fully visible */
      50% { opacity: 0; }      /* Fully invisible */
    }

  /* Define the blinking animation */
  @keyframes blink {
      0% { opacity: 1; }   /* Fully visible */
      50% { opacity: 0; }  /* Fully invisible */
      100% { opacity: 1; } /* Fully visible again */
    }

    #campaignDonor{
      color: red; /* Success color */

    }
    /* Class to apply the blinking effect */
    .success-text {
      animation: blink 0.5s linear 1; /* Duration: 0.5s, Iterations: 1 */
      color: green!important; /* Success color */
      font-weight: bold; /* Make the text stand out */
    }
    /* Class to apply the blinking effect */
    .blink-text {
      animation: blink 0.5s linear 3; /* Duration: 0.5s, Iterations: 3 */
      color: red; /* Remark color */
    }
      /* Class to apply the blinking effect */
      .error-text {
      animation: blink 0.5s linear 1; /* Duration: 0.5s, Iterations: 1 */
      color: red; /* Success color */
      font-weight: bold; /* Make the text stand out */
    }


  </style>
</head>
<body>
    <nav class="container-fluid">

      
      <!-- Header -->
      <!-- <header class="container">
        <h1>Stealth Donations</h1>
        <hgroup>
          <p>Connect your wallet and donate</p>
        </hgroup>
       
      </header> -->
        <ul>
          <li><strong>Stealth Donations</strong></li>
        </ul>
        <ul>
          <li><button onclick="openSettings()"> ‚öôÔ∏è Settings</button></li>
          <li id="openBUtton"> <button onclick="openWallet()" > Connect Wallet üîå </button> </li>
          <li id="closeBUtton" style="display: none;"> <button onclick="closeWallet()" > Disconnect Wallet üö∂‚Äç‚û°Ô∏è </button> </li>
        </ul>
      </nav>

      
  <main class="container">

    <!-- <h1>Stealth Donations</h1> -->

      <!-- Header -->
      <!-- <header class="container">
        <hgroup>
          <p>Connect your wallet and donate</p>
        </hgroup>
       
      </header> -->

    <!-- Campaign Details -->
    <section id="campaignDetails" style="display: none;">
      <h2>Campaign Details</h2>
      <p><span id="campaignDonor" > User not connected</span></p>
      <!-- <p><strong>User:</strong> <span id="campaignDonor"> User not connected</span></p> -->
      <p><strong>Recipient:</strong> <span id="campaignRecipient"></span></p>
      <p><strong>Goal:</strong> <span id="campaignGoal"></span> ETH</p>
      <p><strong>Raised:</strong> <span id="campaignRaised"></span> ETH</p>
      <div class="progress-bar">
        <div class="progress-bar-fill" id="progressBarFill"></div>
      </div>
      <div id="campaignEndedBanner" style="display: none; background-color: #ffebee; color: red; padding: 1rem; border-radius: 5px; margin-top: 1rem;">
        <strong>CAMPAIGN HAS ENDED</strong>
      </div>

      <!-- Success Banner -->
<div id="campaignSuccessBanner" style="display: none; background-color: #e8f5e9; color: green; padding: 1rem; border-radius: 5px; margin-top: 1rem;">
  <strong>CAMPAIGN SUCCESSFULLY FUNDED!</strong>
</div>


<p><strong>Time Left:</strong> <span id="campaignTimeLeft">Loading...</span></p>
    </section>


    <!-- Donor List -->
<section id="donorListSection" style="display: none;">
  <h2>Donors</h2>
  <ul id="donorList"></ul>
</section>


    <!-- Donate MODAL -->
    <section id="donateSection" style="display: none;">
      <h2>Make a Donation</h2>
      <form id="donateForm">
        <label for="amount">Amount (in ETH):</label>
        <input type="number" id="amount" step="0.01" placeholder="Enter Donation Amount" required>

        <label for="pseudonym">Pseudonym (Optional):</label>
        <input type="text" id="pseudonym" placeholder="Your Pseudonym">

        <button type="submit">Donate</button>
      </form>
    </section>
  </main>


    <!--PAYMENT/SIGN MODAL -->
    <!-- <dialog id="paymentModal" class="modal"> -->
    <dialog id="paymentModal" >
      <article>
        <header>
          <a href="#" aria-label="Close" class="close" data-target="paymentModal"></a>
          <h2 id="paymentModalTitle">Scan QR Code to Pay/Sign</h2>
        </header>
        <div id="qrCodeContainer" style="text-align: center;"></div>
        <section id="iusConnect"></section>
        <p id="countdown" style="font-size: 1.2rem; margin-top: 1rem;">Expires in: 15:00</p>
        <div id="successSection" class="success-section mt-4">
          <svg class="success-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
            <path fill="currentColor"
              d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5 0-200-89.5-200-200S145.5 56 256 56s200 89.5 200 200-89.5 200-200 200zm101.8-262.2L246.6 302.6c-5.7 6.8-15.5 8.3-22.3 2.6l-67.6-56.3c-6.8-5.7-8.3-15.5-2.6-22.3 5.7-6.8 15.5-8.3 22.3-2.6l55.3 46.1 94.7-113.8c5.7-6.8 15.5-8.3 22.3-2.6 6.8 5.7 8.3 15.5 2.6 22.3z" />
          </svg>
          <p class="mt-3 fs-5 text-success" id="successMessage">Payment Successful!</p>
        </div>
        <footer>
          <button id="closeModalBtnPaymentModal" class="outline">Close</button>
        </footer>
      </article>
    </dialog>
    <!--fin PAYMENT/SIGN Modal -->



  <!-- Wallet MODAL -->
  <dialog id="walletModal"  >
    <article class="walletWith">
        <header>
              <a href="#" aria-label="Close" class="close" data-target="walletModal"></a>
              <h3>Select Wallet</h3>
            </header>
    <div id="walletModalContent">
      
        <div class="wallet-option" onclick="connectWallet('metamask')">
        <img src="img/MetaMask_Fox.svg" alt="MetaMask" class="wallet-icon">
        <span>MetaMask</span>
      </div>
 
      <div class="wallet-option" onclick="connectWallet('iusnaturalis')">
        <img src="img/logoius.svg" alt="iusNaturalis" class="wallet-icon">
        <span>iusNaturalis</span>
      </div>
      <!-- <button onclick="closeWalletModal()">Cancel</button> -->
    </div>
    </article>
  </dialog>


  <!-- Settings MODAL -->
  <dialog id="settingsModal">
    <article>
      <header>
            <a href="#" aria-label="Close" class="close" data-target="settingsModal"></a>
            <h3>Settings</h3>
          </header>



          <label for="theme-toggle">Dark Mode:</label>
          <label class="toggle-switch">
            <input type="checkbox" id="theme-toggle">
            <span class="slider"></span>
          </label>


      <!-- <label>
          <input type="checkbox" id="notificationsToggle"> Enable Notifications
      </label> -->
      <!-- Wallet Selector -->
      <!-- <label for="walletSelector">Choose your wallet:</label>
      <select id="walletSelector" onchange="handleWalletChange()">
        <option value="metamask" selected>Metamask</option>
        <option value="iusNaturalis">Ius Naturalis</option>
        <option value="localTest">Local Test</option>
      </select> -->

      <!-- <label>
        <select id="languageSelect">
            <option value="en">English</option>
            <option value="es">Espa√±ol</option>
            <option value="fr">Fran√ßais</option>
        </select> Language
    </label> -->
  
      <!-- Dynamic Feedback -->
      <!-- <p id="walletFeedback" style="margin-top: 1rem;">Currently selected: Metamask</p> -->
    </article>
  </dialog>

  
  <div id="overlay" class="overlay"></div>

  <!-- JavaScript -->
	<script src="js/ethers-6.13.2.umd.min.js"></script>
  <script src="js/qrcode.min.js"></script>
	<script src="js/sweetalert2.all.min.js"></script>
  <script src="js/tsparticles.confetti.bundle.min.js"></script>
	<script src="js/Tone.min.js"></script> 



  <script type="module">
		// XMTP
		import { Client } from '@xmtp/xmtp-js'
		window.Client = Client;
 

    import { sha256 } from '@noble/hashes/sha256';
    import { utils } from '@noble/secp256k1';
    window.utils = utils;
    window.sha256 = sha256;
    
</script>
    
  <script>
    // Define global variables
window.options = {}; // User-specific API keys (can be empty)

	window.globalOptionsList = [
			{
                'ALCHEMY_API_KEY': 'X048z0PxuDPd5vbTiKLbWJgogG9Tvd2I',
                'INFURA_API_KEY' : 'b17405e634bd40308be3eb4fa2485c9a',
				'IPFS_GATEWAY': 'https://gateway.lighthouse.storage/ipfs/',
				"POLYBASE_DB": "https://explorer.testnet.polybase.xyz/studio/pk%2F0x97eab0841786aeae14135af5e26750626e46e2e15a412b6a319dd2ce7f323c805d67fcfb0f8ea1f27959e486e11e49926fbf4b1c2b9252daa20283e200e3b1b3%2FSTARKID/collections/STARKID",
				"ZK_PUBKEY": "2F0x97eab0841786aeae14135af5e26750626e46e2e15a412b6a319dd2ce7f323c805d67fcfb0f8ea1f27959e486e11e49926fbf4b1c2b9252daa20283e200e3b1b3"
			},
        ]
window.optionsList = [
            {
              "CONTRACT_ADDRESS": "0x23f15345392Fd2caCCaC1CE2361eA28669E8326C",
                "TOKEN_CHAIN_NAME": 'Arbitrum sepolia',
                "CHAIN_ID": '421614',
                // "TOKEN_CHAINID": '421614',
                "EXPLORER": 'https://sepolia.arbiscan.io/',
                "API": 'https://arbitrum-sepolia.infura.io/v3/b17405e634bd40308be3eb4fa2485c9a',
                "ALCHEMY_KEY": 'X048z0PxuDPd5vbTiKLbWJgogG9Tvd2I'
            }
        ]
// const paymentModal = document.getElementById("paymentModal");
// const closeModalBtn = document.getElementById("closeModalBtn");
// const qrCodeContainer = document.getElementById("qrCodeContainer");
const countdownElement = document.getElementById("countdown");

      
    // Replace with your contract ABI and address
    const CONTRACT_ABI = [ { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" }, { "inputs": [ { "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "internalType": "address", "name": "owner", "type": "address" } ], "name": "ERC721IncorrectOwner", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "operator", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "ERC721InsufficientApproval", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "approver", "type": "address" } ], "name": "ERC721InvalidApprover", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "operator", "type": "address" } ], "name": "ERC721InvalidOperator", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" } ], "name": "ERC721InvalidOwner", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "receiver", "type": "address" } ], "name": "ERC721InvalidReceiver", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "sender", "type": "address" } ], "name": "ERC721InvalidSender", "type": "error" }, { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "ERC721NonexistentToken", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" } ], "name": "OwnableInvalidOwner", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "account", "type": "address" } ], "name": "OwnableUnauthorizedAccount", "type": "error" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "approved", "type": "address" }, { "indexed": true, "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "operator", "type": "address" }, { "indexed": false, "internalType": "bool", "name": "approved", "type": "bool" } ], "name": "ApprovalForAll", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "indexed": true, "internalType": "address", "name": "creator", "type": "address" }, { "indexed": true, "internalType": "address", "name": "recipient", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "goal", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "deadline", "type": "uint256" } ], "name": "CampaignCreated", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "newGoal", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "newDeadline", "type": "uint256" } ], "name": "CampaignRenewed", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "indexed": true, "internalType": "address", "name": "contributor", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "ContributionMade", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "indexed": true, "internalType": "address", "name": "recipient", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "FundsWithdrawn", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "previousOwner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "newOwner", "type": "address" } ], "name": "OwnershipTransferred", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "from", "type": "address" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }, { "indexed": true, "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "Transfer", "type": "event" }, { "inputs": [ { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "approve", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" } ], "name": "balanceOf", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "name": "campaigns", "outputs": [ { "internalType": "address", "name": "recipient", "type": "address" }, { "internalType": "bytes", "name": "recipientPublicKey", "type": "bytes" }, { "internalType": "uint256", "name": "goal", "type": "uint256" }, { "internalType": "uint256", "name": "deadline", "type": "uint256" }, { "internalType": "uint256", "name": "raisedAmount", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" }, { "internalType": "string", "name": "_pseudonym", "type": "string" } ], "name": "contribute", "outputs": [], "stateMutability": "payable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "_recipient", "type": "address" }, { "internalType": "bytes", "name": "_recipientPublicKey", "type": "bytes" }, { "internalType": "uint256", "name": "_goal", "type": "uint256" }, { "internalType": "uint256", "name": "_durationInDays", "type": "uint256" } ], "name": "createCampaign", "outputs": [], "stateMutability": "payable", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "getApproved", "outputs": [ { "internalType": "address", "name": "", "type": "address" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" }, { "internalType": "uint256", "name": "index", "type": "uint256" } ], "name": "getContributorByIndex", "outputs": [ { "internalType": "address", "name": "", "type": "address" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" }, { "internalType": "address", "name": "contributor", "type": "address" } ], "name": "getContributorPseudonym", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" } ], "name": "getContributorsCount", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" } ], "name": "hasGoalReached", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "operator", "type": "address" } ], "name": "isApprovedForAll", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "name", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "nextTokenId", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "owner", "outputs": [ { "internalType": "address", "name": "", "type": "address" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "ownerOf", "outputs": [ { "internalType": "address", "name": "", "type": "address" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" }, { "internalType": "uint256", "name": "_newDurationInDays", "type": "uint256" }, { "internalType": "uint256", "name": "_newGoal", "type": "uint256" } ], "name": "renewCampaign", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "renounceOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "safeTransferFrom", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "internalType": "bytes", "name": "data", "type": "bytes" } ], "name": "safeTransferFrom", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "operator", "type": "address" }, { "internalType": "bool", "name": "approved", "type": "bool" } ], "name": "setApprovalForAll", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "bytes4", "name": "interfaceId", "type": "bytes4" } ], "name": "supportsInterface", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "symbol", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" } ], "name": "timeLeft", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "tokenURI", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "transferFrom", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "newOwner", "type": "address" } ], "name": "transferOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" } ], "name": "withdrawAllFunds", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" }, { "internalType": "uint256", "name": "_amount", "type": "uint256" } ], "name": "withdrawFunds", "outputs": [], "stateMutability": "nonpayable", "type": "function" } ];
    const CONTRACT_ADDRESS = "0x23f15345392Fd2caCCaC1CE2361eA28669E8326C";

    let provider, signer, contract;


    // RANDOM PROVIDER SELECTOR
		// -----------------
			// GET PROVIDER
			// -----------------
			// console.warn('CREATING PROVIDER FOR CHAIN ID:', chainId)
			// const rpcs = await getRPCsByChainId(Number(chainId));
			// const selProv = await simpleRandomProvider(rpcs);
			// const provider = await new ethers.JsonRpcProvider(selProv);
			// 	pv = provider;
			// if (!selProv) {
			// 	throw new Error('No working RPC provider found');
			// }
		
			// console.log('Selected RPC URL:', selProv);

		/**
 * Function to fetch the list of RPCs for a given chainId.
 *
 * @param {number} chainId - The chainId to search for.
 * @returns {Promise<Array<string>>} - A promise that resolves to an array of RPC URLs.
 */
 async function getRPCsByChainId(chainId) {
	console.warn('getRPCsByChainId:', chainId)
    try {
        // Fetch the data from the JSON file
        const source = await fetch("chainsv1.json");
        const data = await source.json();

        // Find the entry with the matching chainId
        const chain = data.find(entry => entry.chainId === chainId);

		ch = chain
        // If a matching chain is found, return its RPCs; otherwise, return an empty array
        if (chain && Array.isArray(chain.rpc)) {
            return chain.rpc;
        } else {
            console.warn(`No RPCs found for chainId: ${chainId}`);
            return [];
        }
    } catch (error) {
        console.error("Error fetching RPCs:", error);
        return []; // Return an empty array in case of an error
    }
}
 

async function providerChecker(providerUrl, maxAttempts = 3, delayMs = 1000) {
  let attempts = 0;

  while (attempts < maxAttempts) {
    try {
      const provider = new ethers.JsonRpcProvider(providerUrl);
      // Attempt to fetch the current block number to verify connectivity
      const blockNumber = await provider.getBlockNumber();
      console.log(`Connected successfully to ${providerUrl}. Current block number:`, blockNumber);
      return provider; // Successfully connected provider
    } catch (error) {
      attempts++;
      console.warn(
        `Attempt ${attempts} failed for provider ${providerUrl}:`,
        error.message || error
      );
      if (attempts >= maxAttempts) {
        console.error(`Failed to connect to ${providerUrl} after ${maxAttempts} attempts.`);
        return null; // Indicate failure to connect
      }
      // Wait before retrying
      await new Promise((resolve) => setTimeout(resolve, delayMs));
    }
  }
}

function replaceApiKeyPlaceholder(selectedProvider) {
    console.log('replaceApiKeyPlaceholder üëÅÔ∏è‚Äçüó®Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüëÅÔ∏è‚Äçüó®Ô∏è');

    // Access global variables
    const options = window.options || {};
    const globalOptionsList = window.globalOptionsList || [];

    // Ensure globalOptionsList has at least one object
    if (!Array.isArray(globalOptionsList) || globalOptionsList.length === 0) {
        throw new Error('globalOptionsList must be a non-empty array!');
    }

    // Define a mapping of placeholders to their respective API keys
    const apiKeyPlaceholders = {
        INFURA_API_KEY: 'INFURA_API_KEY',
        ALCHEMY_API_KEY: 'ALCHEMY_API_KEY'
    };

    // Iterate over the placeholders to check if the selectedProvider contains any of them
    for (const [placeholder, apiKeyName] of Object.entries(apiKeyPlaceholders)) {
        if (selectedProvider.includes(`$\{${placeholder}\}`)) {
            // Retrieve the API key from options or globalOptionsList
            const apiKey = options[apiKeyName] || globalOptionsList[0][apiKeyName];

            if (!apiKey) {
                throw new Error(`${apiKeyName} is missing!`);
            }

            // Replace the placeholder with the actual API key
            selectedProvider = selectedProvider.replace(`$\{${placeholder}\}`, apiKey);
            console.log(`${apiKeyName} URL:`, selectedProvider);

            return selectedProvider; // Exit early after replacing the placeholder
        }
    }

    // If no placeholder is found, return the original provider
    return selectedProvider;
}
// function replaceApiKeyPlaceholder(selectedProvider) {
//   // function replaceApiKeyPlaceholder(selectedProvider, options, globalOptionsList) {
//       console.log('replaceApiKeyPlaceholder üëÅÔ∏è‚Äçüó®Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüëÅÔ∏è‚Äçüó®Ô∏è');

//   // Define a mapping of placeholders to their respective API keys
//   const apiKeyPlaceholders = {
//     INFURA_API_KEY: globalOptionsList[0].INFURA_API_KEY,
//     ALCHEMY_API_KEY: globalOptionsList[0].ALCHEMY_API_KEY
//   };

//   // Iterate over the placeholders to check if the selectedProvider contains any of them
//   for (const [placeholder, apiKeyName] of Object.entries(apiKeyPlaceholders)) {
//     if (selectedProvider.includes(placeholder)) {
//       // Retrieve the API key from options or globalOptionsList
//       const apiKey = options[apiKeyName] || globalOptionsList?.[0]?.[apiKeyName];
//       if (!apiKey) throw new Error(`${apiKeyName} is missing!`);

//       // Replace the placeholder with the actual API key
//       selectedProvider = selectedProvider.replace(placeholder, apiKey);
//       console.log(`${apiKeyName} URL:`, selectedProvider);
//       return selectedProvider; // Exit early after replacing the placeholder
//     }
//   }

//   // If no placeholder is found, log that the URL is already valid
//   console.log("OK! URL does not contain any API key placeholder ‚úÖ ");
//   return selectedProvider;
// }


async function simpleRandomProvider(rpcs, options = {}) {
  console.log('simpleRandomProvider', rpcs);

  // Validate input
  if (!Array.isArray(rpcs) || rpcs.length === 0) {
    console.error('‚ö†Ô∏è No providers available!');
    return null;
  }

  // Shuffle the list once to avoid repeated random selection
  const shuffledProviders = [...rpcs].sort(() => Math.random() - 0.5);

  for (const providerUrl of shuffledProviders) {
    try {
      let selectedProvider = providerUrl;

      console.log('üëÅÔ∏è‚Äçüó®Ô∏è Trying Provider üëÅÔ∏è‚Äçüó®Ô∏è:', selectedProvider);
	  
    let replacedProv = replaceApiKeyPlaceholder(selectedProvider)
    
 console.log('TRY WITH PROVIDER =', replacedProv)

      // Try to connect to the selected provider with retries
      const provider = await providerChecker(replacedProv);

      // const provider = await providerChecker(selectedProvider);

      if (provider) {
        console.log('‚úÖ‚úÖ‚úÖ Connected to provider:', replacedProv);
        return replacedProv; // Exit and return the working provider
      } else {
        console.log('‚ùå Failed to connect to provider:', replacedProv);
      }
    } catch (error) {
      console.error(`‚ùå Error with provider ${providerUrl}:`, error.message);
    }
  }

  console.error('‚ö†Ô∏è All providers failed to connect!');
  return null; // No working provider found
}
 

// THEME SWITCHER

    // Function to apply the selected theme
    function applyTheme(isDarkMode) {
      document.body.className = ''; // Clear existing classes
      if (isDarkMode) {
        document.body.classList.add('dark-theme');
      } else {
        document.body.classList.add('light-theme');
      }
    }

    // Function to save settings
    function saveThemeSettings(isDarkMode) {
      localStorage.setItem('isDarkMode', isDarkMode);
    }

    // Function to load the saved theme from localStorage
    function loadSavedTheme() {
      const savedIsDarkMode = localStorage.getItem('isDarkMode') === 'true'; // Default to false if no preference is saved
      applyTheme(savedIsDarkMode);

      // Set the checkbox state based on the saved preference
      const themeToggle = document.getElementById('theme-toggle');
      themeToggle.checked = savedIsDarkMode;

      // Add event listener to the checkbox to toggle the theme
      themeToggle.addEventListener('change', (event) => {
        const isDarkMode = event.target.checked;
        applyTheme(isDarkMode);
        saveThemeSettings(isDarkMode);
      });
    }

  
	/*********************************************************************************************
		.) INIT 
  **********************************************************************************************/


// Retrieve the preferred wallet from localStorage and initialize
function initializeWalletPreference() {
    console.log('initializeWalletPreference()')
    const savedWallet = localStorage.getItem('preferredWallet');
    const walletSelector = document.getElementById('walletSelector');
    const feedback = document.getElementById('walletFeedback');

    if (savedWallet) {
    // Set the saved preference
    walletSelector.value = savedWallet;
    feedback.textContent = `Currently selected: ${ savedWallet === 'metamask' ? 'Metamask' : savedWallet === 'iusNaturalis' ? 'Ius Naturalis' : 'Local Test' }`; // Modal
    info.innerHTML += `<br>Wallet selected: ${ savedWallet === 'metamask' ? 'Metamask' : savedWallet === 'iusNaturalis' ? 'Ius Naturalis' : 'Local Test' }`; // Main page
    // Trigger the appropriate function based on the selected wallet
if (savedWallet === 'metamask') {
    initMetamask();
} else if (savedWallet === 'iusNaturalis') {
    initIusNaturalis();
} else {
    initLocalTest();
}
    } else {
    // Default to Local Test if no preference is saved
    const defaultWallet = 'localTest';
    localStorage.setItem('preferredWallet', defaultWallet);
    walletSelector.value = defaultWallet;
    feedback.textContent = 'Currently selected: Local  by default'; // Modal
    info.innerHTML += " Currently selected: Local Test by default"; // Main page
    initLocalTest();

    }
}



// Define initialization functions for each wallet type
function initMetamask() {
    console.log("Initializing Metamask...");
}

function initIusNaturalis() {
    console.log("Initializing Ius Naturalis...");
    
}

	/*********************************************************************************************
		.) PICO
		**********************************************************************************************/
    function openSettings() {
      const settingsModal = document.getElementById('settingsModal');
      settingsModal.showModal();

        // document.getElementById("darkModeToggle").addEventListener("click", async (e) => {
        //   // const darkModeToggle = document.getElementById("darkModeToggle");
        // console.log('DARK MODE')

        // });
    }


    // Open Wallet Modal
    function openWallet() {
        const walletModal = document.getElementById('walletModal');
        walletModal.showModal();

    //   document.getElementById("walletModal").style.display = "flex";
    }

       // disconnect Wallet 
       function closeWallet() {
        console.log('CLOSE/ DISCONNECT WALLET')

        const donorElement = document.getElementById("campaignDonor");
        donorElement.innerText = `User disconneted`;
        donorElement.classList.remove("success-text");

        // interchange wallet buttons...
        document.getElementById('openBUtton').style.display ='block'
        document.getElementById('closeBUtton').style.display ='none'

}

    function openCustomModal(id){
  console.log('OPEN CUSTOM MODAL')

  const modalToOpen = document.getElementById(id);
  modalToOpen.showModal();
}

    document.querySelectorAll('.close').forEach((closeButton) => {
      closeButton.addEventListener('click', (event) => {
        event.preventDefault();
        
        
        const targetModal = event.currentTarget.getAttribute('data-target');
        console.log('CLOSE MODAL TARGET: ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è', targetModal)
        document.getElementById(targetModal).close();
       
        if(targetModal == 'settingsModal') saveSettings();
        // if(targetModal == 'settingsModal')console.log('DOING SOMETHING FOR settingsmodal')
        // saveSettings() 

        else if(targetModal == 'paymentModal')console.log('DOING SOMETHING FOR paymentModal')
        // if(targetModal ==paymentModal)


      });
    });

            const darkModeToggle = document.getElementById("darkModeToggle");

         
        function loadSettings() {
                darkModeToggle.checked = localStorage.getItem("darkMode") === "true";
                // languageSelect.value = localStorage.getItem("language") || "en";
                // notificationsToggle.checked = localStorage.getItem("notifications") === "true";
            }

            function saveSettings() {
                // localStorage.setItem("darkMode", darkModeToggle.checked);
                localStorage.setItem("language", languageSelect.value);
                localStorage.setItem("notifications", notificationsToggle.checked);
            }
 


// Toggle modal
// const toggleModal = (event) => {
//   console.log('TOOGLEMODAL',event)
//   event.preventDefault();
//   const modal = document.getElementById(event.currentTarget.dataset.target);
//   if (!modal) return;
//   modal && (modal.open ? closeModal(modal) : openModal(modal));
// };

// Open modal
const openModal = (modal) => {
  console.log('OPENMODAL')

  const { documentElement: html } = document;
  const scrollbarWidth = getScrollbarWidth();
  if (scrollbarWidth) {
    html.style.setProperty(scrollbarWidthCssVar, `${scrollbarWidth}px`);
  }
  html.classList.add(isOpenClass, openingClass);
  setTimeout(() => {
    visibleModal = modal;
    html.classList.remove(openingClass);
  }, animationDuration);
  modal.showModal();
};


// Close modal
const closeModal = (modal) => {
  console.log('CLOSEMODAL')

  clearInterval(countdownInterval); // Stop countdown
  // document.getElementById("paymentModal")
  // document.getElementById("paymentModal").close(); // Close modal

  visibleModal = null;
  const { documentElement: html } = document;
  html.classList.add(closingClass);
  setTimeout(() => {
    html.classList.remove(closingClass, isOpenClass);
    html.style.removeProperty(scrollbarWidthCssVar);
    modal.close();
  }, animationDuration);
};

const closePaymentModal = (modal) => {
  console.log('closePaymentModal',modal)
  document.getElementById('paymentModal').close();

}
// Event listeners
// openModalBtn.addEventListener("click", openModal);
// closeModalBtn.addEventListener("click", closeModal);

// Close modal when clicking outside of it
paymentModal.addEventListener("click", (event) => {
  console.log('CLICKED INSIDE  paymentModal')
  if (event.target === paymentModal) {
    console.log('CLICKED OUTSIDE  paymentModal')
    // closeModal();
    document.getElementById('paymentModal').close();

  }
});

// Reset modal state when closed
paymentModal.addEventListener("close", () => {
  console.warn('RESET for clsoging paymentModal')
  qrCodeContainer.style.display = "block";
  countdownElement.style.display = "block";
  successSection.style.display = "none";
  iusConnect.innerHTML=''
});
	/*********************************************************************************************
		.) SOUNDS
		**********************************************************************************************/

	

		// // Initialize Tone.js
		// Tone.start();
		// console.log("tone started");
        
       function playtxReceived() {
        	// Initialize Tone.js
		Tone.start();
		console.log("tone started");
    
         const synth = new Tone.Synth({
           oscillator: { type: "triangle" },
           envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 }
         }).toDestination();
       
         const now = Tone.now();
         const notes = ["C4", "D4", "E4", "G4", "A4", "B4", "C5", "E5"]; // Ascending scale
         notes.forEach((note, index) => {
           synth.triggerAttackRelease(note, "16n", now + index * 0.05); // Faster timing
         });
       
         synth.triggerAttackRelease("G5", "8n", now + notes.length * 0.05); // After the arpeggio
       }
       const defaults = {
            spread: 360,
            ticks: 100,
            gravity: 0,
            decay: 0.94,
            startVelocity: 30,
        };

        function shoot() {
            confetti({
                ...defaults,
                particleCount: 30,
                scalar: 1.2,
                shapes: ["circle", "square"],
                colors: ["#a864fd", "#29cdff", "#78ff44", "#ff718d", "#fdff6a"],
            });

            confetti({
                ...defaults,
                particleCount: 20,
                scalar: 2,
                shapes: ["emoji"],
                shapeOptions: {
                    emoji: {
                        value: ["ü¶Ñ", "üåà"],
                    },
                },
            });
        }

function donationReceived(){
  

     // LAUNCH FANCY CONFETTI
     setTimeout(shoot, 0);
            setTimeout(shoot, 100);
            setTimeout(shoot, 200);

            playtxReceived()
            Swal.fire({
              position: "top-end",
              icon: "success",
              title: "Donation received",
              showConfirmButton: false,
              timer: 1500
            });
}



    // // Open Wallet Modal
    // function openWalletModal() {
    //     const wModal = document.getElementById('walletModal');
    //     wModal.showModal();

    //   document.getElementById("walletModal").style.display = "flex";
    // }

    // Close Wallet Modal
    // function closeWalletModal() {
    //   document.getElementById("walletModal").style.display = "none";
    // }

    function updateDonateButtonState() {
      const donateButton = document.querySelector("#donateForm button");
      if (!signer) {
        donateButton.disabled = true;
        donateButton.innerText = "Connect Wallet to Donate";
      } else {
        donateButton.disabled = false;
        donateButton.innerText = "Donate";
      }
    }

// Call this function whenever the wallet connection status changes

        /*********************************************************************************************
        .)  COPYFadd 
        **********************************************************************************************/
        function copy2clipboard(text) {
            let thisEl= event.target;
 
            try {
              // Check if Clipboard API is supported
              if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                  console.log('Copied to clipboard:', text);
                  showSuccessIcon(thisEl); // Use event.target to get the clicked element

                }).catch(err => {
                  console.error('Failed to copy using Clipboard API:', err);
                  fallbackCopy(text); // Fallback to execCommand if API fails
                  showSuccessIcon(thisEl); // Use event.target to get the clicked element

                });
              } else {
                  fallbackCopy(text); // Fallback for older browsers
                  showSuccessIcon(thisEl); // Use event.target to get the clicked element

              }
            } catch (err) {
              console.error('Copy failed:', err);
            }
          }
          
          function fallbackCopy(text) {
            // Create a temporary, invisible textarea
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed'; // Prevent scrolling issues
            textarea.style.opacity = '0'; // Invisible
            textarea.style.zIndex = '-1'; // Avoid modal interference
            document.body.appendChild(textarea);
            textarea.select();
            try {
              document.execCommand('copy');
              console.log('Copied to clipboard (fallback):', text);
            } catch (err) {
              console.error('Fallback copy failed:', err);
            }
            document.body.removeChild(textarea);
          }
            
          function showSuccessIcon(element) {
            const svgElement = element.closest("svg");
            if (!svgElement) return;

            
            svgElement.innerHTML = `
                <path fill="green" d="M504 75c-9.4-9.4-24.6-9.4-33.9 0L184.4 360.7l-112-112c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l128 128c9.4 9.4 24.6 9.4 33.9 0l304-304c9.3-9.4 9.3-24.6-.1-33.9z"></path>
            `;
            setTimeout(() => {
                svgElement.innerHTML = `<path fill="currentColor" d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path>`
            }, 1500);
        }



           /*********************************************************************************************
        .)  CONNECT WALLET 
        **********************************************************************************************/   
// Update the button state after connecting the wallet
async function connectWallet(walletType) {
  try {
    let ethereumProvider;

    switch (walletType) {
      case "metamask":
        if (typeof window.ethereum !== "undefined") {
          ethereumProvider = window.ethereum;
        } else {
          alert("MetaMask is not loaded or not installed .");
          return;
        }
        break;

      case "phantom":
        if (typeof window.solana !== "undefined") {
          ethereumProvider = window.solana; // Phantom uses Solana's API
        } else {
          alert("Phantom is not installed.");
          return;
        }
        break;

      case "rabby":
      case "rainbow":
        if (typeof window.ethereum !== "undefined") {
          ethereumProvider = window.ethereum;
        } else {
          alert(`${walletType.charAt(0).toUpperCase() + walletType.slice(1)} is not installed.`);
          return;
        }
        break;

      case "iusnaturalis":
        // alert("Connecting to iusNaturalis...");
        await iusConnectModal()
        return
        break;

// HACER ESTO EN ius function
        provider = new ethers.BrowserProvider(window.iusNaturalis);
        window.iusNaturalis = await  new IusNaturalisProvider(recoveredAddress);
        ethereumProvider = window.iusNaturalis;
        window.ethereum = window.iusNaturalis;
        
        break;


        // if (typeof window.ethereum !== "undefined") {
        //   console.warn("window.ethereum !== undefined .");

        //   provider = new ethers.BrowserProvider(window.iusNaturalis);
        //   window.iusNaturalis = new IusNaturalisProvider(recoveredAddress);
        //   ethereumProvider = window.iusNaturalis;
        // } else {
        //   console.warn("iusNaturalis is not loaded or not installed .");
        //     //  window.iusNaturalis = new IusNaturalisProvider(recoveredAddress);
        // provider = new ethers.BrowserProvider(window.iusNaturalis);
        // window.iusNaturalis = await  new IusNaturalisProvider(recoveredAddress);
        // ethereumProvider = window.iusNaturalis;

        //   // return;
        // }
        // break;
        // return 
        // window.iusNaturalis = new IusNaturalisProvider(recoveredAddress);
        // provider = new ethers.BrowserProvider(window.iusNaturalis);
        // window.iusNaturalis = new IusNaturalisProvider(recoveredAddress);

        // await connectToIusNaturalis();
        
        // return

        // const rpcUrl = optionsList[0].API; // Replace with your RPC URL
        // const jsonRpcProvider = new ethers.JsonRpcProvider(rpcUrl);

        // let smartcontractwallet = await contractWallet()

        // const walletWithProvider = smartcontractwallet.connect(jsonRpcProvider);
        // const customProvider = new CustomEthereumProvider(walletWithProvider, jsonRpcProvider);

        // // Assign the custom provider to window.ethereum (optional)
        // if (!window.ethereum) {
        //     window.ethereum = customProvider;
        //     ethereumProvider = window.ethereum;

        // } else {
        //     console.warn('window.ethereum already exists. Overwriting it may cause issues.');
        //     window.ethereum = customProvider;
        //     ethereumProvider = window.ethereum;

        // }

        
        // return;

      default:
        alert("Unsupported wallet.");
        return;
    }

    console.log("CONTINUE connectwallet().");

    provider = await new ethers.BrowserProvider(ethereumProvider);
    await provider.send("eth_requestAccounts", []);
    signer = await provider.getSigner();
    contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

    // document.getElementById("walletStatus").innerText = `Connected: ${await signer.getAddress()}`;
    // document.getElementById("campaignDonor").innerText = `Connected: ${await signer.getAddress()}`;
    
// // ..
//       const signerAddress = await getSignerAddress();
//       const donorElement = document.getElementById("campaignDonor");

//       // Update the text content
//       donorElement.innerText = `Connected: ${signerAddress}`;

//       // Add the blinking class to trigger the animation
//       donorElement.classList.add("blink-text");

//       // Remove the blinking class after the animation completes
//       setTimeout(() => {
//         donorElement.classList.remove("blink-text");
//       }, 1500); // 0.5s * 3 iterations = 1500ms

// // ..




    
    // closeWalletModal();
    document.getElementById('paymentModal').close();

    updateDonateButtonState(); // Update the donate button state

    stayInSync(ethereumProvider)
    // showSuccessAnimation()

  } catch (error) {
    console.error("Error connecting wallet:", error);
    // alert("Failed to connect wallet.");
  }
}


function disconnectWallet() {
    ethereumProvider.removeAllListeners('accountsChanged');
    ethereumProvider.removeAllListeners('chainChanged');
    console.log('Wallet disconnected.');
}

async function connectToIusNaturalis(){
  console.log(' connecting connecting...')
  closeWalletModal();

 
let countdownInterval;
let remainingTime = 15 * 60; // 15 minutes in seconds
  // openModal()
  iusConnectModal()

}
    // Function to parse query parameters from the URL
    function getQueryParams() {
      const params = {};
      const queryString = window.location.search.substring(1);
      queryString.split("&").forEach(pair => {
        const [key, value] = pair.split("=");
        params[decodeURIComponent(key)] = decodeURIComponent(value);
      });
      return params;
    }
// Function to load campaign details
// Function to load campaign details
async function loadCampaign(tokenId) {
  try {
    const campaign = await contract.campaigns(tokenId);

    // Check if the campaign has ended by calling `timeLeft`
    let timeLeftInSeconds;
    try {
      timeLeftInSeconds = Number(await contract.timeLeft(tokenId)); // Explicitly convert BigInt to Number
    } catch (error) {
      if (error.message.includes("Crowdfunding period has ended")) {
        // Campaign has ended, set timeLeft to 0
        timeLeftInSeconds = 0;
      } else {
        throw error; // Re-throw unexpected errors
      }
    }

    // Format goal and raised amount for display
    const goalFormatted = ethers.formatEther(campaign.goal); // Convert goal to ETH
    const raisedFormatted = ethers.formatEther(campaign.raisedAmount); // Convert raised amount to ETH

    // Update campaign details
    document.getElementById("campaignRecipient").innerText = campaign.recipient;
    document.getElementById("campaignGoal").innerText = goalFormatted;
    document.getElementById("campaignRaised").innerText = raisedFormatted;

    // Show a banner if the campaign has ended
    const campaignEndedBanner = document.getElementById("campaignEndedBanner");
    if (timeLeftInSeconds === 0) {
      campaignEndedBanner.style.display = "block"; // Show the banner
    } else {
      campaignEndedBanner.style.display = "none"; // Hide the banner
    }

    // Calculate progress percentage safely
    const goalBigInt = BigInt(campaign.goal.toString()); // Ensure goal is BigInt
    const raisedBigInt = BigInt(campaign.raisedAmount.toString()); // Ensure raised amount is BigInt
    const progressPercent = Number((raisedBigInt * 100n) / goalBigInt); // Explicit conversion to Number

    // Update progress bar
    const progressBarFill = document.getElementById("progressBarFill");
    progressBarFill.style.width = `${Math.min(progressPercent, 100)}%`;

    // Show a success banner if the goal is fully raised
    const campaignSuccessBanner = document.getElementById("campaignSuccessBanner");
    if (raisedBigInt >= goalBigInt) {
      campaignSuccessBanner.style.display = "block"; // Show the success banner
      progressBarFill.style.backgroundColor = "#4caf50"; // Green progress bar for success
    } else {
      campaignSuccessBanner.style.display = "none"; // Hide the success banner
      progressBarFill.style.backgroundColor = "#4caf50"; // Default progress bar color
    }

    // Show campaign details and donation section
    document.getElementById("campaignDetails").style.display = "block";
    document.getElementById("donateSection").style.display =
      timeLeftInSeconds > 0 && raisedBigInt < goalBigInt ? "block" : "none"; // Hide donation section if the campaign has ended or is fully funded

    // Start the countdown timer
    startCountdownTimer(timeLeftInSeconds);

    // Load and display the list of donors
    const donorListElement = document.getElementById("donorList");
    donorListElement.innerHTML = ""; // Clear previous donor list

    const contributorCount = await contract.getContributorsCount(tokenId);
    for (let i = 0; i < contributorCount; i++) {
      const contributorAddress = await contract.getContributorByIndex(tokenId, i);
      const pseudonym = await contract.getContributorPseudonym(tokenId, contributorAddress);

      const listItem = document.createElement("li");
      listItem.textContent = `${pseudonym || "Anonymous"} (${contributorAddress})`;
      donorListElement.appendChild(listItem);
    }

    // Show the donor list section
    document.getElementById("donorListSection").style.display = "block";
  } catch (error) {
    console.error(`Error loading campaign ${tokenId}:`, error);
    console.warn(`Error loading campaign ${tokenId}:`, error);
    // alert("Failed to load campaign. Please check the Campaign ID.");
  }
}

// Function to start the countdown timer
function startCountdownTimer(timeLeftInSeconds) {
  const timeLeftElement = document.getElementById("campaignTimeLeft");

  // Clear any existing interval to prevent multiple timers
  clearInterval(window.countdownInterval);

  // Update the timer every second
  window.countdownInterval = setInterval(() => {
    if (timeLeftInSeconds <= 0) {
      clearInterval(window.countdownInterval);
      timeLeftElement.innerText = "Campaign has ended";
      timeLeftElement.style.color = "red";
      return;
    }

    // Convert seconds into days, hours, minutes, and seconds
    const days = Math.floor(timeLeftInSeconds / (24 * 60 * 60));
    const hours = Math.floor((timeLeftInSeconds % (24 * 60 * 60)) / (60 * 60));
    const minutes = Math.floor((timeLeftInSeconds % (60 * 60)) / 60);
    const seconds = timeLeftInSeconds % 60;

    // Format the time string
    const timeString = `${days > 0 ? `${days}d ` : ""}${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
    timeLeftElement.innerText = timeString;

    // Decrement the time left
    timeLeftInSeconds--;
  }, 1000);
}
 
    // Handle donation form submission
document.getElementById("donateForm").addEventListener("submit", async (e) => {
      e.preventDefault();

  // Check if the wallet is connected
  if (!signer) {
    alert("Please connect your wallet before donating.");
    
    openWalletModal(); // Optionally open the wallet modal to prompt connection
    return;
  }

      const amount = ethers.parseEther(document.getElementById("amount").value);
      const pseudonym = document.getElementById("pseudonym").value || "Anonymous";

// Create the contract instance with the signer
// console.warn()
console.warn('INFO DEL CONTRACT:', CONTRACT_ADDRESS, CONTRACT_ABI, signer);
contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
cx =contract

// UNSINGNED TX
    const tokenId = getQueryParams().tokenId; // Retrieve tokenId from query params
  
    // Encode the function call using the contract ABI
  const iface = new ethers.Interface(CONTRACT_ABI);
  const data = iface.encodeFunctionData("contribute", [tokenId, pseudonym]);
console.warn('DATA:', data)

  // Create the unsigned transaction object
  unsignedTx = {
    to: CONTRACT_ADDRESS,
    value: amount.toString(),
    data: data,
    gasLimit: 100000, // Adjust gas limit as needed
    chainId: optionsList[0].CHAIN_ID, // Replace with the appropriate chain ID (e.g., 1 for Ethereum Mainnet)
  };

  console.log(unsignedTx);

  let stringedMessage = JSON.stringify(unsignedTx)
  console.log("stringedMessage: ",stringedMessage); // Check the output
// SEND MESSAGE
  // Define the code for the message type
            const chatCode = "paymentSign0x22"; // Example: Replace with the appropriate code
            
            // // Format the message by prepending the code
            const formattedMessage = `${chatCode} ${stringedMessage}`;
            
            // // Create a new conversation
            let conversation = await iusnaturalisxmtp.conversations.newConversation(peerVerifiedAddress);
            conv = conversation
            // // Send the formatted message
            await conversation.send(formattedMessage);

            return
            // make the tx
        try {
          // Call the `contribute` function
          // const tx = await contract.contribute(tokenId, pseudonym, { value: amount });
          const tx = await contract.contribute(getQueryParams().tokenId, pseudonym, { value: amount });

          console.log("Transaction Sent:", tx.hash);

          // Wait for the transaction to be mined
          const receipt = await tx.wait();
          console.log("Transaction Confirmed:", receipt);
        } catch (error) {
          console.error("Error Sending Transaction:", error);
        }

  return 
      try {
        const tx = await contract.contribute(getQueryParams().tokenId, pseudonym, { value: amount });
        await tx.wait();
        alert("Donation successful!");

        // Reload campaign details after donation
        loadCampaign(getQueryParams().tokenId);
      } catch (error) {
        console.error("Error donating:", error);
        alert("Failed to donate. Please try again.");
      }


    });

    // https://localhost:4343/don2.html?tokenId=1
    // Automatically load campaign if tokenId is present in the URL
    window.onload = async () => {
    loadSavedTheme();

 // RANDOM PROVIDER SELECTOR
		// -----------------
			// GET PROVIDER
			// -----------------
			// console.warn('CREATING PROVIDER FOR CHAIN ID:', chainId)
      let chainId=optionsList[0].CHAIN_ID
			const rpcs = await getRPCsByChainId(Number(chainId));
			const selProv = await simpleRandomProvider(rpcs);
			// window.provider = await new ethers.JsonRpcProvider(selProv);
			if (!selProv) {
				throw new Error('No working RPC provider found');
			}
		
			console.log('Selected RPC URL üß°üß°üß°:', selProv);


    // window.provider = new ethers.JsonRpcProvider(selProv);
    provider = new ethers.JsonRpcProvider(optionsList[0].API);
    // window.provider = new ethers.JsonRpcProvider(optionsList[0].API);
    // const provider = new ethers.JsonRpcProvider(optionsList[0].API);
  contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);

    const queryParams = getQueryParams();
    if (queryParams.tokenId) {
    // document.getElementById("tokenId").value = queryParams.tokenId; // Pre-fill the input field
    await loadCampaign(queryParams.tokenId); // Load the campaign details
    }

    updateDonateButtonState();

    // Event listeners
    // openModalBtn.addEventListener("click", openModal);
    document.getElementById('closeModalBtnPaymentModal').addEventListener("click", closePaymentModal);
    // loadSavedTheme();


		// // Initialize Tone.js
		// Tone.start();
		// console.log("tone started");
        
    // Add event listener to close modal when clicking outside
    // const overlay = document.getElementById('overlay');
    // overlay.addEventListener('click', closeModal);

    };




    // Function to show the success animation
function showSuccessAnimation() {
  // Hide QR code and countdown
  qrCodeContainer.style.display = "none";
  countdownElement.style.display = "none";

  // Show success section
  // successMessage.innerText = 'Connected!'
  successSection.style.display = "flex";
  iusConnect.innerHTML=''
}


// ----------------------------------
// HACK TO COMMUNICATE THROUGH XMTP
// ----------------------------------
async function createXMTPClient(wallet, databaseEncryptionKey) {
  // If no databaseEncryptionKey is provided, generate a new one
  if (!databaseEncryptionKey) {
    databaseEncryptionKey = new Uint8Array(32);
    crypto.getRandomValues(databaseEncryptionKey);
    console.log('Generated new databaseEncryptionKey:', databaseEncryptionKey);
  }

  console.log('createXMTPClient: ', wallet, databaseEncryptionKey);

  try {
    // Creating a new XMTP client
    const xmtpClient = await Client.create(wallet, {
      env: 'dev', // Use 'production' for mainnet
      dbEncryptionKey: databaseEncryptionKey, // Required for V3
    });

    console.warn(
      'üü¢üü¢üü¢ XMTP STARTED üü¢üü¢üü¢ üî¥üü†üü°üîµ‚ö´ COMMUNICATING WITH THIS ADDRESS: ',
      wallet.address
    );

    return xmtpClient;
  } catch (error) {
    console.error('Failed to create XMTP client:', error);
    throw error; // Re-throw the error for the caller to handle
  }
}    
 

    // ---------
async function contractWallet() {
    let contractMnemonic = localStorage.getItem('contractMnemonic');
    if (!contractMnemonic) {
        console.error('NO contractMnemonic  in localStorage!');

        const randmnemonic = await ethers.HDNodeWallet.createRandom()
        contractMnemonic = randmnemonic.mnemonic.phrase;
        localStorage.setItem('contractMnemonic', contractMnemonic);

    } else {
        console.log('contractMnemonic is in localStorage!');

    }
    let contractWall = deriveAddressWallet(contractMnemonic, 0)
    return contractWall
}

// ---------------

        // Function to derive an address on demand
        async function deriveAddressWallet(mnemonic, index) {
            const basePath = "m/44'/60'/0'/0/";
            const path = `${basePath}${index}`;
            const derivedNode = ethers.HDNodeWallet.fromPhrase(mnemonic, path);
            return derivedNode
        }
// ---------------

// 2. Derive the databaseEncryptionKey
 

/**
 // HELPERS
 * Generates cryptographically secure random bytes.
 * @param {number} length - The number of bytes to generate.
 * @returns {Uint8Array} A Uint8Array containing the random bytes.
 */
 function getRandomBytes(length) {
    return crypto.getRandomValues(new Uint8Array(length));
}
/**
 * Converts a hex string to a Uint8Array.
 * @param {string} hex - The hex string.
 * @returns {Uint8Array} The corresponding Uint8Array.
 */
 function hexToUint8Array(hex) {
    return new Uint8Array(
        hex.match(/[\da-f]{2}/gi).map((byte) => parseInt(byte, 16))
    );
}

/**
 * Converts a Uint8Array to a hex string.
 * @param {Uint8Array} uint8Array - The Uint8Array to convert.
 * @returns {string} The corresponding hex string.
 */
 function uint8ArrayToHex(uint8Array) {
    return Array.from(uint8Array)
        .map((byte) => byte.toString(16).padStart(2, '0')) // Ensure each byte is 2 characters
        .join('');
}
 
 
/**
 * Concatenates two Uint8Arrays.
 * @param {Uint8Array} array1 - The first array.
 * @param {Uint8Array} array2 - The second array.
 * @returns {Uint8Array} The concatenated array.
 */
 function concatUint8Arrays(array1, array2) {
    const result = new Uint8Array(array1.length + array2.length);
    result.set(array1);
    result.set(array2, array1.length);
    return result;
}



/**
 * Derives a database encryption key from the wallet's private key.
 * @param {string} privateKey - The wallet's private key (hex string).
 * @returns {Object} An object containing the derived key and salt.
 */
async function deriveDatabaseEncryptionKey(privateKey) {
    // Generate a random salt using Web Crypto API
    const salt = getRandomBytes(16); // 16 bytes of random data

    // Define the number of iterations
    const iterations = 100000;

    // Derive the key by hashing the private key + salt repeatedly
    let derivedKey = hexToUint8Array(privateKey);
    for (let i = 0; i < iterations; i++) {
        derivedKey = sha256(concatUint8Arrays(derivedKey, salt));
    }

    // Log the length of the derived key for debugging
    console.log('Derived Key Length (bytes):', derivedKey.length);

    // Ensure the derived key is exactly 32 bytes
    if (derivedKey.length !== 32) {
        throw new Error(`Unexpected derived key length: ${derivedKey.length} bytes`);
    }

    // Convert the derived key to a hex string
    const derivedKeyHex = uint8ArrayToHex(derivedKey);
    console.log('Derived Key (hex):', derivedKeyHex);

    // Return the derived key and salt
    return {
        derivedKey: derivedKeyHex, // Derived key as hex string
        salt: uint8ArrayToHex(salt) // Salt as hex string
    };
}




// ENCRYPT DECRYPT FUNCTIONS 
/**
 * Encrypts data using AES-CBC with the derived key.
 * @param {string} plaintext - The data to encrypt.
 * @param {string} key - The encryption key (hex string).
 * @returns {Promise<Object>} An object containing the IV and ciphertext.
 */
 async function encryptData(plaintext, key) {
    const encoder = new TextEncoder();
    const cryptoKey = await crypto.subtle.importKey(
        'raw',
        hexToUint8Array(key), // Convert hex key to Uint8Array
        { name: 'AES-CBC' },
        false,
        ['encrypt']
    );

    // Generate a random initialization vector (IV)
    const iv = crypto.getRandomValues(new Uint8Array(16));

    // Encrypt the plaintext
    const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-CBC', iv },
        cryptoKey,
        encoder.encode(plaintext)
    );

    // Return the IV and ciphertext as byte arrays
    return {
        iv: Array.from(iv),
        ciphertext: Array.from(new Uint8Array(encrypted))
    };
}

/**
 * Decrypts data using AES-CBC with the derived key.
 * @param {Object} encryptedData - The encrypted data (IV and ciphertext).
 * @param {string} key - The decryption key (hex string).
 * @returns {Promise<string>} The decrypted plaintext.
 */
async function decryptData(encryptedData, key) {
    const cryptoKey = await crypto.subtle.importKey(
        'raw',
        hexToUint8Array(key), // Convert hex key to Uint8Array
        { name: 'AES-CBC' },
        false,
        ['decrypt']
    );

    // Decrypt the ciphertext
    const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-CBC', iv: new Uint8Array(encryptedData.iv) },
        cryptoKey,
        new Uint8Array(encryptedData.ciphertext).buffer
    );

    // Decode the plaintext
    const decoder = new TextDecoder();
    return decoder.decode(decrypted);
}


/**
 * Initializes the database encryption process.
 */
 
 async function initializeDatabaseEncryption() {
    try {
      
      // 000
      // let contractMnemonic = localStorage.getItem('contractMnemonic');
      let derivedKey =   localStorage.getItem('dbEncryptionSalt');
      
      if (!derivedKey) {
        console.error('NO dbEncryptionSalt  in localStorage!');

        // Step 1: Get the wallet
        const wallet = await contractWallet();

        // Step 2: Derive the database encryption key
        const { derivedKey, salt } = await deriveDatabaseEncryptionKey(wallet.privateKey);
    
        // Step 3: Store the salt securely (e.g., in localStorage)
        localStorage.setItem('dbEncryptionSalt', salt);
    
        // Step 4: Use the derivedKey for encryption/decryption
        console.log('Derived Database Encryption Key:', derivedKey);

        // // Example: Encrypt some data
        const plaintext = 'Sensitive data';
        const encrypted = await encryptData(plaintext, derivedKey);
        console.log('Encrypted Data:', encrypted);
    
        // Example: Decrypt the data
        const decrypted = await decryptData(encrypted, derivedKey);
        console.log('Decrypted Data:', decrypted);


    } else {
        console.log('dbEncryption Salt is in localStorage!');

    }
        // 000

return derivedKey
    } catch (error) {
        console.error('Error initializing database encryption:', error);
    }
}

// Call the function
// initializeDatabaseEncryption();


        // ----------------------------------


    // Function to open the modal and generate QR code
  async function iusConnectModal() {
      console.warn('iusConnectModal()')
      // closeWalletModal();

    // let countdownInterval;
    // let remainingTime = 15 * 60; // 15 minutes in seconds

        const successSection = document.getElementById("successSection");

        // modify title
        document.getElementById('paymentModalTitle').innerText='To login to the app, please sign this message with your wallet'
        // document.getElementById('paymentModalTitle').innerText='Connect'


        console.log("üí¢üí´üôÉ Initializing and connecting to Ius Naturalis wallet...");

        // Create  address for this site to communicate with the user
        let smartcontractwallet = await contractWallet()

        let databaseEncryptionKey = await initializeDatabaseEncryption();
            
        const iusnaturalisxmtp = await createXMTPClient(smartcontractwallet,databaseEncryptionKey);
        window.iusnaturalisxmtp = iusnaturalisxmtp; // make GLOBAL


        console.log('isNOTConnected!')
          
         // ...................................................
         // NEW MESSAGE TO SIGN USING ETH_REQUESTACCOUNTS v2 
         let uniqueTopic = `request-accounts-${Date.now()}`;
         
         let requestPayload = {
           action: 'eth_requestAccounts',
           nonce: crypto.randomUUID(), // Unique identifier for this session
           xmtpTopic: uniqueTopic, // Custom topic for XMTP messages
           requester: smartcontractwallet.address // Custom topic for XMTP messages
           
          };
          r = requestPayload
          
          let qrCodeData = requestPayload
          q = qrCodeData
          
          document.getElementById('paymentModalTitle').innerText=`To login to the app, please sign this message with your wallet. Unique ID: ${requestPayload.nonce}`

         const jsonString = JSON.stringify(requestPayload, (key, value) =>
             typeof value === 'bigint' ? value.toString() : value
         );
         const escapedJsonString = JSON.stringify(jsonString)
             .replace(/"/g, '&quot;') // Replace double quotes with HTML-escaped equivalent
             .replace(/'/g, '&#39;'); // Replace single quotes with HTML-escaped equivalent

         let unescapedJsonString = JSON.stringify(jsonString)

         js = escapedJsonString

         // ...................................................
         // MESSAGE TO SIGN
         // let messageToSign = "I am logging with IusNaturalis";
         let m = `${escapedJsonString}`;

         document.getElementById('iusConnect').innerHTML = ` <div class=" responsive-svg" id="canvas"></div> 
                <svg class='copy2clipboard' id='' onclick="event.stopPropagation();copy2clipboard('${m}')" xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"> <path  fill='currentColor' d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"/> </svg>
                 <div id="result"> </div> `


    // Generate QR Code
    QRCode.toCanvas(m, { width: 256 }, (error, canvas) => {
      // QRCode.toCanvas(txRequest, { width: 256 }, (error, canvas) => {
      if (error) {
        console.error("Error generating QR code:", error);
        return;
      }
      qrCodeContainer.innerHTML = ""; // Clear previous QR code
      qrCodeContainer.appendChild(canvas); // Append new QR code
    });

    // Reset countdown
    remainingTime = 15 * 60;
    updateCountdown();

      // Show modal
    // paymentModal.showModal();
    // closeWalletModal();
    document.getElementById('walletModal').close();
    document.getElementById('paymentModal').showModal();

    // Start countdown
    startCountdown();


    // CONTINUE BY LISTENING TO COMM
    await listenToAllMessages(iusnaturalisxmtp, qrCodeData)


}



 // ---------------------------------------------
 // Start Listening to All Messages
 // ---------------------------------------------

 // Global State to Track Conversations
 const activeChats = new Map(); // Tracks open chat streams
 let messageStore = {}; // Stores all messages grouped by address
 let abortController;


 async function listenToAllMessages(xmtpClient, messageInput) {

     console.log('listenToAllMessages()')

     // Create an AbortController to manage the stream
     abortController = new AbortController();
     const {
         signal
     } = abortController;
     // check address sender is not this page
     let smartcontractwallet = await contractWallet()
     let smartcontractAddr = smartcontractwallet.address;

     try {
         for await (const message of await xmtpClient.conversations.streamAllMessages({
             signal
         })) {


             if (message.senderAddress === smartcontractAddr) {
                 console.log(`üì£ conversation from yourself`);
                //  console.log(`üì£ conversation from yourself`, smartcontractAddr, message.content);

                 continue;
             }


             console.log(`üéÉ New message from [${message.senderAddress}]: ${message.content}`);

             peerAddress= message.senderAddress;
             // Add message to the global message store
             if (!messageStore[message.senderAddress]) {
                 messageStore[message.senderAddress] = [];
             }

             messageStore[message.senderAddress].push({
                 content: message.content,
                 timestamp: message.sent,
             });



             // Notify the UI or state manager
            console.warn('MESSAGE:', message.senderAddress, message.content, messageInput);
            let recoveredAddress = ethers.verifyMessage(JSON.stringify(messageInput), message.content);
            console.warn(`Logged in as: ${recoveredAddress}`);

            peerVerifiedAddress= recoveredAddress;
             
            // const signer = await provider.getSigner(recoveredAddress);
            
            // document.getElementById("walletStatus").innerText = `Connected: ${recoveredAddress}`;
            document.getElementById("campaignDonor").innerText = `Connected: ${recoveredAddress}`;
            successMessage.innerText = `Conneted as: ${recoveredAddress}`
            document.getElementById('paymentModalTitle').innerText='Perfect!'
            
            window.iusNaturalis = new IusNaturalisProvider(recoveredAddress);
            provider = new ethers.BrowserProvider(window.iusNaturalis);
             signer = await provider.getSigner();
        ethereumProvider = window.iusNaturalis;
        window.ethereum = window.iusNaturalis;

        // ---
        // provider = new ethers.BrowserProvider(window.iusNaturalis);
        // window.iusNaturalis = await  new IusNaturalisProvider(recoveredAddress);
        // signer = await provider.getSigner();
        // ethereumProvider = window.iusNaturalis;
        // window.ethereum = window.iusNaturalis;
        // ---
             
            showSuccessAnimation()
            // document.getElementById('connectWalletBtn').style.display ='none'
       

            // CONTINUAR LOGICA DE connectWallet par ius aqui√∑
  // document.getElementById("walletStatus").innerText = `Connected: ${await signer.getAddress()}`;
  // document.getElementById("campaignDonor").innerText = `Connected: ${await signer.getAddress()}`;



        const signerAddress = await signer.getAddress();
        const donorElement = document.getElementById("campaignDonor");

    // closeWalletModal();
    updateDonateButtonState(); // Update the donate button state
    setTimeout(() => {
      // alert('CLOSE PAYMENT MODAL...')
      document.getElementById('openBUtton').style.display ='none'
      document.getElementById('closeBUtton').style.display ='block'
      document.getElementById('paymentModal').close();


// ..
  // Update the text content with a checkmark
  donorElement.innerText = `Connected: ${signerAddress} ‚úÖ`;

// Add the success class to trigger the animation
donorElement.classList.add("success-text");

// Remove the success class after the animation completes
// setTimeout(() => {
//   donorElement.classList.remove("success-text");
// }, 800); // 0.5s for the animation duration

// // Update the text content
      // donorElement.innerText = `Connected: ${signerAddress}`;

      // // Add the blinking class to trigger the animation
      // donorElement.classList.add("blink-text");

      // // Remove the blinking class after the animation completes
      // setTimeout(() => {
      //   donorElement.classList.remove("blink-text");
      // }, 1500); // 0.5s * 3 iterations = 1500ms

// ..


    }, 1000);
    return
    stayInSync(ethereumProvider)

            //  FILTER???

             // ....................
         }
     } catch (err) {
         if (err.name === 'AbortError') {
             console.log('Stopped listening to all messages.');
         } else {
             console.warn('Error in streamAllMessages:', err);
         }
     }
 }



  // ---------------------------------------------
 // INJECT PROVIDER
 // ---------------------------------------------
//  import { ethers } from "ethers";

class IusNaturalisSigner extends ethers.AbstractSigner {
    // Remove type annotations and private keyword (not valid in JS)
    constructor(provider, address) {
        super(provider);
        this.provider = provider;
        this._address = ethers.getAddress(address); // Validate and format the address
    }

    async getAddress() {
      alert('is naturalis getAddress')
        return this._address;
    }

    async signMessage(message) {
        const messageBytes = typeof message === 'string' 
            ? ethers.toUtf8Bytes(message) 
            : message;
        return this.provider.send('personal_sign', [
            ethers.hexlify(messageBytes), 
            this._address
        ]);
    }

    async signTransaction(transaction) {
        const tx = await ethers.resolveProperties(transaction);
        return this.provider.send('eth_signTransaction', [tx]);
    }

    async sendTransaction(transaction) {
        const tx = await ethers.resolveProperties(transaction);
        const hash = await this.provider.send('eth_sendTransaction', [tx]);
        return this.provider.getTransaction(hash);
    }
}

class IusNaturalisProvider {
  constructor(address) {
    this.isIusNaturalis = true;
    this._events = {};
    this._address = ethers.getAddress(address); // Validate and format the address
  }

  // Core method for handling JSON-RPC requests
  async request({ method, params }) {
    // alert('_sendToWalletBackend')
    const response = await this._sendToWalletBackend(method, params);

    if (response.error) {
      throw new Error(response.error.message);
    }

    return response.result;
  }

  // ... (keep existing on/removeListener methods)

  async _sendToWalletBackend(method, params) {
    return {
      jsonrpc: "2.0",
      id: 1,
      result: await this._handleMethod(method, params),
    };
  }
  async _handleMethod(method, params) {
  switch (method) {
    case "net_version":
      // Return the chain ID as a string (e.g., "1" for Ethereum Mainnet)
      return "1"; // Replace with the actual chain ID of your network

    case "eth_chainId":
      // alert('get eth_chainId');
      // Return the chain ID as a hex string (e.g., "0x1" for Ethereum Mainnet)
      return optionsList[0].TOKEN_CHAINID; // Replace with the actual chain ID in hex format
      
      // return "0x1"; // Replace with the actual chain ID in hex format

    case "eth_requestAccounts":
      return [this._address];

    case "eth_accounts":
      return [this._address];

    case "personal_sign":
      if (params[1].toLowerCase() !== this._address.toLowerCase()) {
        throw new Error("Invalid address");
      }
      return "0x_signed_message_hash";

    case "eth_sendTransaction":
      alert('sendign transaction!')
      params[0].from = this._address;
      return "0x_transaction_hash";

      case "eth_blockNumber":
      // Return the current block number as a hex string
      // return "0x" + (await ethers._getBlockNumber()).toString(16);
      return "0x" + (await this._getBlockNumber()).toString(16);


    default:
      throw new Error(`Method ${method} not supported`);
  }
}

  // Helper method to fetch or mock the block number
  async _getBlockNumber() {
    // Option 1: Fetch the block number from a real Ethereum node
    console.warn('using helper method for geblocknumber')
    const fallbackProvider = new ethers.JsonRpcProvider(optionsList[0].API);
    return await fallbackProvider.getBlockNumber();

    // Option 2: Mock the block number for testing
    // return 18_000_000; // Replace with a mock block number
  }
 
}
 
 // ---------------------------------------------
 // UPDATE CONVERSATIONS
 // ---------------------------------------------
 // Conversation List UI Updates
 // Maintain a list of conversations with their last message and timestamps:
 async function updateConversationList(address, signature, messageInput) {
     console.log(`üôÜ‚Äç‚ôÇÔ∏è üôÜ‚Äç‚ôÇÔ∏è üôÜ‚Äç‚ôÇÔ∏èUpdated conversation with ${address}: ${signature}`);
     // Update the UI or state with the latest conversation data

     // let signature = lastMessage;
     sig = signature;
     msg = messageInput;
     let recoveredAddress = ethers.verifyMessage(JSON.stringify(messageInput), signature);
     // let recoveredAddress = ethers.verifyMessage(messageInput);
     rx = recoveredAddress
     console.warn(`Logged in as: ${recoveredAddress}`);
     alert(`Logged in as: ${recoveredAddress}`);


    
     return
 
 }


function iusPayModal() {

  // modify title
  document.getElementById('paymentModalTitle').innerText='Pay'

  // Simulate generating a transaction request or payment link
  const txRequest = "ethereum:0xYourContractAddress?value=10000000000000000"; // Example Ethereum URI

  // Generate QR Code
  QRCode.toCanvas(txRequest, { width: 256 }, (error, canvas) => {
    if (error) {
      console.error("Error generating QR code:", error);
      return;
    }
    qrCodeContainer.innerHTML = ""; // Clear previous QR code
    qrCodeContainer.appendChild(canvas); // Append new QR code
  });

  // Reset countdown
  remainingTime = 15 * 60;
  updateCountdown();

  // Show modal
  paymentModal.showModal();

  // Start countdown
  startCountdown();
}
// Function to close the modal
// function closeModal() {
//   clearInterval(countdownInterval); // Stop countdown
//   // document.getElementById("paymentModal")
//   document.getElementById("paymentModal").close(); // Close modal
// }


// Function to start the countdown
function startCountdown() {
  countdownInterval = setInterval(() => {
    remainingTime--;
    if (remainingTime <= 0) {
      clearInterval(countdownInterval);
      closeModal();
    }
    updateCountdown();
  }, 1000);
}

// Function to update the countdown display
function updateCountdown() {
      // Select DOM elements
    // const openModalBtn = document.getElementById("openModalBtn");
const countdownElement = document.getElementById("countdown");



  const minutes = Math.floor(remainingTime / 60);
  const seconds = remainingTime % 60;
  countdownElement.textContent = `Expires in: ${minutes}:${seconds < 10 ? "0" : ""}${seconds}`;
}



function stayInSync(ethereumProvider){
console.log('stayInSync()')

// STAY IN SYNC WITH WALLLET STATE
// Listen for account changes
ethereumProvider.on('accountsChanged', async (accounts) => {
    console.log('Accounts changed:', accounts);
    if (accounts.length === 0) {
        console.warn('User disconnected their wallet.');
    } else {
        const signer = await provider.getSigner();
        console.warn('New connected account:', await signer.getAddress());
    }
});

// Listen for chain changes
ethereumProvider.on('chainChanged', (chainId) => {
    // alert('Network changed:', chainId, '...RELOADING');
    alert('Network changed ...RELOADING');
    // Optionally reload the page or update the app state
    window.location.reload();
});
}



// Prepare the transaction
async function prepareTransaction() {
    try {
        // Estimate gas limit (optional but recommended)
        const gasLimit = await contract.contribute.estimateGas(tokenId, pseudonym, { value: contributionAmount });

        // Send the transaction
        const tx = await contract.contribute(tokenId, pseudonym, {
            value: contributionAmount,
            gasLimit: gasLimit // Optional: Use the estimated gas limit
        });

        console.log(`Transaction sent! Tx hash: ${tx.hash}`);

        // Wait for the transaction to be mined
        const receipt = await tx.wait();
        console.log(`Transaction mined in block ${receipt.blockNumber}`);
    } catch (error) {
        console.error("Error sending transaction:", error);
    }
}


// Prepare the transaction for signing
async function prepareTransactionForSigning(senderAddress,tokenId,pseudonym,contributionAmount) {


// Replace these with your actual values
const CONTRACT_ADDRESS = optionsList[0].CONTRACT_ADDRESS;
const CONTRACT_ABI = [ "function contribute(uint256 _tokenId, string memory _pseudonym) external payable" ];




provider = new ethers.JsonRpcProvider(optionsList[0].API);
      // const provider = new ethers.JsonRpcProvider(optionsList[0].API);
      // contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);


      // let tokenId;
      const queryParams = getQueryParams();
      if (queryParams.tokenId) {
        // document.getElementById("tokenId").value = queryParams.tokenId; // Pre-fill the input field
        loadCampaign(queryParams.tokenId); // Load the campaign details
        tokenId = queryParams.tokenId
      } else{
        tokenId = 1; //set as default
      }



 
// const pseudonym =  document.getElementById("pseudonym").value || "Anonymous"; // Example pseudonympseudonym
// const contributionAmount = document.getElementById("amount").value; // Example contribution amount (0.1 ETH)
// const contributionAmount = ethers.parseEther("0.1"); // Example contribution amount (0.1 ETH)

// User's address (the sender of the transaction)
// const userAddress = "0xUserAddress"; // Replace with the user's Ethereum address

// Create a contract instance
const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);

// const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, provider);
    try {
        // Get the nonce for the sender's address
        // const senderAddress = "0xUserAddress"; // Replace with the user's address
        const nonce = await provider.getTransactionCount(senderAddress);
        console.log('NONCE:',nonce)
        // Estimate, gas limit (optional but recommended)
        const gasLimit = await contract.contribute.staticCall(tokenId, pseudonym, { value: contributionAmount });

        // Encode the function call
        const data = contract.interface.encodeFunctionData("contribute", [tokenId, pseudonym]);

        // Create the transaction object
        const tx = {
            to: CONTRACT_ADDRESS,
            value: contributionAmount,
            data: data,
            gasLimit: gasLimit,
            nonce: nonce,
            chainId: optionsList[0].CHAIN_ID, // Replace with the chain ID
            type: 2, // EIP-1559 transaction type (optional, depending on the network)
            maxPriorityFeePerGas: ethers.parseUnits("2", "gwei"), // Optional: Set priority fee
            maxFeePerGas: ethers.parseUnits("20", "gwei") // Optional: Set max fee
        };

        // Serialize the transactioncontributionAmount
        const serializedTx = ethers.Transaction.from(tx).serialized;

        console.log("Serialized Transaction:", serializedTx);

        // Send this serialized transaction to the user (e.g., via XMTP)
        return serializedTx;
    } catch (error) {
        console.error("Error preparing transaction:", error);
    }
}

/**
 * Function to sign a serialized transcontributionAmountaction.
// CLIENTE !!!
 * ESTO SE HACE EN EL CLIENTE
 * @param {string} serializedTx - The serialized transaction (unsigned).
 * @param {string} privateKey - The user's private key (ensure this is secure and not exposed publicly).
 * @returns {Promise<string>} - The signed transaction (ready to be broadcasted).
 */
async function signTransaction(serializedTx, privateKey) {
    try {
        // Create a wallet instance using the private key
        const wallet = new ethers.Wallet(privateKey);

        // Parse the serialized transaction
        const tx = ethers.Transaction.from(serializedTx);

        // Sign the transaction
        const signedTx = await wallet.signTransaction(tx);

        console.log("Signed Transaction:", signedTx);

        return signedTx;
    } catch (error) {
        console.error("Error signing transaction:", error);
        throw error;
    }
}


// CLIENTE !!!
// Broadcast the signed transaction
// BROADCASTEADO AUTOMATICAMENTE POR EL CLIENTE
// SI EL CLIENTE NO TINEE INTERNET, LO PASA POR QR AL EMISO
async function broadcastTransaction(signedTx) {

  
    try {
        const txResponse = await provider.broadcastTransaction(signedTx);
        console.log("Transaction broadcasted! Tx hash:", txResponse.hash);

        // Wait for the transaction to be mined (optional)
        const receipt = await txResponse.wait();
        console.log(`Transaction mined in block ${receipt.blockNumber}`);
    } catch (error) {
        console.error("Error broadcasting transaction:", error);
    }
}



async function sendSignedMessage(xmtpClient, address, messageContent) {
            try {
   
				let conversation = await iusnaturalisxmtp.conversations.newConversation(address);
	
				// Send the message
                await conversation.send(messageContent);
                console.log(`Message sent to ${address}: ${messageContent}`);

                // Optionally, add the sent message to the message store
                if (!messageStore[address]) {
                messageStore[address] = [];
                }
                messageStore[address].push({
                content: messageContent,
                timestamp: new Date(),
                sender: 'self', // Mark it as sent by the user
                });

                // Update the chat window
                // updateChatWindow(address, messageContent);
            } catch (err) {
                console.error(`Failed to send message to ${address}:`, err);
            }
        }
    // -----------------------------------------
            // NEW STEALTH ADDRESS FUNCTIONS
            // -----------------------------------------
            async function generateStealthAddress(privateKey, publicKey) {
                // privkey sender, pubkey recipient
                console.warn('üè∞ generateStealthAddress()', privateKey, publicKey)
                const privateKeyHex = `0x${toHexString(privateKey)}`;
                a = privateKeyHex
                b = publicKey
                c = privateKey
                const pubPoint = secp.ProjectivePoint.fromHex(publicKey);
                ppoint = pubPoint
                const sharedSecret = pubPoint.multiply(BigInt(privateKeyHex)).toHex();
                console.log('üë´sharedSecret( at generateStealthAddress):', sharedSecret);
                const hashedSecret = ethers.keccak256('0x' + sharedSecret).slice(0, 42);
    
                // 1.Multiply hs by the curve generator point (G): You can use the secp256k1 generator point (which is a constant) to compute the point hs * G.
                const G = secp.ProjectivePoint.BASE;  // Generator point G
                const hsBigInt = BigInt(hashedSecret);  // hs should already be in hex or BigInt format
                const hsPoint = G.multiply(hsBigInt);  // hs * G
                hsp = hsPoint
    
                // 2.Add Bob‚Äôs public key: You now add Bob‚Äôs public key as an elliptic curve point to hs * G. Ensure Bob's public key is in the correct format for the addition.
                const point = secp.ProjectivePoint.fromHex(publicKey);  // Bob's public key point
                const stealthPubPoint = hsPoint.add(point);  // hs * G + Bob's public key
                p1 = point
                p2 = stealthPubPoint
    
                // 3.Convert the resulting point to an Ethereum address: Finally, you convert the resulting elliptic curve point to an Ethereum address. This is typically done by compressing the point to its x-coordinate, hashing it, and then converting it to an Ethereum address.
                const stealthPubKey = stealthPubPoint.toHex();  // Convert to hex
                const stealthAddress = ethers.computeAddress('0x' + stealthPubKey);  // Convert to Ethereum address
                console.log('üëªStealth Address:', stealthAddress);
                return { stealthAddress, sharedSecret }
            }
    



            // ##################################
            // CHATCODES
          
            
            // Declare all chatCodes here
const chatCodeHandlers = {
  paymentSign0x22: handleSignPayment,
  paymentReceived0x21: handlePaymentReceived,
  peerGasPaymentAccepted0x21: handleGasPaymentAccepted,
  peerGasPaymentRequest0x20: handleGasPaymentRequest,
  addToken0x19: handleAddToken,
};

async function handleChatCodes(message) {
  const content = message.content.trim(); // Trim whitespace for consistency

  // Extract the code from the beginning of the message
  const codeEndIndex = content.indexOf(" ");
  const code = codeEndIndex === -1 ? content : content.slice(0, codeEndIndex);

  // Check if the code exists in the handlers map
  if (chatCodeHandlers[code]) {
    // Extract the rest of the message (if any) after the code
    const remainingMessage = codeEndIndex === -1 ? "" : content.slice(codeEndIndex + 1).trim();

    // Call the corresponding handler with the full message and remaining content
    await chatCodeHandlers[code]({ ...message, content: remainingMessage });
  } else {
    console.warn(`Unknown chat code: ${code}`);
  }
}

// Example handler functions
async function handleSignPayment(message) {
  console.log("Handling SIGN PAUMENT:", message);

}

async function handlePaymentReceived(message) {
  console.log("Handling payment received:", message);
}

async function handleGasPaymentAccepted() {
  console.log("Handling gas payment accepted");
}

async function handleGasPaymentRequest(message) {
  console.log("Handling gas payment request:", message);
}

async function handleAddToken(message) {
  console.log("Handling add token:", message);
}

// USAGE
  // Define the code for the message type
            // const chatCode = "paymentReceived0x21"; // Example: Replace with the appropriate code
            
            // // Original message content
            // const originalMessage = "Transaction successful";
            
            // // Format the message by prepending the code
            // const formattedMessage = `${chatCode} ${originalMessage}`;
            
            // // Create a new conversation
            // let conversation = await iusnaturalisxmtp.conversations.newConversation(addr);
            
            // // Send the formatted message
            // await conversation.send(formattedMessage);


  </script>
</body>
</html>