<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MetaMask Stealth Donations</title>
    <!-- Include Pico CSS -->
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"> -->
    <!-- <link rel="stylesheet" href="css/pico@1.min.css" /> -->
    <!-- pico v2 -->
    <link rel="stylesheet" href="css/pico.min.css" />
    <script src="js/sweetalert2.all.min.js"></script>
    <script src="js/ethers-6.13.2.umd.min.js"></script>

    <style>
              .container {
                width: 100%;
            }
    
            .row {
                display: flex;
                flex-wrap: wrap;
                margin-bottom: 20px;
            }
    
            .col {
                flex: 1;
                min-width: 300px;
                padding: 10px;
            }
    </style>
    <!-- Include MetaMask SDK -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/@metamask/sdk@latest/dist/browser/metamask-sdk.min.js"></script> -->
</head>

<body>

    <div class="row">

        

    <div class=" col">
        <h3>ALICE (METAMASK)</h3>

        <!-- <h1>MetaMask Stealth Donations </h1>
        <p>Given Bob's public key: 03c2ceb90237c4eca2a8ce51c1f2d217f860dcb8909cdc9e2c9b5a038e70f6eb9c</p> -->
        <p id="status">Status: Not Connected</p>
        <button id="connectButton" class="contrast">Connect to MetaMask</button>
        <p id="accountDisplay" style="display: none;">Connected Account: <span id="account"></span></p>
        <!-- </main> -->

        <!-- <main class="container"> -->
        <h1>Sign to create your Stealth Address (proxy address)</h1>
         <button id="signButton" class="secondary" style="display: none;">Create proxy address (personal_sign)</button>
        <p id="signatureDisplay" style="display: none;">Signature: <span id="signature"></span></p>


        <button id="signButtonMS" class="secondary" style="display: none;">Create proxy address (eth_signTypedData_v4)</button>
        <p id="stealthAddressDisplay" style="display: none;">Stealth Address: <span id="stealthAddress"></span></p>

    <!-- </main> -->
    Address: <span id="aliceAddress" class="addr"></span><br>
    Public Key: <span id="alicePubkey" class="addr"></span><br>
    
    <span id="aliceSharedSecret" class="addr"></span>
    <span id="aliceBalance" class="balance"></span>
    <span id="aliceGas" class="balance"></span>

    <fieldset role="group">
        <input type="number" id="aliceAmount" placeholder="Amount to send" step="0.01" min="0" required>
        <input type="button" id="aliceSendButton" value="Send to bob StAddr" />
    </fieldset>

    <span id="aliceTx" class="balance"></span>

    <div id="aliceNotifications"></div>

    </div> 

       <!-- Columna B - BOB -->
       <div class=" col">
        <h3>BOB (Stealth Donations DApp)</h3>
        Address: <span id="bobAddress" class="addr"></span><br>
        Public Key: <span id="bobPubkey" class="addr"></span><br>
        
        <span id="bobSharedSecret" class="addr"></span>
        <span id="bobBalance" class="balance"></span>
        <span id="bobGas" class="balance"></span>

        <fieldset role="group">
            <input type="number" id="bobAmount" placeholder="Amount to send" step="0.01" min="0" required>
            <input type="button" id="bobSendButton" value="Send to alice StAddr" />
        </fieldset>

        <span id="bobTx" class="balance"></span>

        <div id="bobNotifications"></div>
    </div>


    <!-- fin row -->
    <script type="module">
        import hexer from 'browser-string-hexer';
        window.hexer = hexer;


        import { getPublicKey, utils } from '@noble/secp256k1';
        window.getPublicKey = getPublicKey;
        window.utils = utils;
        
        import * as secp from '@noble/secp256k1';
        window.secp = secp;


        // import { sha256 } from '@noble/hashes/sha256';
        // window.sha256 = sha256;

        // import { utf8ToBytes } from '@noble/hashes/utils';
        // window.utf8ToBytes = utf8ToBytes;


        import { MetaMaskSDK } from "@metamask/sdk"
        window.MetaMaskSDK = MetaMaskSDK;

    </script>
    <script>
        window.globalOptionsList = [
            {
                'INFURA_API_KEY': 'b17405e634bd40308be3eb4fa2485c9a',
                'ALCHEMY_API_KEY': 'X048z0PxuDPd5vbTiKLbWJgogG9Tvd2I',
                'IPFS_GATEWAY': 'https://gateway.lighthouse.storage/ipfs/',
                "POLYBASE_DB": "https://explorer.testnet.polybase.xyz/studio/pk%2F0x97eab0841786aeae14135af5e26750626e46e2e15a412b6a319dd2ce7f323c805d67fcfb0f8ea1f27959e486e11e49926fbf4b1c2b9252daa20283e200e3b1b3%2FSTARKID/collections/STARKID",
                "ZK_PUBKEY": "2F0x97eab0841786aeae14135af5e26750626e46e2e15a412b6a319dd2ce7f323c805d67fcfb0f8ea1f27959e486e11e49926fbf4b1c2b9252daa20283e200e3b1b3"
            },
        ]

             // --------------------------------------------------------
            // "API": 'https://arbitrum-sepolia.blockpi.network/v1/rpc/public',
            window.optionsList = [
                {
                    "TOKEN_CHAIN_NAME": 'Arbitrum sepolia',
                    "TOKEN_CHAINID": '421614',
                    "ERC20_TOKEN_CONTRACT": "0xFb1cb5a6dADDcE008d86f72057265A3afC82d539",
                    "ERC20_TOKEN_NAME": "PDTROK",
                    "ERC20_TOKEN_ABI": 'PermitDeadlineTokenv2',
                    "EXPLORER": 'https://sepolia.arbiscan.io/',
                    "API": 'https://arbitrum-sepolia.infura.io/v3/9219faae2bac4d24b95c2d967b22005a',
                    "ABI": ' [ { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" }, { "inputs": [], "name": "AccessControlBadConfirmation", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "account", "type": "address" }, { "internalType": "bytes32", "name": "neededRole", "type": "bytes32" } ], "name": "AccessControlUnauthorizedAccount", "type": "error" }, { "inputs": [], "name": "ECDSAInvalidSignature", "type": "error" }, { "inputs": [ { "internalType": "uint256", "name": "length", "type": "uint256" } ], "name": "ECDSAInvalidSignatureLength", "type": "error" }, { "inputs": [ { "internalType": "bytes32", "name": "s", "type": "bytes32" } ], "name": "ECDSAInvalidSignatureS", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "allowance", "type": "uint256" }, { "internalType": "uint256", "name": "needed", "type": "uint256" } ], "name": "ERC20InsufficientAllowance", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "balance", "type": "uint256" }, { "internalType": "uint256", "name": "needed", "type": "uint256" } ], "name": "ERC20InsufficientBalance", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "approver", "type": "address" } ], "name": "ERC20InvalidApprover", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "receiver", "type": "address" } ], "name": "ERC20InvalidReceiver", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "sender", "type": "address" } ], "name": "ERC20InvalidSender", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" } ], "name": "ERC20InvalidSpender", "type": "error" }, { "inputs": [ { "internalType": "uint256", "name": "deadline", "type": "uint256" } ], "name": "ERC2612ExpiredSignature", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "signer", "type": "address" }, { "internalType": "address", "name": "owner", "type": "address" } ], "name": "ERC2612InvalidSigner", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "account", "type": "address" }, { "internalType": "uint256", "name": "currentNonce", "type": "uint256" } ], "name": "InvalidAccountNonce", "type": "error" }, { "inputs": [], "name": "InvalidShortString", "type": "error" }, { "inputs": [ { "internalType": "string", "name": "str", "type": "string" } ], "name": "StringTooLong", "type": "error" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "spender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [], "name": "EIP712DomainChanged", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "bytes32", "name": "role", "type": "bytes32" }, { "indexed": true, "internalType": "bytes32", "name": "previousAdminRole", "type": "bytes32" }, { "indexed": true, "internalType": "bytes32", "name": "newAdminRole", "type": "bytes32" } ], "name": "RoleAdminChanged", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "bytes32", "name": "role", "type": "bytes32" }, { "indexed": true, "internalType": "address", "name": "account", "type": "address" }, { "indexed": true, "internalType": "address", "name": "sender", "type": "address" } ], "name": "RoleGranted", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "bytes32", "name": "role", "type": "bytes32" }, { "indexed": true, "internalType": "address", "name": "account", "type": "address" }, { "indexed": true, "internalType": "address", "name": "sender", "type": "address" } ], "name": "RoleRevoked", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "from", "type": "address" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "Transfer", "type": "event" }, { "inputs": [], "name": "DEFAULT_ADMIN_ROLE", "outputs": [ { "internalType": "bytes32", "name": "", "type": "bytes32" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "DOMAIN_SEPARATOR", "outputs": [ { "internalType": "bytes32", "name": "", "type": "bytes32" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "MAX_MINT_AMOUNT", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "VALIDATOR_ROLE", "outputs": [ { "internalType": "bytes32", "name": "", "type": "bytes32" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" } ], "name": "allowance", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "approve", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "account", "type": "address" } ], "name": "balanceOf", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "decimals", "outputs": [ { "internalType": "uint8", "name": "", "type": "uint8" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "eip712Domain", "outputs": [ { "internalType": "bytes1", "name": "fields", "type": "bytes1" }, { "internalType": "string", "name": "name", "type": "string" }, { "internalType": "string", "name": "version", "type": "string" }, { "internalType": "uint256", "name": "chainId", "type": "uint256" }, { "internalType": "address", "name": "verifyingContract", "type": "address" }, { "internalType": "bytes32", "name": "salt", "type": "bytes32" }, { "internalType": "uint256[]", "name": "extensions", "type": "uint256[]" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" } ], "name": "getPermitDeadline", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "bytes32", "name": "role", "type": "bytes32" } ], "name": "getRoleAdmin", "outputs": [ { "internalType": "bytes32", "name": "", "type": "bytes32" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "bytes32", "name": "role", "type": "bytes32" }, { "internalType": "address", "name": "account", "type": "address" } ], "name": "grantRole", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "bytes32", "name": "role", "type": "bytes32" }, { "internalType": "address", "name": "account", "type": "address" } ], "name": "hasRole", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "", "type": "address" } ], "name": "lastMintTimestamp", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "mint", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "name", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" } ], "name": "nonces", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "uint256", "name": "deadline", "type": "uint256" }, { "internalType": "uint8", "name": "v", "type": "uint8" }, { "internalType": "bytes32", "name": "r", "type": "bytes32" }, { "internalType": "bytes32", "name": "s", "type": "bytes32" } ], "name": "permit", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "bytes32", "name": "role", "type": "bytes32" }, { "internalType": "address", "name": "callerConfirmation", "type": "address" } ], "name": "renounceRole", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "bytes32", "name": "role", "type": "bytes32" }, { "internalType": "address", "name": "account", "type": "address" } ], "name": "revokeRole", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "bytes4", "name": "interfaceId", "type": "bytes4" } ], "name": "supportsInterface", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "symbol", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "totalSupply", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "transfer", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" } ], "name": "transferFrom", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "nonpayable", "type": "function" } ] '
    
                },
            ]
        // DOM Elements
        const connectButton = document.getElementById('connectButton');
        const status = document.getElementById('status');
        const accountDisplay = document.getElementById('accountDisplay');
        const accountSpan = document.getElementById('account');


        // DOM Elements
        const signButton = document.getElementById('signButton');
        const signatureDisplay = document.getElementById('signatureDisplay');
        const signatureSpan = document.getElementById('signature');


        const signButtonMS = document.getElementById('signButtonMS');
        const stealthAddressDisplay = document.getElementById('stealthAddressDisplay');
        const stealthAddressSpan = document.getElementById('stealthAddress');



        async function connectWithMetamask() {
            console.log('connectWithMetamask')

            const MMSDK = new MetaMaskSDK({
                dappMetadata: {
                    name: "stealthDonations Dapp",
                    url: window.location.href,
                },
                infuraAPIKey: globalOptionsList[0].INFURA_API_KEY,
                // infuraAPIKey: 9219faae2bac4d24b95c2d967b22005a,

            })

            window.MMSDK = MMSDK;
            // Connect and get accounts
            const accounts = await MMSDK.connect()
            console.log('accounts:', accounts)

            // Update UI with connected account
            if (accounts.length > 0) {
                status.textContent = 'Status: Connected';

                let aliceAddresslink = ` <a href="${optionsList[0].EXPLORER}/address/${accounts[0]}" target="_blank">${accounts[0]}</a>`
                document.getElementById('aliceAddress').innerHTML = aliceAddresslink;
                // aliceAddress.innerHTML=accounts[0];
                currentAccount = accounts[0];
                connectButton.style.display = 'none';
                accountSpan.textContent = accounts[0];
                accountDisplay.style.display = 'block';
                signButton.style.display = 'inline-block'; // Show the create sign button
                signButtonMS.style.display = 'inline-block'; // Show the create stealth address button
            } else {
                status.textContent = 'Error: No accounts found.';
            }

            // Get provider for RPC requests
            const provider = MMSDK.getProvider()

            // Batch multiple RPC requests
            const batchResults = await provider.request({
                method: "metamask_batch",
                params: [
                    { method: "eth_accounts" },
                    { method: "eth_chainId" }
                ]
            })

            console.log('account:', batchResults[0][0])
            console.log('chaiId:', parseInt(batchResults[1], 16))

            return
        }

        const toHexString = (bytes) => {
            return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');
        };

        function removeHexPrefix(hexString) {
            // Check if the hex string starts with '0x' and remove it
            if (hexString.startsWith('0x')) {
                return hexString.slice(2);
            }
            return hexString;
        }


        // -------------------------------------------------------
        // HELPSERS FUNCTIONS
        // -------------------------------------------------------

// Hash a message using keccak256
function hashMessage(message) {
  return keccak256(new Uint8Array([...hexToBytes(message)]));
}

// Derive an ephemeral private key from a signature
function deriveEphemeralPrivateKey(signature) {
  const hash = sha256(hexToBytes(signature));
  return hash.slice(0, 32); // Use the first 32 bytes as the private key
}

// Compute the shared secret using ECDH
function computeSharedSecret(privateKey, publicKey) {
  return secp256k1.getSharedSecret(privateKey, publicKey);
}


function generateDeterministicNonce(aliceAddress, bobPublicKey, protocolId) {

    // ethers.solidityPackedKeccak256(types, values)
  const context = ethers.solidityPackedKeccak256(
    ["address", "bytes", "string"],
    [aliceAddress, bobPublicKey, protocolId]
  );
  return parseInt(context.slice(2), 16); // Convert hex to integer
}






        // -------------------------------------------------------
        // METAMASK createProxyAddress personal_sign
        // -------------------------------------------------------
        async function createProxyAddress() {
            console.log('createProxyAddress()')

            try {
                if (!currentAccount) {
                    status.textContent = 'Error: Please connect your wallet first.';
                    return;
                }


                //////////////////////////
                // CREATE DETERMINISTIC EPHIMERALL KEYPAIR (for alice)
                // alice signs BOB PUBKEY (smart contract pubkey) 
                // to deterministically create a private key for the new keypair
                //////////////////////////

                // GET BOB PUBLIC KEY
                  bobPK= document.getElementById('bobPubkey').innerHTML

                 // ...............
                // NONCE?
                let aliceAddress = currentAccount
                const protocolId = "stealthDonations-v1"; //  protocol identifier

                console.log('joinedDATA: ',aliceAddress, bobPK, protocolId);
                const nonce = generateDeterministicNonce(aliceAddress, bobPK, protocolId);
                console.log("Deterministic Nonce:", nonce);
                
                // Concatenate Bob's public key and the nonce
                const messageData = new Uint8Array([
                ...hexToBytes(bobPublicKey.slice(2)), // Remove '0x' prefix
                ...new Uint8Array(new BigUint64Array([BigInt(nonce)]).buffer), // Convert nonce to bytes
                ]);
                console.log('messageData:', messageData)
                
              // Hash the concatenated data
                let hashedData = bytesToHex(ethers.keccak256(messageData));
                console.log('hashedData:', hashedData)

                // ALICE SIGNS BOB PUBKEY
                 let params = [hashedData, currentAccount];

                // Request to sign the message
                const ethereummmsdk = mmsdk.getProvider()
                 signature = await ethereummmsdk.request({
                    method: 'personal_sign',//Prepends a safe prefix
                    params: params,//v1 messageHex. recupera bien la address
                });
                console.log('Signature:', signature);

                // ...............
                // Step: recover the address from the signed message
                const recoveredAddress = ethers.verifyMessage(hashedData, signature);//ok!!!.recupera bie la address
                console.warn('‚úÖ  ‚õìÔ∏è‚Äçüí• Recovered Address from signature:', recoveredAddress);
                
        
                // ...............
                // WRITE TO LOCALSTORAGE?


                
                // ...............
                //  ‚ñó‚ñÑ‚ññ ‚ñó‚ññ   ‚ñó‚ñÑ‚ñÑ‚ñÑ‚ññ ‚ñó‚ñÑ‚ñÑ‚ññ‚ñó‚ñÑ‚ñÑ‚ñÑ‚ññ
                // ‚ñê‚ñå ‚ñê‚ñå‚ñê‚ñå     ‚ñà  ‚ñê‚ñå   ‚ñê‚ñå   
                // ‚ñê‚ñõ‚ñÄ‚ñú‚ñå‚ñê‚ñå     ‚ñà  ‚ñê‚ñå   ‚ñê‚ñõ‚ñÄ‚ñÄ‚ñò
                // ‚ñê‚ñå ‚ñê‚ñå‚ñê‚ñô‚ñÑ‚ñÑ‚ññ‚ñó‚ñÑ‚ñà‚ñÑ‚ññ‚ñù‚ñö‚ñÑ‚ñÑ‚ññ‚ñê‚ñô‚ñÑ‚ñÑ‚ññ

                // GET USER(ALICE) PUBKEY ???
                const alicepublicKey = await derivePubkey(hashedData, signature);
                alicepubkey = alicepublicKey;
                console.log('alicepublicKey:', alicepublicKey)
                // return

                // let alicepublicKeyDehex = removeHexPrefix(alicepublicKey)
                // ...............

                // Display the signature
                signatureSpan.textContent = signature;
                signatureDisplay.style.display = 'block';
                status.textContent = 'Message signed successfully!';


                // ...............
                // CREATE ALICE STEALTH ADDRESS USING SIGNATURE AS PRIVATE KEY
                // ...............
                // Derive the ephemeral private key from the signature
                // const hash = sha256(hexToBytes(signature));
                signedHash = ethers.getBytes(ethers.keccak256(signature)); // Hash Bob's public key
                ephemeralPrivateKey = signedHash.slice(0, 32); // Use the first 32 bytes as the private key //OK
                ephPrikeyArray = ethers.hexlify(ephemeralPrivateKey)
                aliceEphemeralPublicKey = getPublicKey(ephemeralPrivateKey, true); // Compressed format
    
                console.log("Ephemeral Private Key (HEXLIFY):", ethers.hexlify(ephemeralPrivateKey));//a
                console.log("Ephemeral Public Key (HEXLIFY):", ethers.hexlify(aliceEphemeralPublicKey));//A
          

                //////////////////////////
                // PREPARE THINGS...
                //////////////////////////
                // const privateKeyHex = `0x${toHexString(privateKey)}`;
                 publicKeyHexWithoutPrefix = removeHexPrefix(bobPK);
                 BPubey = secp.ProjectivePoint.fromHex(publicKeyHexWithoutPrefix);//B
                 B= BPubey;
                aPrivkey = BigInt(ethers.hexlify(ephemeralPrivateKey))
                 a=aPrivkey;
                 console.log('prepare things:', publicKeyHexWithoutPrefix, BPubey, aPrivkey)

                  APubkey = BigInt(ethers.hexlify(aliceEphemeralPublicKey))

                 //////////////////////////
                 // COMPUTE SHARED SECRET (from alice side)
                 // s= a *B
                //  hs= hash(s)
                 //////////////////////////
                 // let alternativeAlicePrivateKey = BigInt(ethers.hexlify(ephemeralPrivateKey))
                 aliceSharedSecret = BPubey.multiply(aPrivkey).toHex();//s=a‚ãÖB
                console.warn('üë´  ALICE sharedSecret  (at generateStealthAddress):', aliceSharedSecret);
                const hashedSecret = ethers.keccak256('0x' + aliceSharedSecret).slice(0, 42);//hs
                document.getElementById('aliceSharedSecret').innerHTML += `<br><br>Shared secret (Alice side): ${aliceSharedSecret}`;
    
                //////////////////////////
                // COMPUTE STEALTH PUBKEY (alice to pay bob)
                // stPk= hs * G +B
                // hs = hash(a*B) * G +B
                //////////////////////////
                
                // 1.Multiply hs by the curve generator point (G): You can use the secp256k1 
                // generator point (which is a constant) to compute the point hs * G.
                const G = secp.ProjectivePoint.BASE;  // Generator point G
                const hs = BigInt(hashedSecret);  // hs should already be in hex or BigInt format
                const hsPoint = G.multiply(hs);  // hs * G
                
                // 2.Adition it to Bob‚Äôs public key: (hsPoint +B)
                 stealthPubPoint = hsPoint.add(BPubey);  // (hs * G) + B (Bob's public key)
                
                //////////////////////////
                // COPMUTE STEALTH ADDRESS (alice) METHOD I: with compute(public key)
                // stPk= hs * G +B
                //////////////////////////
                // 3.Convert the resulting point to an Ethereum address: Finally, you convert the resulting elliptic curve point to an Ethereum address. This is typically done by compressing the point to its x-coordinate, hashing it, and then converting it to an Ethereum address.
                alicestealthPubKey = stealthPubPoint.toHex();  // Convert to hex
                document.getElementById('alicePubkey').innerHTML = alicestealthPubKey;// IS THIS ONE OR NOT ???
                 proxyAddress = ethers.computeAddress('0x' + alicestealthPubKey);  // Convert to Ethereum address
                console.log('üëªproxyAddress Address:', proxyAddress);
                console.log('üëªALICE sharedSecret:', aliceSharedSecret);
               document.getElementById('aliceSharedSecret').innerHTML += `<br><br>hased Shared secret (Alice side): ${hashedSecret}`;

               Swal.fire({
                   title: "Your PROXY address was created!",
                   text: proxyAddress,
                   icon: "success"
                 });
            

                //////////////////////////
                // COMPUTE STEALTH WALLET (alice) from privkey
                // a + hs
                //////////////////////////
                    // ALICE can comput the private key to the stealth addres
                const hprivkeyBigInt = BigInt(aPrivkey);  // hs should already be in hex or BigInt format
    
                const hsBigInt = BigInt(hashedSecret);  // hs should already be in hex or BigInt format
                // hs = hsBigInt
                aliceStealthPrivkeyMethod1 = hprivkeyBigInt + hsBigInt
                console.warn('üõ∞Ô∏è aliceStealthPrivkeyMethod1: ', aliceStealthPrivkeyMethod1)

                // aliceStealthPrivkeyMethod2 = hprivkeyBigInt.add(hsBigInt);  // (hs * G) + B (Bob's public key)
                // console.warn('üõ∞Ô∏è aliceStealthPrivkeyMethod2: ', aliceStealthPrivkeyMethod2)
    
                eth2bigint = ethers.toBigInt(aliceStealthPrivkeyMethod1)
    
                const stealthPrivateKey = ethers.zeroPadValue(ethers.toBeHex(aliceStealthPrivkeyMethod1), 32);
                console.warn(' üöÅ ALICE stealthPrivateKey: ', stealthPrivateKey)
                const stealthwallet = new ethers.Wallet(stealthPrivateKey);
                const derivedStealthPubKey = stealthwallet.publicKey;
                console.warn(' ü™Çü¶π‚Äç‚ôÇÔ∏è ALICE stealthPrivateKey: ', stealthPrivateKey)
                console.warn(' ü™Ç  ALICE STEALTH ADDRESS: ', stealthwallet.address)
            // ...............
            
                    
            // ‚ñó‚ñÑ‚ñÑ‚ññ  ‚ñó‚ñÑ‚ññ ‚ñó‚ñÑ‚ñÑ‚ññ 
            // ‚ñê‚ñå ‚ñê‚ñå‚ñê‚ñå ‚ñê‚ñå‚ñê‚ñå ‚ñê‚ñå
            // ‚ñê‚ñõ‚ñÄ‚ñö‚ññ‚ñê‚ñå ‚ñê‚ñå‚ñê‚ñõ‚ñÄ‚ñö‚ññ
            // ‚ñê‚ñô‚ñÑ‚ñû‚ñò‚ñù‚ñö‚ñÑ‚ñû‚ñò‚ñê‚ñô‚ñÑ‚ñû‚ñò

            // ...............
            //  CALCUlATE SHARED SECRET (FROM BOB SIDE)
            // s=b.A
            // let bobSharedsecret=  await generateBobsharedsecret(stealthPubKey)// stealthPubKey= alice pubkey
            // 1. prepare things
            // ...............
            const bobwallet = await bobWallet()
                 bobPrivKey = bobwallet.privateKey;
                 bobPrivateKey = ethers.getBytes(bobPrivKey);
                 bPrivkey = `0x${toHexString(bobPrivateKey)}`;
                 BPubkey = secp.ProjectivePoint.fromHex(aliceEphemeralPublicKey);

                //////////////////////////
                 // COMPUTE SHARED SECRET (from bob side )
                 // s=b.A
                 //////////////////////////
                bobSharedsecret = BPubkey.multiply(BigInt(bPrivkey)).toHex();//s=b‚ãÖA
                console.log('üë´sharedSecret( from bob side):', bobSharedsecret);

                 bobhashedSecret = ethers.keccak256('0x' + bobSharedsecret).slice(0, 42);//hs
                console.log('hashedSecret( from bob side):', bobhashedSecret);
            // --------------------------------------
                console.log('üíöüîî bobSharedsecret (hs):', bobSharedsecret);
               
               document.getElementById('bobSharedSecret').innerHTML += `<br><br>Shared secret (Bob side): ${bobhashedSecret}`;
            //    document.getElementById('bobSharedSecret').innerHTML += `<br><br>Shared secret (Bob side): ${ethers.hexlify(bobSharedsecret)}`;
               
            
            } catch (error) {
                console.error(error);
                status.textContent = `Error: ${error.message}`;
            }

        }

  // METAMASK createProxyAddress message_sign /eth_signTypedData_v4
  async function createProxyAddressAlt () {
      
      
      try {
          if (!currentAccount) {
              status.textContent = 'Error: Please connect your wallet first.';
              return;
            }
            console.log('createProxyAddressAlt()',currentAccount)


                // GET BOB PUBLIC KEY
                let bobPK= document.getElementById('bobPubkey').innerHTML
 
                //   ---
                // ALICE SIGNS BOB PUBKEY
                // ========------------
                const ethereummmsdk = mmsdk.getProvider()
                // const provider = MMSDK.getProvider()

                    // Batch multiple RPC requests
            const batchResults = await ethereummmsdk.request({
                method: "metamask_batch",
                params: [
                    { method: "eth_accounts" },
                    { method: "eth_chainId" }
                ]
            })

            console.log('account:', batchResults[0][0])
            console.log('chaiId:', parseInt(batchResults[1], 16))
            let chnid= parseInt(batchResults[1], 16)
                // ========------------

                
                const domain = {
                    name: "Stealth Address Protocol",
                    version: "1",
                    chainId: chnid, // Replace with your chain ID (e.g., 1 for Ethereum mainnet)
                  };
                  
                  const types = {
                    StealthAddressData: [
                      { name: "recipientPublicKey", type: "bytes" },
                      { name: "nonce", type: "uint256" },
                    ],
                  };
                  
                  // Generate the deterministic nonce
                  const protocolId = "stealth-address-v1"; // Protocol identifier
                  const nonce = generateDeterministicNonce(currentAccount, bobPK, protocolId);
                  console.log("Deterministic Nonce:", nonce);
                  
                  // Construct the message
                  const message = {
                    recipientPublicKey: bobPK, // Bob's public key
                    nonce: nonce,              // Deterministic nonce
                  };

                  
                  // PREPARE PARAMETERS/
                  const params = [
                    JSON.stringify({
                      domain,
                      types,
                      primaryType: "StealthAddressData",
                      message,
                    }),
                    currentAccount, // Alice's Ethereum address
                  ];

                console.log('params: ', params)

                // Request the user to sign the message
                // const ethereummmsdk = mmsdk.getProvider()
                
                const signature = await ethereummmsdk.request({
                    method: 'eth_signTypedData_v4',
                    params,
                });
                console.log('Signature:', signature);
                    return
                
            } catch (error) {
                console.error(error);
                status.textContent = `Error: ${error.message}`;
            }

        }


        async function metamaskGenStAddr(bobPublicKey) {
            console.log('metamaskStAddrGen()')


            try {
                if (!currentAccount) {
                    status.textContent = 'Error: Please connect your wallet first.';
                    return;
                }

                // GENERATE PUBLIC KEY (completar)
                if (!/^[0-9a-fA-F]+$/.test(bobPublicKey)) {
                    bobPublicKey = "03c2ceb90237c4eca2a8ce51c1f2d217f860dcb8909cdc9e2c9b5a038e70f6eb9c";
                }


                // ------
                const bobPublicKeyHexed = `0x${bobPublicKey}`;
                console.log('bobPublicKeyHexed: ', bobPublicKeyHexed, bobPublicKey)
                // 1. Alice uses MetaMask to sign a message containing Bob's public key (B):
                const message = ethers.solidityPacked(["bytes"], [bobPublicKeyHexed]);
                mmsg = message;
                console.log('message:', message)
                let hexedMessage = hexer(message);
                hmmsg = hexedMessage

                // 2. Derive the Shared Secret: Alice hashes the signature to derive hs:
                let params = [hexedMessage, currentAccount];
                pp = params;
                // const values = [bobPublicKey, "SharedSecretMessage"];

                // Request the user to sign the message
                const ethereummmsdk = mmsdk.getProvider()
                const signature = await ethereummmsdk.request({
                    method: 'personal_sign',//Prepends a safe prefix
                    params: [hexedMessage, currentAccount],//v1 messageHex. recupera bien la address
                    params: params,//v1 messageHex. recupera bien la address
                });
                ssig = signature
                console.log('Signature:', signature);


                // ...............
                // GET USER(ALICE) PUBKEY
                const publicKey = await derivePubkey(hexedMessage, signature);
                console.log('publicKey():', publicKey)
                // ...............

                // Display the signature
                signatureSpan.textContent = signature;
                signatureDisplay.style.display = 'block';
                status.textContent = 'Message signed successfully!';

                // Step: recover the address from the signed message
                const recoveredAddress = ethers.verifyMessage(message, signature);//ok!!!.recupera bie la address
                console.warn('‚úÖ  ‚õìÔ∏è‚Äçüí• Recovered Address:', recoveredAddress);

                // 2 .Alice hashes the signature to derive hs:
                const sharedSecret = ethers.keccak256(signature);
                console.log('Shared Secret:', sharedSecret);
                signatureSpan.innerHTML += `<br><br>Shared secret: ${sharedSecret}`;


                //////////////////////////
                // 3. Alice computes the stealth public key (stPk) using hs and Bob's public key (B):
                // const stPk = hs * G + B; // Elliptic curve math
                //////////////////////////

                // A.Multiply hs by the curve generator point (G): 

                const G = secp.ProjectivePoint.BASE;  // Generator point G
                const hsBigInt = BigInt(sharedSecret);  // hs should already be in hex or BigInt format
                const hsPoint = G.multiply(hsBigInt);  // hs * G
                hsp = hsPoint

                // B.Adition it to Bob‚Äôs public key:
                const point = secp.ProjectivePoint.fromHex(bobPublicKey);  // Bob's public key point
                const stealthPubPoint = hsPoint.add(point);  // hs * G + B (Bob's public key)
                spp = stealthPubPoint

                // C.Convert the resulting point to an Ethereum address: 
                const stealthPubKey = stealthPubPoint.toHex();  // Convert to hex
                const stealthAddress = ethers.computeAddress('0x' + stealthPubKey);  // Convert to Ethereum address
                stPk = stealthAddress
                console.log('üëªStealth Address:', stealthAddress);
                signatureSpan.innerHTML += `<br><br>Stealth address: ${stealthAddress}`;

                return { stealthAddress, sharedSecret }
            } catch (error) {
                console.error(error);
                status.textContent = `Error: ${error.message}`;
            }

        }


        // -----------------------------------------
        // NEW STEALTH ADDRESS FUNCTIONS
        // -----------------------------------------
        
        function deriveStealthAddress(sharedSecret, spendingPublicKey) {
            console.log('deriveStealthAddress', sharedSecret, spendingPublicKey)
            
            // Hash the shared secret to produce a tweak value
            tweak = ethers.keccak256(sharedSecret);
        
            // Convert spending public key to a point on the curve
            spendingPoint = secp.ProjectivePoint.fromHex(ethers.getBytes(spendingPublicKey));
            //   const spendingPoint = secp.Point.fromHex(ethers.getBytes(spendingPublicKey));
            //   const spendingPoint = secp.Point.fromHex(spendingPublicKey);
        
            // spendingPublicKey should be intarray
            //   const point = secp.ProjectivePoint.fromHex(spendingPublicKey);  // Bob's public key point
            point = secp.ProjectivePoint.fromHex(ethers.getBytes(bobSpendingPublicKey));  // Bob's public key point
        
        
            // Add the tweak to the spending public key
            //   stPk= hs * G +B ??
        
            //   const stealthPoint = spendingPoint.add(secp.Point.fromPrivateKey(tweak));
            const stealthPoint = spendingPoint.add(secp.Point.fromPrivateKey(ethers.getBytes(tweak)));
        
          return `0x${stealthPoint.toHex(true)}`; // Compressed format
}

// const stealthAddress = deriveStealthAddress(sharedSecret, bobSpendingPublicKey);

        async function generateSharedSecret(signer, recipientPublicKey) {
            // Convert recipient's public key to a message format
            const message = ethers.keccak256(recipientPublicKey); // Hash the public key

            // Sign the message using MetaMask
            const signature = await signer.signMessage(ethers.getBytes(message));
            console.log('Signature:', signature);

            // Extract the shared secret from the signature
            const sharedSecret = ethers.keccak256(signature);
            console.log('Shared Secret:', sharedSecret);

            return sharedSecret;
        }


        async function computeStealthAddress(sharedSecret, recipientPublicKey) {
            // Hash the shared secret
            const hashedSecret = ethers.keccak256(sharedSecret).slice(0, 42);

            // Multiply the hash by the generator point (G)
            const G = secp.ProjectivePoint.BASE; // Generator point G
            const hsBigInt = BigInt(hashedSecret); // Convert to BigInt
            const hsPoint = G.multiply(hsBigInt); // hs * G

            // Add the recipient's public key
            const recipientPoint = secp.ProjectivePoint.fromHex(recipientPublicKey);
            const stealthPubPoint = hsPoint.add(recipientPoint); // hs * G + recipient's public key

            // Convert the resulting point to an Ethereum address
            const stealthPubKey = stealthPubPoint.toHex(); // Convert to hex
            const stealthAddress = ethers.computeAddress('0x' + stealthPubKey); // Convert to Ethereum address
            console.log('Stealth Address:', stealthAddress);

            return stealthAddress;
        }

        async function createStealthAddressWithMetamask() {
            console.log('ü¶äü¶äü¶ä createStealthAddressWithMetamask()')
            try {
                // Step 1: Get the user's public key
                const recipientPublicKey = await getPublicKeyFromMetaMask();// OLD METHOD

                // alert(recipientPublicKey)

                // Step 2: Generate the stealth address
                // const stealthAddress = await generateStealthAddressWithMetaMask('03c2ceb90237c4eca2a8ce51c1f2d217f860dcb8909cdc9e2c9b5a038e70f6eb9c');

                console.log('Stealth Address for Donations:', stealthAddress);
                return stealthAddress;
            } catch (error) {
                console.error('Error setting up stealth donations:', error);
            }
        }


        async function getPublicKeyFromMetaMask(bobPublicKey) {
            console.log('getPublicKeyFromMetaMask() OLD METHOD')
            if (!window.ethereum) {
                throw new Error('MetaMask is not installed!');
            }

            // Step 1: Connect to MetaMask
            const provider = new ethers.BrowserProvider(window.ethereum);/// OLD METHOD
            const signer = await provider.getSigner();
            const address = await signer.getAddress();
            console.log('Connected to MetaMask account (OLD METHOD ü¶ñ ü¶ñ):', address);

            // ---
            // Step 2: Define a message to sign
            // const message = 'Sign this message to generate your public key for stealth donations.';
            // msga = message;
            // const messageBytes = ethers.getBytes(ethers.id(message)); // Hash the message
            // msgb = messageBytes


            // ---
            // VARIATION

            if (!/^[0-9a-fA-F]+$/.test(bobPublicKey)) {
                bobPublicKey = "03c2ceb90237c4eca2a8ce51c1f2d217f860dcb8909cdc9e2c9b5a038e70f6eb9c";
            }


            // ------
            const bobPublicKeyHexed = `0x${bobPublicKey}`;
            console.log('bobPublicKeyHexed: ', bobPublicKeyHexed, bobPublicKey)
            // 1. Alice uses MetaMask to sign a message containing Bob's public key (B):
            const message = ethers.solidityPacked(["bytes"], [bobPublicKeyHexed]);
            console.log('message:', message)
            let hexedMessage = hexer(message);
            hmmsg = hexedMessage
            let params = [hexedMessage, currentAccount];

            // // Request the user to sign the message
            // const ethereummmsdk = mmsdk.getProvider()
            // const signature = await ethereummmsdk.request({
            //     method: 'personal_sign',//Prepends a safe prefix
            //     params: [hexedMessage, currentAccount],//v1 messageHex. recupera bien la address
            //     params: params,//v1 messageHex. recupera bien la address
            //     // params: [message, currentAccount],//v1 messageHex. recupera bien la address
            // });
            // ssig=signature
            // console.log('Signature:', signature);



            // [[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]
            // Step 3: Request the user to sign the message
            const signature = await signer.signMessage(hexedMessage);
            console.log('Signature:', signature);
            sig2 = signature;

            // ---
            // Step 4: Recover the public key from the signature

            const recoveredAddress = ethers.verifyMessage(hexedMessage, signature);//ok!!!
            console.log(' Recovered Address:', recoveredAddress);

            // Optional: Verify the recovered address matches the signer's address
            if (recoveredAddress !== address) {
                throw new Error('Recovered address does not match signer address!');
            }
            // ---

            // Step 5: Derive the public key 
            const publicKey = await derivePublicKeyFromSignature(signature, hexedMessage);
            console.log('Recovered Public Key:', publicKey);

            // let verifyAddr2 =  await deriveAddressFromPublicKey(publicKey);
            //     console.warn('Verified address v2 from Public Key:', verifyAddr2);



            return publicKey;
        }

        async function derivePubkey(message, signature) {

            // ATENCIO: Ethereum signatures use a specific hashing process for messages. When signing with personal_sign, the message is 
            // prefixed with \x19Ethereum Signed Message:\n<length> before hashing.


            // Hash the message (keccak256 hash of the message)
            const messageHash = ethers.keccak256(ethers.toUtf8Bytes(message));

            // Convert the signature to bytes format
            const sigBytes = ethers.getBytes(signature);

            // Split the signature into `r`, `s`, and `v` components
            const r = sigBytes.slice(0, 32);
            const s = sigBytes.slice(32, 64);
            const v = sigBytes[64];



            // ---

            // Convert the message hash to Uint8Array (remove '0x' prefix)
            const messageHashBytes = ethers.getBytes(messageHash);

            // Adjust `v` to match secp256k1's expected range (0 or 1)
            const recoveryBit = v - 27;

            // Recover the public key
            const publicKey = secp.Signature.fromCompact(sigBytes.slice(0, 64))
                .addRecoveryBit(recoveryBit)
                .recoverPublicKey(messageHashBytes);
            // ---

            puk = publicKey

            const publicKeyHex = publicKey.toHex();  // Convert to hex
            const originalAddress = ethers.computeAddress('0x' + publicKeyHex);  // Convert to Ethereum address
            console.warn('üë©‚Äçüé§ ALICE Address (from pubKey):', originalAddress);

            // Convert the public key to a compressed format (optional)
            const compressedPublicKey = `0x${publicKeyHex}`;
            cpuk = compressedPublicKey
            console.warn("Public Key (Compressed):", compressedPublicKey);

            return compressedPublicKey;
        }

        async function derivePublicKeyFromSignature(message, signature) {
            try {
                // Step 1: Hash the message using Keccak-256
                const messageHash = ethers.id(message); // Hash the message

                // Step 2: Parse the signature into its components (r, s, v)
                const sig = ethers.Signature.from(signature); // Parse the signature
                const r = sig.r;
                const s = sig.s;
                const recoveryId = sig.v - 27; // Convert v (27/28) to recovery ID (0/1)

                // Step 3: Recover the public key
                const publicKey = ethers.SigningKey.recoverPublicKey(messageHash, {
                    r,
                    s,
                    v: recoveryId + 27, // Convert recoveryId back to v
                });
                console.log('Recovered Public Key:', publicKey);
                return publicKey;

                // Step 4: Derive the Ethereum address from the public key
                // const address = getAddressFromPublicKey(publicKey);
                // console.log('Derived Ethereum Address:', address);

                // return address;
            } catch (error) {
                console.error('Error recovering address from signature:', error);
                throw error;
            }
        }

        // Helper function to derive an Ethereum address from a public key
        function getAddressFromPublicKey(publicKey) {
            // Ensure the public key is valid
            if (!publicKey.startsWith("0x")) {
                publicKey = "0x" + publicKey; // Add '0x' prefix if missing
            }

            if (publicKey.length !== 132) {
                throw new Error("Invalid public key length. Expected 64 bytes (uncompressed public key).");
            }

            // Remove the '0x' prefix and the first byte (0x04 for uncompressed keys)
            const keyBytes = publicKey.slice(4); // Remove '0x04'

            // Hash the public key using Keccak-256
            const hashedKey = ethers.keccak256("0x" + keyBytes);

            // Extract the last 20 bytes (40 hex characters)
            const address = "0x" + hashedKey.slice(-40);

            // Convert to a checksummed address
            return ethers.getAddress(address);
        }


        // Function to derive an Ethereum address from a public key
        // import { ethers } from 'ethers';

        function deriveAddressFromPublicKey(publicKey) {
            // Step 1: Ensure the public key is valid
            if (!publicKey.startsWith("0x")) {
                publicKey = "0x" + publicKey; // Add '0x' prefix if missing
            }

            // Step 2: Validate the public key length
            if (publicKey.length !== 132) {
                throw new Error("Invalid public key length. Expected 64 bytes (uncompressed public key).");
            }

            // Step 3: Remove the '0x' prefix and the first byte (0x04 for uncompressed keys)
            const keyBytes = publicKey.slice(4); // Remove '0x04'

            // Step 4: Hash the public key using Keccak-256
            const hashedKey = ethers.keccak256("0x" + keyBytes);

            // Step 5: Take the last 20 bytes (40 characters in hex)
            const address = "0x" + hashedKey.slice(-40);

            // Step 6: Convert to a checksummed address
            return ethers.getAddress(address);
        }




        function getLast20Bytes(hexString) {
            // Ensure the input is a valid hex string with '0x' prefix
            if (!hexString.startsWith("0x")) {
                throw new Error("Invalid hex string: must start with '0x'");
            }

            // Ensure the hex string is long enough to extract 20 bytes
            if (hexString.length < 42) { // 2 characters for '0x' + 40 characters for 20 bytes
                throw new Error("Hex string is too short to extract 20 bytes");
            }

            // Extract the last 40 characters (20 bytes)
            const last20Bytes = "0x" + hexString.slice(-40); // Take the last 40 characters
            return last20Bytes;
        }


        // Add event listener to the button
        connectButton.addEventListener('click', connectWithMetamask);
        signButton.addEventListener('click', createProxyAddress);
        signButtonMS.addEventListener('click', createProxyAddressAlt);
        // createOwnStealthAddressButton.addEventListener('click', createStealthAddressWithMetamask);




        // ----------------------------
        // EXTRA UTILS (TEST)
        // ----------------------------

        // Helper function to convert a hex string to a Uint8Array
        function hexToBytes(hex) {
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
            }
            return bytes;
        }

        // Helper function to convert a Uint8Array to a hex string
        function bytesToHex(bytes) {
            return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');
        }

        function uncompressPubKey(comppressedPubkey) {

            // Compressed public key (hex string)
            const compressedPublicKeyHex = '03c2ceb90237c4eca2a8ce51c1f2d217f860dcb8909cdc9e2c9b5a038e70f6eb9c';

            // Step 1: Convert the compressed public key hex string into a Uint8Array
            const compressedPublicKeyBytes = hexToBytes(compressedPublicKeyHex);

            // Step 2: Decompress the public key using @noble/secp256k1
            // const point = Point.fromHex(compressedPublicKeyBytes); // This creates a Point object from the compressed key
            const point = secp.ProjectivePoint.fromHex(compressedPublicKeyBytes);  // Bob's public key point

            // Step 3: Get the uncompressed public key as a Uint8Array
            const uncompressedPublicKeyBytes = point.toRawBytes(false); // false means uncompressed format

            // Step 4: Convert the uncompressed public key back to a hex string
            // const uncompressedPublicKeyHex = bytesToHex(uncompressedPublicKeyBytes);
             uncompressedPublicKeyHex = ethers.hexlify(uncompressedPublicKeyBytes);

            console.log('Uncompressed Public Key:', uncompressedPublicKeyHex);
        }

        function compressPubKey(publicKey) {
            if (!(publicKey instanceof Uint8Array)) {
                throw new Error("Public key must be a Uint8Array");
            }

            // Validate length for uncompressed (65 bytes) or compressed (33 bytes)
            if (![65, 33].includes(publicKey.length)) {
                throw new Error("Invalid public key length");
            }

            // Compress the public key
            const compressed = secp.ProjectivePoint.fromHex(publicKey).toHex();
            validateCompressedPublicKey(compressed)
            // ensureHexPrefix(compressed,66)
            return compressed;
        }

        function validateCompressedPublicKey(publicKeyHex) {
            if (publicKeyHex.startsWith("0x")) {
                // Remove the '0x' prefix for validation
                publicKeyHex = publicKeyHex.slice(2);
            }

            // Validate the data length (66 characters for a compressed public key)
            if (publicKeyHex.length !== 66) {
                throw new Error("Invalid compressed public key length. Expected 66 characters.");
            }

            // Validate the prefix byte
            const prefix = publicKeyHex.slice(0, 2);
            if (prefix !== "02" && prefix !== "03") {
                throw new Error("Invalid compressed public key: Prefix must be 0x02 or 0x03");
            }

            console.log("The public key is valid and compressed.");
        }


        // Function to derive an address on demand
        async function deriveAddressWallet(mnemonic, index) {
            const basePath = "m/44'/60'/0'/0/";
            const path = `${basePath}${index}`;
            const derivedNode = ethers.HDNodeWallet.fromPhrase(mnemonic, path);
            return derivedNode
        }



        // async function aliceWallet() {
        //     let aliceMnemonic = localStorage.getItem('aliceMnemonic');
        //     if (!aliceMnemonic) {
        //         console.error('NO aliceMnemonic  in localStorage!');

        //         const randmnemonic = await ethers.HDNodeWallet.createRandom()
        //         aliceMnemonic = randmnemonic.mnemonic.phrase;
        //         localStorage.setItem('aliceMnemonic', aliceMnemonic);

        //     } else {
        //         console.log('aliceMnemonic is in localStorage!');

        //     }
        //     let aliceWall = deriveAddressWallet(aliceMnemonic, 0)
        //     return aliceWall
        // }

   // 1- GET  PRIV KEY(IF not CREATE IT)
   
   async function bobWallet() {
                let bobMnemonic = localStorage.getItem('bobMnemonic');
                if (!bobMnemonic) {
                    console.error('NO bobMnemonic  in localStorage!');
    
                    const randmnemonic = await ethers.HDNodeWallet.createRandom()
                    bobMnemonic = randmnemonic.mnemonic.phrase;
                    console.log(bobMnemonic)
                    localStorage.setItem('bobMnemonic', bobMnemonic);
    
                } else {
                    console.log('bobMnemonic is in localStorage!');
    
                }
    
                let bobWall = deriveAddressWallet(bobMnemonic, 0)
                return bobWall
    
            }
    
    
 async function generateBobsharedsecret(alicePublicKey) {
                // privkey sender, pubkey recipient
                console.warn('üè∞ generateBobsharedsecret()',  alicePublicKey)
                
                 bobwallet = await bobWallet()
                 bobPrivKey = bobwallet.privateKey;
                // const alicePrivateKeyA = alicewallet.privateKey;
                 bobPrivateKey = ethers.getBytes(bobPrivKey);

                 privateKeyHex = `0x${toHexString(bobPrivateKey)}`;
                // a = privateKeyHex
                // b = publicKey
                // c = privateKey
                 pubPoint = secp.ProjectivePoint.fromHex(alicePublicKey);
                 sharedSecret = pubPoint.multiply(BigInt(privateKeyHex)).toHex();//s=a‚ãÖB
                console.log('üë´sharedSecret( from bob side):', sharedSecret);

                 hashedSecret = ethers.keccak256('0x' + sharedSecret).slice(0, 42);//hs
                console.log('hashedSecret( from bob side):', hashedSecret);

                return hashedSecret
 }


 async function simplecreateStealthWallet(privateKey, hashedSharedSecret) {
    //  4- To compute his stealth address privK Bob does: 
    // b + hs
    console.warn('simplecreateStealthWallet()', privateKey, hashedSharedSecret)


    // ...............
    // BOB can comput the private key to the stealth addres
    // b +hs
    // ...............
    const hprivkeyBigInt = BigInt(privateKey);  // hs should already be in hex or BigInt format
    // b = hprivkeyBigInt

    const hsBigInt = BigInt(hashedSharedSecret);  // hs should already be in hex or BigInt format
    hs = hsBigInt

    computedPrivKey = hprivkeyBigInt + hsBigInt

    console.warn('üõ∞Ô∏è computedPrivKey: ', computedPrivKey)


    eth2bigint = ethers.toBigInt(computedPrivKey)

 }

 async function createStealthWallet(privateKey, publicKey) {
    //  4- To compute his stealth address privK Bob does: 
    // b + hs

    console.warn('ü¶∏‚Äç‚ôÇÔ∏ècreateStealthWallet()', privateKey, publicKey)
     publicKeyHexWithoutPrefix = removeHexPrefix(publicKey);
     pubPoint = secp.ProjectivePoint.fromHex(publicKeyHexWithoutPrefix);

    //  here
     sharedSecret = pubPoint.multiply(BigInt(privateKey)).toHex();//s= a *B

    console.log('üë´sharedSecret  (at createStealthWallet ):', sharedSecret);
     hashedSecret = ethers.keccak256('0x' + sharedSecret).slice(0, 42);

    // ...............
    // BOB can comput the private key to the stealth addres
    // b +hs
    // ...............
    const hprivkeyBigInt = BigInt(privateKey);  // hs should already be in hex or BigInt format
    // b = hprivkeyBigInt

    const hsBigInt = BigInt(hashedSecret);  // hs should already be in hex or BigInt format
    hs = hsBigInt

    computedPrivKey = hprivkeyBigInt + hsBigInt

    console.warn('üõ∞Ô∏è computedPrivKey: ', computedPrivKey)


    eth2bigint = ethers.toBigInt(computedPrivKey)

    const stealthPrivateKey = ethers.zeroPadValue(ethers.toBeHex(computedPrivKey), 32);
    console.warn(' üöÅ stealthPrivateKey: ', stealthPrivateKey)
    const stealthwallet = new ethers.Wallet(stealthPrivateKey);
    const derivedStealthPubKey = stealthwallet.publicKey;
    console.warn(' ü™Çü¶π‚Äç‚ôÇÔ∏è stealthPrivateKey: ', stealthPrivateKey)
    console.warn(' ü™Ç stealthAddress: ', stealthwallet.address)


    return stealthwallet

}
        // -------------------------------------
        // BOB PART?
        // -------------------------------------

async function init() {
                console.log('init()')
    
    
                /**********************
                 .) ALICE
                ************************/
                // Alice generates her one-time private key
                // let alicewallet = await aliceWallet()
                // const alicePrivateKeyA = alicewallet.privateKey;
                // let alicePrivateKey = ethers.getBytes(alicePrivateKeyA);
                // let aliceAddresslink = ` <a href="${optionsList[0].EXPLORER}/address/${alicewallet.address}" target="_blank">${alicewallet.address}</a>`
                // document.getElementById('aliceAddress').innerHTML = aliceAddresslink
                // document.getElementById('aliceAmount').value = 0.01;
                // document.getElementById('bobAmount').value = 0.01;
                // alicePublicKey = getPublicKey(alicePrivateKey);
                // alicePublicKeyHex = `0x${toHexString(alicePublicKey)}`;
                // let alicePublicKeyB = ethers.getBytes(alicewallet.publicKey);
    
                /**********************
                 .) BOB
                ************************/
                // Bob's public key (can be retrieved or shared)
                let bobwallet = await bobWallet()
                const bobPrivKey = bobwallet.privateKey;
                let bobPrivateKey = ethers.getBytes(bobPrivKey);
                let bobAddresslink = ` <a href="${optionsList[0].EXPLORER}/address/${bobwallet.address}" target="_blank">${bobwallet.address}</a>`

                document.getElementById('bobAddress').innerHTML = bobAddresslink;
                document.getElementById('bobPubkey').innerHTML = bobwallet.publicKey
                // document.getElementById('bobPubkey').innerHTML = ` ${bobwallet.publicKey}`
    
                bobPublicKey = getPublicKey(bobPrivateKey);
                bobPublicKeyHex = `0x${toHexString(bobPrivateKey)}`;
    
    
                /**********************
                 .) calculate stealth address
                 ************************/
    
                //////////////////////////
                // ALICE GENERATES THE STEALTH ADDRESS TO PAY BOB
                //////////////////////////
                return
                let stealthAddress = await generateStealthAddress(alicePrivateKey, bobPublicKey)
    
                let boblink = ` <a href="${optionsList[0].EXPLORER}/address/${stealthAddress.stealthAddress}" target="_blank">${stealthAddress.stealthAddress}</a>`
                result.innerHTML += `<br>üë©üëªStealth address (generated by Alice to pay Bob): ${boblink}
                <br>üë´sharedSecret: ${stealthAddress.sharedSecret}`
                document.getElementById('bobAddress').innerHTML += `<br>SthAddr: ${boblink}`
    
                // ALICE PROXY ADDRESS
                let AliceSelfStealthAddress = await generateStealthAddress(alicePrivateKey, alicePublicKey)
                let aliceProxylink = ` <a href="${optionsList[0].EXPLORER}/address/${AliceSelfStealthAddress.stealthAddress}" target="_blank">${AliceSelfStealthAddress.stealthAddress}</a>`
                result.innerHTML += `<br>üë©üëªAlice sefl Stealth (proxy)address (generated by alice to receive donations): ${aliceProxylink}`

                //////////////////////////
                // BOB GENERATES THE STEALTH ADDRESS TO PAY ALICE
                //////////////////////////
                let bobstealthAddress = await generateStealthAddress(bobPrivateKey, alicePublicKey)
                let alicelink = ` <a href="${optionsList[0].EXPLORER}/address/${bobstealthAddress.stealthAddress}" target="_blank">${bobstealthAddress.stealthAddress}</a>`
                result.innerHTML += `<br><br>üßîüëªStealth address (generated by Bob to pay Alice): ${alicelink} 
                <br>üë´sharedSecret: ${bobstealthAddress.sharedSecret}`
                document.getElementById('aliceAddress').innerHTML += `<br>SthAddr: ${alicelink}`
    
                    // BOB PROXY ADDRESS
                    let BobSelfStealthAddress = await generateStealthAddress(bobPrivateKey, bobPublicKey)
                let bobProxylink = ` <a href="${optionsList[0].EXPLORER}/address/${BobSelfStealthAddress.stealthAddress}" target="_blank">${BobSelfStealthAddress.stealthAddress}</a>`
                result.innerHTML += `<br>üßîüëªBob sefl Stealth (proxy)address (generated by bob to receive donations): ${bobProxylink}`



                let bobstWallet = await createStealthWallet(bobwallet.privateKey, alicewallet.publicKey)
                stw = bobstWallet
                result.innerHTML += `<br><br><br><br>üëªüßîüí≥ BOB'S STEALTH WALLET ==>  ADDRESS üí≥üßîüëª  (to receive from Alice)  : ${bobstWallet.address}`
    
    
                let alicestWallet = await createStealthWallet(alicewallet.privateKey, bobwallet.publicKey)
                astw = alicestWallet
                result.innerHTML += `<br>üëªüë©üí≥ ALICE'S STEALTH WALLET ==> ADDRESS üí≥üë©üëª  (to receive from Bob)  : ${alicestWallet.address}`
    

                /**********************
                 .) CHECK BALANCES
                 ************************/
                let aliceGasBalance = await checkGasBalance(alicewallet.address)
                console.log('Alice GAS Balance:', aliceGasBalance)
                document.getElementById('aliceGas').innerHTML = `<br>Balance: ` + aliceGasBalance
                let bobGasBalance = await checkGasBalance(bobwallet.address)
                console.log('Bob GAS Balance:', bobGasBalance)
                document.getElementById('bobGas').innerHTML = `<br>Balance : ` + bobGasBalance
    
                /**********************
                 .) claim?
                 ************************/
                // Example: Bob checks and claims the transaction
                const checkResult = await checkStealthTransaction(bobPrivKey, stealthAddress.stealthAddress);
    
                // Assuming checkResult returns a balance value
                if (checkResult === 0) {
                    // Action to take if balance is 0
                    console.log("Balance is 0, no funds available.");
                    console.log("‚õî‚õî‚õîüí∏No funds available or no action was taken.");
                    result.innerHTML += " <br><br>‚õî‚õî‚õîüí∏No funds available or no action was taken.";
    
                } else if (checkResult > 0) {
                    // Action to take if there is a balance
                    console.log(`Balance is ${checkResult}, funds available.`);
                    console.warn("üí∞üí∞üí∞ Funds are ready to be claimed from the stealth address.");
                    result.innerHTML += `<br><br> <ins>${checkResult}üí∞üí∞üí∞ Funds are ready to be claimed from the stealth address.</ins>`
                    document.getElementById('bobTx').innerHTML += `<br><button class="button-primary" type="button" onclick="claimBob('${bobPrivKey}', '${stealthAddress.stealthAddress}', this)">Claim ${checkResult}</button>`;
    
    
                } else {
                    console.log("Unexpected balance value.");
                }
    
    
    
            }
    
            init()
    </script>
</body>

</html>