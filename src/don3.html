<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Donate to Campaign</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
  <style>
     :root {
            --font: white;
            --bk: linear-gradient(var(--c0), var(--c0b));
            --bckmodal: #262626;
            --mainBk: #41307c;

        }

        body {
            /* color: var(--font)!important; */
            background-image: radial-gradient(circle, #5c0067 0%, var(--bckmodal) 100%);
            /* background-image: radial-gradient(circle, var(--mainBk) 0%, var(--bckmodal) 100%); */
        }
        h1,h2,h3,h4,p{
            color: var(--font)!important;

        }
    /* Custom Progress Bar */
    .progress-bar {
      width: 100%;
      background-color: #e0e0e0;
      border-radius: 5px;
      overflow: hidden;
      margin-top: 1rem;
    }

    .progress-bar-fill {
      height: 20px;
      background-color: #4caf50;
      width: 0%;
      transition: width 0.3s ease;
    }

    /* Wallet Modal Styles */
    #walletModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    #walletModalContent {
      background: white;
      padding: 2rem;
      border-radius: 10px;
      text-align: center;
      max-width: 400px;
      width: 100%;
    }

    .wallet-option {
      display: flex;
      align-items: center;
      margin: 1rem 0;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 5px;
      transition: background 0.3s ease;
    }

    .wallet-option:hover {
      background: #f0f0f0;
    }

    .wallet-icon {
      width: 32px;
      height: 32px;
      margin-right: 1rem;
    }

    /* Position the Connect Wallet button in the top-right corner */
    .connect-wallet-container {
      position: absolute;
      top: 1rem;
      right: 1rem;
      z-index: 100;
    }

    .connect-wallet-btn {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1rem;
      transition: background-color 0.3s ease;
    }

    .connect-wallet-btn:hover {
      background-color: #0056b3;
    }

 /* Success Icon Animation */
 .success-icon {
      width: 8rem;
      height: 8rem;
      color: #28a745; /* Green color */
      animation: fadeInScale .33s ease-in-out;
    }

    @keyframes fadeInScale {
      0% {
        opacity: 0;
        transform: scale(0.5);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }

    /* Hide success section initially */
    .success-section {
      display: none;
    /* display: flex; */
    flex-direction: column;
    align-items: center;
    }

    #successMessage{
      word-break: break-all;
    }

    #paymentModalTitle{
      font-size: small;
      text-align: center;
    }
    .copy2clipboard{
      cursor: pointer;
    }
  </style>
</head>
<body>
  <main class="container">
    <!-- Connect Wallet Button (Top-Right) -->
    <div class="connect-wallet-container">
      <button id="connectWalletBtn" class="connect-wallet-btn" onclick="openWalletModal()">Connect Wallet</button>
      <!-- <p id="walletStatus">Not connected</p> -->
    </div>

    <h1>Donate to Campaign</h1>

    <!-- Select Campaign -->
    <!-- <section>
      <h2>Select Campaign</h2>
      <form id="selectCampaignForm">
        <label for="tokenId">Campaign ID:</label>
        <input type="number" id="tokenId" placeholder="Enter Campaign ID" required>
        <button type="submit">Load Campaign</button>
      </form>
    </section> -->

    <!-- Campaign Details -->
    <section id="campaignDetails" style="display: none;">
      <h2>Campaign Details</h2>
      <p><strong>User:</strong> <span id="campaignDonor">Not connected</span></p>
      <p><strong>Recipient:</strong> <span id="campaignRecipient"></span></p>
      <p><strong>Goal:</strong> <span id="campaignGoal"></span> ETH</p>
      <p><strong>Raised:</strong> <span id="campaignRaised"></span> ETH</p>
      <div class="progress-bar">
        <div class="progress-bar-fill" id="progressBarFill"></div>
      </div>
      <div id="campaignEndedBanner" style="display: none; background-color: #ffebee; color: red; padding: 1rem; border-radius: 5px; margin-top: 1rem;">
        <strong>CAMPAIGN HAS ENDED</strong>
      </div>

      <!-- Success Banner -->
<div id="campaignSuccessBanner" style="display: none; background-color: #e8f5e9; color: green; padding: 1rem; border-radius: 5px; margin-top: 1rem;">
  <strong>CAMPAIGN SUCCESSFULLY FUNDED!</strong>
</div>


<p><strong>Time Left:</strong> <span id="campaignTimeLeft">Loading...</span></p>
      <!-- <p><strong>Time Left:</strong> <span id="campaignTimeLeft"></span> seconds</p> -->
    </section>


    <!-- Donor List -->
<section id="donorListSection" style="display: none;">
  <h2>Donors</h2>
  <ul id="donorList"></ul>
</section>


    <!-- Donate Form -->
    <section id="donateSection" style="display: none;">
      <h2>Make a Donation</h2>
      <form id="donateForm">
        <label for="amount">Amount (in ETH):</label>
        <input type="number" id="amount" step="0.01" placeholder="Enter Donation Amount" required>

        <label for="pseudonym">Pseudonym (Optional):</label>
        <input type="text" id="pseudonym" placeholder="Your Pseudonym">

        <button type="submit">Donate</button>
      </form>
    </section>
  </main>

  <!-- Wallet Modal -->
  <div id="walletModal">
    <div id="walletModalContent">
      <h3>Select Wallet</h3>
      <div class="wallet-option" onclick="connectWallet('metamask')">
        <img src="https://upload.wikimedia.org/wikipedia/commons/3/36/MetaMask_Fox.svg" alt="MetaMask" class="wallet-icon">
        <span>MetaMask</span>
      </div>
      <!-- <div class="wallet-option" onclick="connectWallet('phantom')">
        <img src="https://avatars.githubusercontent.com/u/81297455?s=200&v=4" alt="Phantom" class="wallet-icon">
        <span>Phantom</span>
      </div>
      <div class="wallet-option" onclick="connectWallet('rabby')">
        <img src="https://raw.githubusercontent.com/RabbyHub/rabby-assets/main/logo/rabby-logo.svg" alt="Rabby" class="wallet-icon">
        <span>Rabby</span>
      </div>
      <div class="wallet-option" onclick="connectWallet('rainbow')">
        <img src="https://avatars.githubusercontent.com/u/45037840?s=200&v=4" alt="Rainbow" class="wallet-icon">
        <span>Rainbow</span>
      </div> -->
      <div class="wallet-option" onclick="connectWallet('iusnaturalis')">
        <img src="img/logoius.svg" alt="iusNaturalis" class="wallet-icon">
        <!-- <img src="img/logoIN.png" alt="iusNaturalis" class="wallet-icon"> -->
        <span>iusNaturalis</span>
      </div>
      <button onclick="closeWalletModal()">Cancel</button>
    </div>
  </div>


    <!--PAYMENT/SIGN Modal -->
    <dialog id="paymentModal" class="modal">
      <article>
        <header>
          <h2 id="paymentModalTitle">Scan QR Code to Pay/Sign</h2>
        </header>
        <div id="qrCodeContainer" style="text-align: center;"></div>
        <section id="iusConnect"></section>

        <p id="countdown" style="font-size: 1.2rem; margin-top: 1rem;">Expires in: 15:00</p>


        <!-- Success Section -->
        <div id="successSection" class="success-section mt-4">
          <!-- Inline SVG for Success Icon -->
          <svg
            class="success-icon"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 512 512"
          >
            <path
              fill="currentColor"
              d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5 0-200-89.5-200-200S145.5 56 256 56s200 89.5 200 200-89.5 200-200 200zm101.8-262.2L246.6 302.6c-5.7 6.8-15.5 8.3-22.3 2.6l-67.6-56.3c-6.8-5.7-8.3-15.5-2.6-22.3 5.7-6.8 15.5-8.3 22.3-2.6l55.3 46.1 94.7-113.8c5.7-6.8 15.5-8.3 22.3-2.6 6.8 5.7 8.3 15.5 2.6 22.3z"
            />
          </svg>
          <p class="mt-3 fs-5 text-success" id="successMessage">Payment Successful!</p>
        </div>

        <footer>
          <button id="closeModalBtn" class="outline">Close</button>
        </footer>
      </article>
    </dialog>
    <!--fin PAYMENT/SIGN Modal -->



  <!-- JavaScript -->
	<script src="js/ethers-6.13.2.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
	<script src="js/sweetalert2.all.min.js"></script>
  <script src="js/tsparticles.confetti.bundle.min.js"></script>
	<script src="js/Tone.min.js"></script> 



  <script type="module">

    // import { Client } from '@xmtp/xmtp-js'
    import { Client } from '@xmtp/browser-sdk'

    window.Client = Client;
</script>
    
  <script>
	/*********************************************************************************************
		.) SOUNDS
		**********************************************************************************************/

	

		// Initialize Tone.js
		Tone.start();
		console.log("tone started");
        
       function playtxReceived() {
         const synth = new Tone.Synth({
           oscillator: { type: "triangle" },
           envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 }
         }).toDestination();
       
         const now = Tone.now();
         const notes = ["C4", "D4", "E4", "G4", "A4", "B4", "C5", "E5"]; // Ascending scale
         notes.forEach((note, index) => {
           synth.triggerAttackRelease(note, "16n", now + index * 0.05); // Faster timing
         });
       
         synth.triggerAttackRelease("G5", "8n", now + notes.length * 0.05); // After the arpeggio
       }
       const defaults = {
            spread: 360,
            ticks: 100,
            gravity: 0,
            decay: 0.94,
            startVelocity: 30,
        };

        function shoot() {
            confetti({
                ...defaults,
                particleCount: 30,
                scalar: 1.2,
                shapes: ["circle", "square"],
                colors: ["#a864fd", "#29cdff", "#78ff44", "#ff718d", "#fdff6a"],
            });

            confetti({
                ...defaults,
                particleCount: 20,
                scalar: 2,
                shapes: ["emoji"],
                shapeOptions: {
                    emoji: {
                        value: ["🦄", "🌈"],
                    },
                },
            });
        }

function donationReceived(){
     // LAUNCH FANCY CONFETTI
     setTimeout(shoot, 0);
            setTimeout(shoot, 100);
            setTimeout(shoot, 200);

            playtxReceived()
            Swal.fire({
              position: "top-end",
              icon: "success",
              title: "Donation received",
              showConfirmButton: false,
              timer: 1500
            });
}



const paymentModal = document.getElementById("paymentModal");
const closeModalBtn = document.getElementById("closeModalBtn");
const qrCodeContainer = document.getElementById("qrCodeContainer");
const countdownElement = document.getElementById("countdown");

        optionsList = [
            {
              "CONTRACT_ADDRESS": "0x23f15345392Fd2caCCaC1CE2361eA28669E8326C",
                "TOKEN_CHAIN_NAME": 'Arbitrum sepolia',
                "CHAIN_ID": '421614',
                // "TOKEN_CHAINID": '421614',
                "EXPLORER": 'https://sepolia.arbiscan.io/',
                "API": 'https://arbitrum-sepolia.infura.io/v3/9219faae2bac4d24b95c2d967b22005a',
                "ALCHEMY_KEY": 'X048z0PxuDPd5vbTiKLbWJgogG9Tvd2I'
            }
        ]
    // Replace with your contract ABI and address
    const CONTRACT_ABI = [ { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" }, { "inputs": [ { "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "internalType": "address", "name": "owner", "type": "address" } ], "name": "ERC721IncorrectOwner", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "operator", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "ERC721InsufficientApproval", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "approver", "type": "address" } ], "name": "ERC721InvalidApprover", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "operator", "type": "address" } ], "name": "ERC721InvalidOperator", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" } ], "name": "ERC721InvalidOwner", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "receiver", "type": "address" } ], "name": "ERC721InvalidReceiver", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "sender", "type": "address" } ], "name": "ERC721InvalidSender", "type": "error" }, { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "ERC721NonexistentToken", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" } ], "name": "OwnableInvalidOwner", "type": "error" }, { "inputs": [ { "internalType": "address", "name": "account", "type": "address" } ], "name": "OwnableUnauthorizedAccount", "type": "error" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "approved", "type": "address" }, { "indexed": true, "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "operator", "type": "address" }, { "indexed": false, "internalType": "bool", "name": "approved", "type": "bool" } ], "name": "ApprovalForAll", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "indexed": true, "internalType": "address", "name": "creator", "type": "address" }, { "indexed": true, "internalType": "address", "name": "recipient", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "goal", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "deadline", "type": "uint256" } ], "name": "CampaignCreated", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "newGoal", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "newDeadline", "type": "uint256" } ], "name": "CampaignRenewed", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "indexed": true, "internalType": "address", "name": "contributor", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "ContributionMade", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "indexed": true, "internalType": "address", "name": "recipient", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "FundsWithdrawn", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "previousOwner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "newOwner", "type": "address" } ], "name": "OwnershipTransferred", "type": "event" }, { "anonymous": false, "inputs": [ { "indexed": true, "internalType": "address", "name": "from", "type": "address" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }, { "indexed": true, "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "Transfer", "type": "event" }, { "inputs": [ { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "approve", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" } ], "name": "balanceOf", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "name": "campaigns", "outputs": [ { "internalType": "address", "name": "recipient", "type": "address" }, { "internalType": "bytes", "name": "recipientPublicKey", "type": "bytes" }, { "internalType": "uint256", "name": "goal", "type": "uint256" }, { "internalType": "uint256", "name": "deadline", "type": "uint256" }, { "internalType": "uint256", "name": "raisedAmount", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" }, { "internalType": "string", "name": "_pseudonym", "type": "string" } ], "name": "contribute", "outputs": [], "stateMutability": "payable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "_recipient", "type": "address" }, { "internalType": "bytes", "name": "_recipientPublicKey", "type": "bytes" }, { "internalType": "uint256", "name": "_goal", "type": "uint256" }, { "internalType": "uint256", "name": "_durationInDays", "type": "uint256" } ], "name": "createCampaign", "outputs": [], "stateMutability": "payable", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "getApproved", "outputs": [ { "internalType": "address", "name": "", "type": "address" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" }, { "internalType": "uint256", "name": "index", "type": "uint256" } ], "name": "getContributorByIndex", "outputs": [ { "internalType": "address", "name": "", "type": "address" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" }, { "internalType": "address", "name": "contributor", "type": "address" } ], "name": "getContributorPseudonym", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" } ], "name": "getContributorsCount", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" } ], "name": "hasGoalReached", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "operator", "type": "address" } ], "name": "isApprovedForAll", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "name", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "nextTokenId", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "owner", "outputs": [ { "internalType": "address", "name": "", "type": "address" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "ownerOf", "outputs": [ { "internalType": "address", "name": "", "type": "address" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" }, { "internalType": "uint256", "name": "_newDurationInDays", "type": "uint256" }, { "internalType": "uint256", "name": "_newGoal", "type": "uint256" } ], "name": "renewCampaign", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "renounceOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "safeTransferFrom", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "internalType": "bytes", "name": "data", "type": "bytes" } ], "name": "safeTransferFrom", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "operator", "type": "address" }, { "internalType": "bool", "name": "approved", "type": "bool" } ], "name": "setApprovalForAll", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "bytes4", "name": "interfaceId", "type": "bytes4" } ], "name": "supportsInterface", "outputs": [ { "internalType": "bool", "name": "", "type": "bool" } ], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "symbol", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" } ], "name": "timeLeft", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "tokenURI", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "transferFrom", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "address", "name": "newOwner", "type": "address" } ], "name": "transferOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" } ], "name": "withdrawAllFunds", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [ { "internalType": "uint256", "name": "_tokenId", "type": "uint256" }, { "internalType": "uint256", "name": "_amount", "type": "uint256" } ], "name": "withdrawFunds", "outputs": [], "stateMutability": "nonpayable", "type": "function" } ];
    const CONTRACT_ADDRESS = "0x23f15345392Fd2caCCaC1CE2361eA28669E8326C";

    let provider, signer, contract;

    // Open Wallet Modal
    function openWalletModal() {
      document.getElementById("walletModal").style.display = "flex";
    }

    // Close Wallet Modal
    function closeWalletModal() {
      document.getElementById("walletModal").style.display = "none";
    }

    function updateDonateButtonState() {
  const donateButton = document.querySelector("#donateForm button");
  if (!signer) {
    donateButton.disabled = true;
    donateButton.innerText = "Connect Wallet to Donate";
  } else {
    donateButton.disabled = false;
    donateButton.innerText = "Donate";
  }
}

// Call this function whenever the wallet connection status changes
// https://localhost:4343/don2.html?tokenId=1
window.onload = async () => {
  const queryParams = getQueryParams();
  if (queryParams.tokenId) {
    document.getElementById("tokenId").value = queryParams.tokenId; // Pre-fill the input field
    loadCampaign(queryParams.tokenId); // Load the campaign details
  }
  updateDonateButtonState();
};



        /*********************************************************************************************
        .)  COPYFadd 
        **********************************************************************************************/
        function copy2clipboard(text) {
            let thisEl= event.target;
 
            try {
              // Check if Clipboard API is supported
              if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                  console.log('Copied to clipboard:', text);
                  showSuccessIcon(thisEl); // Use event.target to get the clicked element

                }).catch(err => {
                  console.error('Failed to copy using Clipboard API:', err);
                  fallbackCopy(text); // Fallback to execCommand if API fails
                  showSuccessIcon(thisEl); // Use event.target to get the clicked element

                });
              } else {
                  fallbackCopy(text); // Fallback for older browsers
                  showSuccessIcon(thisEl); // Use event.target to get the clicked element

              }
            } catch (err) {
              console.error('Copy failed:', err);
            }
          }
          
          function fallbackCopy(text) {
            // Create a temporary, invisible textarea
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed'; // Prevent scrolling issues
            textarea.style.opacity = '0'; // Invisible
            textarea.style.zIndex = '-1'; // Avoid modal interference
            document.body.appendChild(textarea);
            textarea.select();
            try {
              document.execCommand('copy');
              console.log('Copied to clipboard (fallback):', text);
            } catch (err) {
              console.error('Fallback copy failed:', err);
            }
            document.body.removeChild(textarea);
          }
            
          function showSuccessIcon(element) {
                        const svgElement = element.closest("svg");
            if (!svgElement) return;

            
            svgElement.innerHTML = `
                <path fill="green" d="M504 75c-9.4-9.4-24.6-9.4-33.9 0L184.4 360.7l-112-112c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l128 128c9.4 9.4 24.6 9.4 33.9 0l304-304c9.3-9.4 9.3-24.6-.1-33.9z"></path>
            `;
            setTimeout(() => {
                svgElement.innerHTML = `<path fill="currentColor" d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path>`
            }, 1500);
        }



           /*********************************************************************************************
        .)  CONNECT WALLET 
        **********************************************************************************************/   
// Update the button state after connecting the wallet
async function connectWallet(walletType) {
  try {
    let ethereumProvider;

    switch (walletType) {
      case "metamask":
        if (typeof window.ethereum !== "undefined") {
          ethereumProvider = window.ethereum;
        } else {
          alert("MetaMask is not loaded or not installed .");
          return;
        }
        break;

      case "phantom":
        if (typeof window.solana !== "undefined") {
          ethereumProvider = window.solana; // Phantom uses Solana's API
        } else {
          alert("Phantom is not installed.");
          return;
        }
        break;

      case "rabby":
      case "rainbow":
        if (typeof window.ethereum !== "undefined") {
          ethereumProvider = window.ethereum;
        } else {
          alert(`${walletType.charAt(0).toUpperCase() + walletType.slice(1)} is not installed.`);
          return;
        }
        break;

      case "iusnaturalis":
        // alert("Connecting to iusNaturalis...");
        await iusConnectModal()
        ethereumProvider = window.iusNaturalis;
        window.iusNaturalis = new IusNaturalisProvider(recoveredAddress);
        provider = new ethers.BrowserProvider(window.iusNaturalis);
        // window.iusNaturalis = new IusNaturalisProvider(recoveredAddress);

        // await connectToIusNaturalis();
        
        // return

        const rpcUrl = optionsList[0].API; // Replace with your RPC URL
            const jsonRpcProvider = new ethers.JsonRpcProvider(rpcUrl);

        // const walletWithProvider = alicewallet.connect(jsonRpcProvider);
        // Create the custom Ethereum provider
        const customProvider = new CustomEthereumProvider(walletWithProvider, jsonRpcProvider);

        // Assign the custom provider to window.ethereum (optional)
        if (!window.ethereum) {
            window.ethereum = customProvider;
            ethereumProvider = window.ethereum;

        } else {
            console.warn('window.ethereum already exists. Overwriting it may cause issues.');
            window.ethereum = customProvider;
            ethereumProvider = window.ethereum;

        }

        
        // return;

      default:
        alert("Unsupported wallet.");
        return;
    }

    provider = new ethers.BrowserProvider(ethereumProvider);
    await provider.send("eth_requestAccounts", []);
    signer = await provider.getSigner();
    contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

    // document.getElementById("walletStatus").innerText = `Connected: ${await signer.getAddress()}`;
    document.getElementById("campaignDonor").innerText = `Connected: ${await signer.getAddress()}`;
    closeWalletModal();
    updateDonateButtonState(); // Update the donate button state

    stayInSync(ethereumProvider)
    // showSuccessAnimation()

  } catch (error) {
    console.error("Error connecting wallet:", error);
    alert("Failed to connect wallet.");
  }
}


function disconnectWallet() {
    ethereumProvider.removeAllListeners('accountsChanged');
    ethereumProvider.removeAllListeners('chainChanged');
    console.log('Wallet disconnected.');
}

async function connectToIusNaturalis(){
  console.log(' connecting connecting...')
  closeWalletModal();

      // Select DOM elements
    // const openModalBtn = document.getElementById("openModalBtn");
// const paymentModal = document.getElementById("paymentModal");
// const closeModalBtn = document.getElementById("closeModalBtn");
// const qrCodeContainer = document.getElementById("qrCodeContainer");
// const countdownElement = document.getElementById("countdown");

let countdownInterval;
let remainingTime = 15 * 60; // 15 minutes in seconds
  // openModal()
  iusConnectModal()

} 
    // Function to parse query parameters from the URL
    function getQueryParams() {
      const params = {};
      const queryString = window.location.search.substring(1);
      queryString.split("&").forEach(pair => {
        const [key, value] = pair.split("=");
        params[decodeURIComponent(key)] = decodeURIComponent(value);
      });
      return params;
    }
// Function to load campaign details
// Function to load campaign details
async function loadCampaign(tokenId) {
  try {
    const campaign = await contract.campaigns(tokenId);

    // Check if the campaign has ended by calling `timeLeft`
    let timeLeftInSeconds;
    try {
      timeLeftInSeconds = Number(await contract.timeLeft(tokenId)); // Explicitly convert BigInt to Number
    } catch (error) {
      if (error.message.includes("Crowdfunding period has ended")) {
        // Campaign has ended, set timeLeft to 0
        timeLeftInSeconds = 0;
      } else {
        throw error; // Re-throw unexpected errors
      }
    }

    // Format goal and raised amount for display
    const goalFormatted = ethers.formatEther(campaign.goal); // Convert goal to ETH
    const raisedFormatted = ethers.formatEther(campaign.raisedAmount); // Convert raised amount to ETH

    // Update campaign details
    document.getElementById("campaignRecipient").innerText = campaign.recipient;
    document.getElementById("campaignGoal").innerText = goalFormatted;
    document.getElementById("campaignRaised").innerText = raisedFormatted;

    // Show a banner if the campaign has ended
    const campaignEndedBanner = document.getElementById("campaignEndedBanner");
    if (timeLeftInSeconds === 0) {
      campaignEndedBanner.style.display = "block"; // Show the banner
    } else {
      campaignEndedBanner.style.display = "none"; // Hide the banner
    }

    // Calculate progress percentage safely
    const goalBigInt = BigInt(campaign.goal.toString()); // Ensure goal is BigInt
    const raisedBigInt = BigInt(campaign.raisedAmount.toString()); // Ensure raised amount is BigInt
    const progressPercent = Number((raisedBigInt * 100n) / goalBigInt); // Explicit conversion to Number

    // Update progress bar
    const progressBarFill = document.getElementById("progressBarFill");
    progressBarFill.style.width = `${Math.min(progressPercent, 100)}%`;

    // Show a success banner if the goal is fully raised
    const campaignSuccessBanner = document.getElementById("campaignSuccessBanner");
    if (raisedBigInt >= goalBigInt) {
      campaignSuccessBanner.style.display = "block"; // Show the success banner
      progressBarFill.style.backgroundColor = "#4caf50"; // Green progress bar for success
    } else {
      campaignSuccessBanner.style.display = "none"; // Hide the success banner
      progressBarFill.style.backgroundColor = "#4caf50"; // Default progress bar color
    }

    // Show campaign details and donation section
    document.getElementById("campaignDetails").style.display = "block";
    document.getElementById("donateSection").style.display =
      timeLeftInSeconds > 0 && raisedBigInt < goalBigInt ? "block" : "none"; // Hide donation section if the campaign has ended or is fully funded

    // Start the countdown timer
    startCountdownTimer(timeLeftInSeconds);

    // Load and display the list of donors
    const donorListElement = document.getElementById("donorList");
    donorListElement.innerHTML = ""; // Clear previous donor list

    const contributorCount = await contract.getContributorsCount(tokenId);
    for (let i = 0; i < contributorCount; i++) {
      const contributorAddress = await contract.getContributorByIndex(tokenId, i);
      const pseudonym = await contract.getContributorPseudonym(tokenId, contributorAddress);

      const listItem = document.createElement("li");
      listItem.textContent = `${pseudonym || "Anonymous"} (${contributorAddress})`;
      donorListElement.appendChild(listItem);
    }

    // Show the donor list section
    document.getElementById("donorListSection").style.display = "block";
  } catch (error) {
    console.error(`Error loading campaign ${tokenId}:`, error);
    alert("Failed to load campaign. Please check the Campaign ID.");
  }
}

// Function to start the countdown timer
function startCountdownTimer(timeLeftInSeconds) {
  const timeLeftElement = document.getElementById("campaignTimeLeft");

  // Clear any existing interval to prevent multiple timers
  clearInterval(window.countdownInterval);

  // Update the timer every second
  window.countdownInterval = setInterval(() => {
    if (timeLeftInSeconds <= 0) {
      clearInterval(window.countdownInterval);
      timeLeftElement.innerText = "Campaign has ended";
      timeLeftElement.style.color = "red";
      return;
    }

    // Convert seconds into days, hours, minutes, and seconds
    const days = Math.floor(timeLeftInSeconds / (24 * 60 * 60));
    const hours = Math.floor((timeLeftInSeconds % (24 * 60 * 60)) / (60 * 60));
    const minutes = Math.floor((timeLeftInSeconds % (60 * 60)) / 60);
    const seconds = timeLeftInSeconds % 60;

    // Format the time string
    const timeString = `${days > 0 ? `${days}d ` : ""}${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
    timeLeftElement.innerText = timeString;

    // Decrement the time left
    timeLeftInSeconds--;
  }, 1000);
}
 
    // Handle donation form submission
document.getElementById("donateForm").addEventListener("submit", async (e) => {
      e.preventDefault();

  // Check if the wallet is connected
  if (!signer) {
    alert("Please connect your wallet before donating.");
    
    openWalletModal(); // Optionally open the wallet modal to prompt connection
    return;
  }

      const amount = ethers.parseEther(document.getElementById("amount").value);
      const pseudonym = document.getElementById("pseudonym").value || "Anonymous";

// Create the contract instance with the signer
// console.warn()
console.warn('INFO DEL CONTRACT:', CONTRACT_ADDRESS, CONTRACT_ABI, signer);
contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
cx =contract

// UNSINGNED TX
    const tokenId = getQueryParams().tokenId; // Retrieve tokenId from query params
  
    // Encode the function call using the contract ABI
  const iface = new ethers.Interface(CONTRACT_ABI);
  const data = iface.encodeFunctionData("contribute", [tokenId, pseudonym]);
console.warn('DATA:', data)

  // Create the unsigned transaction object
  unsignedTx = {
    to: CONTRACT_ADDRESS,
    value: amount.toString(),
    data: data,
    gasLimit: 100000, // Adjust gas limit as needed
    chainId: optionsList[0].CHAIN_ID, // Replace with the appropriate chain ID (e.g., 1 for Ethereum Mainnet)
  };

  console.log(unsignedTx);

  let stringedMessage = JSON.stringify(unsignedTx)
  console.log("stringedMessage: ",stringedMessage); // Check the output
// SEND MESSAGE
  // Define the code for the message type
            const chatCode = "paymentSign0x22"; // Example: Replace with the appropriate code
            
            // // Format the message by prepending the code
            const formattedMessage = `${chatCode} ${stringedMessage}`;
            
            // // Create a new conversation
            let conversation = await iusnaturalisxmtp.conversations.newConversation(peerVerifiedAddress);
            conv = conversation
            // // Send the formatted message
            await conversation.send(formattedMessage);

            return


 
  return

//     console.log("Gas Estimation Successful:", estimatedGas);
//   } catch (error) {
//     console.error("Simulation Failed:", error);
//   }
// return
// make the tx
      try {
  // Call the `contribute` function
  // const tx = await contract.contribute(tokenId, pseudonym, { value: amount });
  const tx = await contract.contribute(getQueryParams().tokenId, pseudonym, { value: amount });

  console.log("Transaction Sent:", tx.hash);

  // Wait for the transaction to be mined
  const receipt = await tx.wait();
  console.log("Transaction Confirmed:", receipt);
} catch (error) {
  console.error("Error Sending Transaction:", error);
}

      return 
      try {
        const tx = await contract.contribute(getQueryParams().tokenId, pseudonym, { value: amount });
        await tx.wait();
        alert("Donation successful!");

        // Reload campaign details after donation
        loadCampaign(getQueryParams().tokenId);
      } catch (error) {
        console.error("Error donating:", error);
        alert("Failed to donate. Please try again.");
      }




    });

    // Automatically load campaign if tokenId is present in the URL
    window.onload = async () => {
      provider = new ethers.JsonRpcProvider(optionsList[0].API);
      // const provider = new ethers.JsonRpcProvider(optionsList[0].API);
      contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);

      const queryParams = getQueryParams();
      if (queryParams.tokenId) {
        // document.getElementById("tokenId").value = queryParams.tokenId; // Pre-fill the input field
        loadCampaign(queryParams.tokenId); // Load the campaign details
      }


    // Event listeners
    // openModalBtn.addEventListener("click", openModal);
    closeModalBtn.addEventListener("click", closeModal);

    };




    // Function to show the success animation
function showSuccessAnimation() {
  // Hide QR code and countdown
  qrCodeContainer.style.display = "none";
  countdownElement.style.display = "none";

  // Show success section
  // successMessage.innerText = 'Connected!'
  successSection.style.display = "flex";
  iusConnect.innerHTML=''
}

// Event listeners
// openModalBtn.addEventListener("click", openModal);
// closeModalBtn.addEventListener("click", closeModal);

// Close modal when clicking outside of it
paymentModal.addEventListener("click", (event) => {
  if (event.target === paymentModal) {
    closeModal();
  }
});

// Reset modal state when closed
paymentModal.addEventListener("close", () => {
  console.warn('clsoging modal')
  qrCodeContainer.style.display = "block";
  countdownElement.style.display = "block";
  successSection.style.display = "none";
  iusConnect.innerHTML=''
});

// ----------------------------------
// HACK TO COMMUNICATE THROUGH XMTP
// ----------------------------------
    async function createXMTPClient(wallet) {
      const iusnaturalisxmtp = await Client.create(wallet)
      console.warn(' 🟢🟢🟢XMTP STARTED🟢🟢🟢🔴🟠🟡🔵⚫ COMMUNICATING WITH THIS ADDRESS: ', wallet.address)
      return iusnaturalisxmtp;
    }

async function contractWallet() {
    let contractMnemonic = localStorage.getItem('contractMnemonic');
    if (!contractMnemonic) {
        console.error('NO contractMnemonic  in localStorage!');

        const randmnemonic = await ethers.HDNodeWallet.createRandom()
        contractMnemonic = randmnemonic.mnemonic.phrase;
        localStorage.setItem('contractMnemonic', contractMnemonic);

    } else {
        console.log('contractMnemonic is in localStorage!');

    }
    let contractWall = deriveAddressWallet(contractMnemonic, 0)
    return contractWall
}


        // Function to derive an address on demand
        async function deriveAddressWallet(mnemonic, index) {
            const basePath = "m/44'/60'/0'/0/";
            const path = `${basePath}${index}`;
            const derivedNode = ethers.HDNodeWallet.fromPhrase(mnemonic, path);
            return derivedNode
        }


        // ----------------------------------


    // Function to open the modal and generate QR code
async function iusConnectModal() {
  console.warn('iusConnectModal()')
  // closeWalletModal();

// let countdownInterval;
// let remainingTime = 15 * 60; // 15 minutes in seconds
  
const successSection = document.getElementById("successSection");

  // modify title
  document.getElementById('paymentModalTitle').innerText='To login to the app, please sign this message with your wallet'
  // document.getElementById('paymentModalTitle').innerText='Connect'


  console.log("💢💫🙃 Initializing and connecting to Ius Naturalis wallet...");

// Create  address for this site to communicate with the user
let smartcontractwallet = await contractWallet()
const iusnaturalisxmtp = await createXMTPClient(smartcontractwallet);
window.iusnaturalisxmtp = iusnaturalisxmtp; // make GLOBAL


console.log('isNOTConnected!')
         // 0. listen to ALL addresses : streamAllMessages()
         // 1.make the user sign
         // 2. close ALL addresses listener and open a single listener with conversation.streamMessages()
        //  document.getElementById('connection').style.display = 'block'
        //  document.getElementById('disconnection').style.display = 'none'

        //  document.getElementById('info').innerHTML = `<br>Not connected`;


         // ...................................................
         // NEW MESSAGE TO SIGN USING ETH_REQUESTACCOUNTS v2 
         let uniqueTopic = `request-accounts-${Date.now()}`;
         
         let requestPayload = {
           action: 'eth_requestAccounts',
           nonce: crypto.randomUUID(), // Unique identifier for this session
           xmtpTopic: uniqueTopic, // Custom topic for XMTP messages
           requester: smartcontractwallet.address // Custom topic for XMTP messages
           
          };
          r = requestPayload
          
          let qrCodeData = requestPayload
          q = qrCodeData
          
          document.getElementById('paymentModalTitle').innerText=`To login to the app, please sign this message with your wallet. Unique ID: ${requestPayload.nonce}`

         const jsonString = JSON.stringify(requestPayload, (key, value) =>
             typeof value === 'bigint' ? value.toString() : value
         );
         const escapedJsonString = JSON.stringify(jsonString)
             .replace(/"/g, '&quot;') // Replace double quotes with HTML-escaped equivalent
             .replace(/'/g, '&#39;'); // Replace single quotes with HTML-escaped equivalent

         let unescapedJsonString = JSON.stringify(jsonString)

         js = escapedJsonString

         // ...................................................
         // MESSAGE TO SIGN
         // let messageToSign = "I am logging with IusNaturalis";
         let m = `${escapedJsonString}`;

         document.getElementById('iusConnect').innerHTML = ` <div class=" responsive-svg" id="canvas"></div> 
                <svg class='copy2clipboard' id='' onclick="event.stopPropagation();copy2clipboard('${m}')" xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"> <path  fill='currentColor' d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"/> </svg>
                 <div id="result"> </div> `

        //  displayQR(m)

         

  // Simulate generating a transaction request or payment link
  // const txRequest = "ethereum:0xYourContractAddress?value=10000000000000000"; // Example Ethereum URI

  // Generate QR Code
  QRCode.toCanvas(m, { width: 256 }, (error, canvas) => {
    // QRCode.toCanvas(txRequest, { width: 256 }, (error, canvas) => {
    if (error) {
      console.error("Error generating QR code:", error);
      return;
    }
    qrCodeContainer.innerHTML = ""; // Clear previous QR code
    qrCodeContainer.appendChild(canvas); // Append new QR code
  });

  // Reset countdown
  remainingTime = 15 * 60;
  updateCountdown();

  // Show modal
  paymentModal.showModal();
  closeWalletModal();

  // Start countdown
  startCountdown();


// CONTINUE BY LISTENING TO COMM
await listenToAllMessages(iusnaturalisxmtp, qrCodeData)


}



 // ---------------------------------------------
 // Start Listening to All Messages
 // ---------------------------------------------

 // Global State to Track Conversations
 const activeChats = new Map(); // Tracks open chat streams
 let messageStore = {}; // Stores all messages grouped by address
 let abortController;


 async function listenToAllMessages(xmtpClient, messageInput) {

     console.log('listenToAllMessages()')

     // Create an AbortController to manage the stream
     abortController = new AbortController();
     const {
         signal
     } = abortController;
     // check address sender is not this page
     let smartcontractwallet = await contractWallet()
     let smartcontractAddr = smartcontractwallet.address;

     try {
         for await (const message of await xmtpClient.conversations.streamAllMessages({
             signal
         })) {


             if (message.senderAddress === smartcontractAddr) {
                 console.log(`📣 conversation from yourself`);
                //  console.log(`📣 conversation from yourself`, smartcontractAddr, message.content);

                 continue;
             }


             console.log(`🎃 New message from [${message.senderAddress}]: ${message.content}`);

             peerAddress= message.senderAddress;
             // Add message to the global message store
             if (!messageStore[message.senderAddress]) {
                 messageStore[message.senderAddress] = [];
             }

             messageStore[message.senderAddress].push({
                 content: message.content,
                 timestamp: message.sent,
             });



             // Notify the UI or state manager
            console.warn('MESSAGE:', message.senderAddress, message.content, messageInput);
            let recoveredAddress = ethers.verifyMessage(JSON.stringify(messageInput), message.content);
            console.warn(`Logged in as: ${recoveredAddress}`);

            peerVerifiedAddress= recoveredAddress;
             
            // const signer = await provider.getSigner(recoveredAddress);
            
            // document.getElementById("walletStatus").innerText = `Connected: ${recoveredAddress}`;
            document.getElementById("campaignDonor").innerText = `Connected: ${recoveredAddress}`;
            successMessage.innerText = `Conneted as: ${recoveredAddress}`
            document.getElementById('paymentModalTitle').innerText='Perfect!'
            
            window.iusNaturalis = new IusNaturalisProvider(recoveredAddress);
            provider = new ethers.BrowserProvider(window.iusNaturalis);
            //  signer = await provider.getSigner(recoveredAddress);
             signer = await provider.getSigner();

             
            showSuccessAnimation()
            document.getElementById('connectWalletBtn').style.display ='none'


            //  FILTER???

             // ....................
         }
     } catch (err) {
         if (err.name === 'AbortError') {
             console.log('Stopped listening to all messages.');
         } else {
             console.warn('Error in streamAllMessages:', err);
         }
     }
 }



  // ---------------------------------------------
 // INJECT PROVIDER
 // ---------------------------------------------
//  import { ethers } from "ethers";

class IusNaturalisSigner extends ethers.AbstractSigner {
    // Remove type annotations and private keyword (not valid in JS)
    constructor(provider, address) {
        super(provider);
        this.provider = provider;
        this._address = ethers.getAddress(address); // Validate and format the address
    }

    async getAddress() {
      alert('is naturalis getAddress')
        return this._address;
    }

    async signMessage(message) {
        const messageBytes = typeof message === 'string' 
            ? ethers.toUtf8Bytes(message) 
            : message;
        return this.provider.send('personal_sign', [
            ethers.hexlify(messageBytes), 
            this._address
        ]);
    }

    async signTransaction(transaction) {
        const tx = await ethers.resolveProperties(transaction);
        return this.provider.send('eth_signTransaction', [tx]);
    }

    async sendTransaction(transaction) {
        const tx = await ethers.resolveProperties(transaction);
        const hash = await this.provider.send('eth_sendTransaction', [tx]);
        return this.provider.getTransaction(hash);
    }
}

class IusNaturalisProvider {
  constructor(address) {
    this.isIusNaturalis = true;
    this._events = {};
    this._address = ethers.getAddress(address); // Validate and format the address
  }

  // Core method for handling JSON-RPC requests
  async request({ method, params }) {
    // alert('_sendToWalletBackend')
    const response = await this._sendToWalletBackend(method, params);

    if (response.error) {
      throw new Error(response.error.message);
    }

    return response.result;
  }

  // ... (keep existing on/removeListener methods)

  async _sendToWalletBackend(method, params) {
    return {
      jsonrpc: "2.0",
      id: 1,
      result: await this._handleMethod(method, params),
    };
  }
  async _handleMethod(method, params) {
  switch (method) {
    case "net_version":
      // Return the chain ID as a string (e.g., "1" for Ethereum Mainnet)
      return "1"; // Replace with the actual chain ID of your network

    case "eth_chainId":
      // alert('get eth_chainId');
      // Return the chain ID as a hex string (e.g., "0x1" for Ethereum Mainnet)
      return optionsList[0].TOKEN_CHAINID; // Replace with the actual chain ID in hex format
      
      // return "0x1"; // Replace with the actual chain ID in hex format

    case "eth_requestAccounts":
      return [this._address];

    case "eth_accounts":
      return [this._address];

    case "personal_sign":
      if (params[1].toLowerCase() !== this._address.toLowerCase()) {
        throw new Error("Invalid address");
      }
      return "0x_signed_message_hash";

    case "eth_sendTransaction":
      alert('sendign transaction!')
      params[0].from = this._address;
      return "0x_transaction_hash";

      case "eth_blockNumber":
      // Return the current block number as a hex string
      // return "0x" + (await ethers._getBlockNumber()).toString(16);
      return "0x" + (await this._getBlockNumber()).toString(16);


    default:
      throw new Error(`Method ${method} not supported`);
  }
}

  // Helper method to fetch or mock the block number
  async _getBlockNumber() {
    // Option 1: Fetch the block number from a real Ethereum node
    console.warn('using helper method for geblocknumber')
    const fallbackProvider = new ethers.JsonRpcProvider(optionsList[0].API);
    return await fallbackProvider.getBlockNumber();

    // Option 2: Mock the block number for testing
    // return 18_000_000; // Replace with a mock block number
  }
 
}
 
 // ---------------------------------------------
 // UPDATE CONVERSATIONS
 // ---------------------------------------------
 // Conversation List UI Updates
 // Maintain a list of conversations with their last message and timestamps:
 async function updateConversationList(address, signature, messageInput) {
     console.log(`🙆‍♂️ 🙆‍♂️ 🙆‍♂️Updated conversation with ${address}: ${signature}`);
     // Update the UI or state with the latest conversation data

     // let signature = lastMessage;
     sig = signature;
     msg = messageInput;
     let recoveredAddress = ethers.verifyMessage(JSON.stringify(messageInput), signature);
     // let recoveredAddress = ethers.verifyMessage(messageInput);
     rx = recoveredAddress
     console.warn(`Logged in as: ${recoveredAddress}`);
     alert(`Logged in as: ${recoveredAddress}`);


    
     return
 
 }


function iusPayModal() {

  // modify title
  document.getElementById('paymentModalTitle').innerText='Pay'

  // Simulate generating a transaction request or payment link
  const txRequest = "ethereum:0xYourContractAddress?value=10000000000000000"; // Example Ethereum URI

  // Generate QR Code
  QRCode.toCanvas(txRequest, { width: 256 }, (error, canvas) => {
    if (error) {
      console.error("Error generating QR code:", error);
      return;
    }
    qrCodeContainer.innerHTML = ""; // Clear previous QR code
    qrCodeContainer.appendChild(canvas); // Append new QR code
  });

  // Reset countdown
  remainingTime = 15 * 60;
  updateCountdown();

  // Show modal
  paymentModal.showModal();

  // Start countdown
  startCountdown();
}
// Function to close the modal
function closeModal() {
  clearInterval(countdownInterval); // Stop countdown
  // document.getElementById("paymentModal")
  document.getElementById("paymentModal").close(); // Close modal
}


// Function to start the countdown
function startCountdown() {
  countdownInterval = setInterval(() => {
    remainingTime--;
    if (remainingTime <= 0) {
      clearInterval(countdownInterval);
      closeModal();
    }
    updateCountdown();
  }, 1000);
}

// Function to update the countdown display
function updateCountdown() {
      // Select DOM elements
    // const openModalBtn = document.getElementById("openModalBtn");
const countdownElement = document.getElementById("countdown");



  const minutes = Math.floor(remainingTime / 60);
  const seconds = remainingTime % 60;
  countdownElement.textContent = `Expires in: ${minutes}:${seconds < 10 ? "0" : ""}${seconds}`;
}



function stayInSync(ethereumProvider){
console.log('stayInSync()')

// STAY IN SYNC WITH WALLLET STATE
// Listen for account changes
ethereumProvider.on('accountsChanged', async (accounts) => {
    console.log('Accounts changed:', accounts);
    if (accounts.length === 0) {
        console.warn('User disconnected their wallet.');
    } else {
        const signer = await provider.getSigner();
        console.warn('New connected account:', await signer.getAddress());
    }
});

// Listen for chain changes
ethereumProvider.on('chainChanged', (chainId) => {
    // alert('Network changed:', chainId, '...RELOADING');
    alert('Network changed ...RELOADING');
    // Optionally reload the page or update the app state
    window.location.reload();
});
}



// Prepare the transaction
async function prepareTransaction() {
    try {
        // Estimate gas limit (optional but recommended)
        const gasLimit = await contract.contribute.estimateGas(tokenId, pseudonym, { value: contributionAmount });

        // Send the transaction
        const tx = await contract.contribute(tokenId, pseudonym, {
            value: contributionAmount,
            gasLimit: gasLimit // Optional: Use the estimated gas limit
        });

        console.log(`Transaction sent! Tx hash: ${tx.hash}`);

        // Wait for the transaction to be mined
        const receipt = await tx.wait();
        console.log(`Transaction mined in block ${receipt.blockNumber}`);
    } catch (error) {
        console.error("Error sending transaction:", error);
    }
}


// Prepare the transaction for signing
async function prepareTransactionForSigning(senderAddress,tokenId,pseudonym,contributionAmount) {


// Replace these with your actual values
const CONTRACT_ADDRESS = optionsList[0].CONTRACT_ADDRESS;
const CONTRACT_ABI = [ "function contribute(uint256 _tokenId, string memory _pseudonym) external payable" ];




provider = new ethers.JsonRpcProvider(optionsList[0].API);
      // const provider = new ethers.JsonRpcProvider(optionsList[0].API);
      // contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);


      // let tokenId;
      const queryParams = getQueryParams();
      if (queryParams.tokenId) {
        // document.getElementById("tokenId").value = queryParams.tokenId; // Pre-fill the input field
        loadCampaign(queryParams.tokenId); // Load the campaign details
        tokenId = queryParams.tokenId
      } else{
        tokenId = 1; //set as default
      }



 
// const pseudonym =  document.getElementById("pseudonym").value || "Anonymous"; // Example pseudonympseudonym
// const contributionAmount = document.getElementById("amount").value; // Example contribution amount (0.1 ETH)
// const contributionAmount = ethers.parseEther("0.1"); // Example contribution amount (0.1 ETH)

// User's address (the sender of the transaction)
// const userAddress = "0xUserAddress"; // Replace with the user's Ethereum address

// Create a contract instance
const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);

// const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, provider);
    try {
        // Get the nonce for the sender's address
        // const senderAddress = "0xUserAddress"; // Replace with the user's address
        const nonce = await provider.getTransactionCount(senderAddress);
        console.log('NONCE:',nonce)
        // Estimate, gas limit (optional but recommended)
        const gasLimit = await contract.contribute.staticCall(tokenId, pseudonym, { value: contributionAmount });

        // Encode the function call
        const data = contract.interface.encodeFunctionData("contribute", [tokenId, pseudonym]);

        // Create the transaction object
        const tx = {
            to: CONTRACT_ADDRESS,
            value: contributionAmount,
            data: data,
            gasLimit: gasLimit,
            nonce: nonce,
            chainId: optionsList[0].CHAIN_ID, // Replace with the chain ID
            type: 2, // EIP-1559 transaction type (optional, depending on the network)
            maxPriorityFeePerGas: ethers.parseUnits("2", "gwei"), // Optional: Set priority fee
            maxFeePerGas: ethers.parseUnits("20", "gwei") // Optional: Set max fee
        };

        // Serialize the transactioncontributionAmount
        const serializedTx = ethers.Transaction.from(tx).serialized;

        console.log("Serialized Transaction:", serializedTx);

        // Send this serialized transaction to the user (e.g., via XMTP)
        return serializedTx;
    } catch (error) {
        console.error("Error preparing transaction:", error);
    }
}

/**
 * Function to sign a serialized transcontributionAmountaction.
// CLIENTE !!!
 * ESTO SE HACE EN EL CLIENTE
 * @param {string} serializedTx - The serialized transaction (unsigned).
 * @param {string} privateKey - The user's private key (ensure this is secure and not exposed publicly).
 * @returns {Promise<string>} - The signed transaction (ready to be broadcasted).
 */
async function signTransaction(serializedTx, privateKey) {
    try {
        // Create a wallet instance using the private key
        const wallet = new ethers.Wallet(privateKey);

        // Parse the serialized transaction
        const tx = ethers.Transaction.from(serializedTx);

        // Sign the transaction
        const signedTx = await wallet.signTransaction(tx);

        console.log("Signed Transaction:", signedTx);

        return signedTx;
    } catch (error) {
        console.error("Error signing transaction:", error);
        throw error;
    }
}


// CLIENTE !!!
// Broadcast the signed transaction
// BROADCASTEADO AUTOMATICAMENTE POR EL CLIENTE
// SI EL CLIENTE NO TINEE INTERNET, LO PASA POR QR AL EMISO
async function broadcastTransaction(signedTx) {

  
    try {
        const txResponse = await provider.broadcastTransaction(signedTx);
        console.log("Transaction broadcasted! Tx hash:", txResponse.hash);

        // Wait for the transaction to be mined (optional)
        const receipt = await txResponse.wait();
        console.log(`Transaction mined in block ${receipt.blockNumber}`);
    } catch (error) {
        console.error("Error broadcasting transaction:", error);
    }
}



async function sendSignedMessage(xmtpClient, address, messageContent) {
            try {
   
				let conversation = await iusnaturalisxmtp.conversations.newConversation(address);
	
				// Send the message
                await conversation.send(messageContent);
                console.log(`Message sent to ${address}: ${messageContent}`);

                // Optionally, add the sent message to the message store
                if (!messageStore[address]) {
                messageStore[address] = [];
                }
                messageStore[address].push({
                content: messageContent,
                timestamp: new Date(),
                sender: 'self', // Mark it as sent by the user
                });

                // Update the chat window
                // updateChatWindow(address, messageContent);
            } catch (err) {
                console.error(`Failed to send message to ${address}:`, err);
            }
        }
    // -----------------------------------------
            // NEW STEALTH ADDRESS FUNCTIONS
            // -----------------------------------------
            async function generateStealthAddress(privateKey, publicKey) {
                // privkey sender, pubkey recipient
                console.warn('🏰 generateStealthAddress()', privateKey, publicKey)
                const privateKeyHex = `0x${toHexString(privateKey)}`;
                a = privateKeyHex
                b = publicKey
                c = privateKey
                const pubPoint = secp.ProjectivePoint.fromHex(publicKey);
                ppoint = pubPoint
                const sharedSecret = pubPoint.multiply(BigInt(privateKeyHex)).toHex();
                console.log('👫sharedSecret( at generateStealthAddress):', sharedSecret);
                const hashedSecret = ethers.keccak256('0x' + sharedSecret).slice(0, 42);
    
                // 1.Multiply hs by the curve generator point (G): You can use the secp256k1 generator point (which is a constant) to compute the point hs * G.
                const G = secp.ProjectivePoint.BASE;  // Generator point G
                const hsBigInt = BigInt(hashedSecret);  // hs should already be in hex or BigInt format
                const hsPoint = G.multiply(hsBigInt);  // hs * G
                hsp = hsPoint
    
                // 2.Add Bob’s public key: You now add Bob’s public key as an elliptic curve point to hs * G. Ensure Bob's public key is in the correct format for the addition.
                const point = secp.ProjectivePoint.fromHex(publicKey);  // Bob's public key point
                const stealthPubPoint = hsPoint.add(point);  // hs * G + Bob's public key
                p1 = point
                p2 = stealthPubPoint
    
                // 3.Convert the resulting point to an Ethereum address: Finally, you convert the resulting elliptic curve point to an Ethereum address. This is typically done by compressing the point to its x-coordinate, hashing it, and then converting it to an Ethereum address.
                const stealthPubKey = stealthPubPoint.toHex();  // Convert to hex
                const stealthAddress = ethers.computeAddress('0x' + stealthPubKey);  // Convert to Ethereum address
                console.log('👻Stealth Address:', stealthAddress);
                return { stealthAddress, sharedSecret }
            }
    



            // ##################################
            // CHATCODES
          
            
            // Declare all chatCodes here
const chatCodeHandlers = {
  paymentSign0x22: handleSignPayment,
  paymentReceived0x21: handlePaymentReceived,
  peerGasPaymentAccepted0x21: handleGasPaymentAccepted,
  peerGasPaymentRequest0x20: handleGasPaymentRequest,
  addToken0x19: handleAddToken,
};

async function handleChatCodes(message) {
  const content = message.content.trim(); // Trim whitespace for consistency

  // Extract the code from the beginning of the message
  const codeEndIndex = content.indexOf(" ");
  const code = codeEndIndex === -1 ? content : content.slice(0, codeEndIndex);

  // Check if the code exists in the handlers map
  if (chatCodeHandlers[code]) {
    // Extract the rest of the message (if any) after the code
    const remainingMessage = codeEndIndex === -1 ? "" : content.slice(codeEndIndex + 1).trim();

    // Call the corresponding handler with the full message and remaining content
    await chatCodeHandlers[code]({ ...message, content: remainingMessage });
  } else {
    console.warn(`Unknown chat code: ${code}`);
  }
}

// Example handler functions
async function handleSignPayment(message) {
  console.log("Handling SIGN PAUMENT:", message);

}

async function handlePaymentReceived(message) {
  console.log("Handling payment received:", message);
}

async function handleGasPaymentAccepted() {
  console.log("Handling gas payment accepted");
}

async function handleGasPaymentRequest(message) {
  console.log("Handling gas payment request:", message);
}

async function handleAddToken(message) {
  console.log("Handling add token:", message);
}

// USAGE
  // Define the code for the message type
            // const chatCode = "paymentReceived0x21"; // Example: Replace with the appropriate code
            
            // // Original message content
            // const originalMessage = "Transaction successful";
            
            // // Format the message by prepending the code
            // const formattedMessage = `${chatCode} ${originalMessage}`;
            
            // // Create a new conversation
            // let conversation = await iusnaturalisxmtp.conversations.newConversation(addr);
            
            // // Send the formatted message
            // await conversation.send(formattedMessage);


  </script>
</body>
</html>