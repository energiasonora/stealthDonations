<!DOCTYPE html>
<html lang="en">

<head><script src="ccip.e4336e28.js"></script><script src="index.80bf872c.js"></script><script src="index.6f3b47d2.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Donate to Campaign</title>
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"> -->
    <!-- <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css"> -->
    <link rel="stylesheet" href="index.a089bd87.css">

    <style>:root {
  --font: white;
  --bk: linear-gradient(var(--c0), var(--c0b));
  --bckmodal: #262626;
  --mainBk: #2996b4;
}

body.light-theme, html {
  color: #000;
  background-color: #fff;
}

body.dark-theme, html {
  background-color: #121212;
  background-image: radial-gradient(circle, var(--mainBk) 0%, var(--bckmodal) 100%);
  color: #fff;
}

.progress-bar {
  background-color: #e0e0e0;
  border-radius: 5px;
  width: 100%;
  margin-top: 1rem;
  overflow: hidden;
}

.progress-bar-fill {
  background-color: #4caf50;
  width: 0%;
  height: 20px;
  transition: width .3s;
}

.wallet-option {
  cursor: pointer;
  border-radius: 5px;
  align-items: center;
  margin: 1rem 0;
  padding: .5rem;
  transition: background .3s;
  display: flex;
}

.wallet-option:hover {
  background: #f0f0f0;
}

.wallet-icon {
  width: 32px;
  height: 32px;
  margin-right: 1rem;
}

.connect-wallet-container {
  z-index: 100;
  position: absolute;
  top: 1rem;
  right: 1rem;
}

.connect-wallet-btn {
  color: #fff;
  cursor: pointer;
  background-color: #007bff;
  border: none;
  border-radius: 5px;
  padding: .5rem 1rem;
  font-size: 1rem;
  transition: background-color .3s;
}

.connect-wallet-btn:hover {
  background-color: #0056b3;
}

.success-icon {
  color: #28a745;
  width: 8rem;
  height: 8rem;
  animation: .33s ease-in-out fadeInScale;
}

@keyframes fadeInScale {
  0% {
    opacity: 0;
    transform: scale(.5);
  }

  100% {
    opacity: 1;
    transform: scale(1);
  }
}

.success-section {
  flex-direction: column;
  align-items: center;
  display: none;
}

#successMessage {
  word-break: break-all;
}

#paymentModalTitle {
  text-align: center;
  font-size: small;
}

.copy2clipboard {
  cursor: pointer;
}

.modal {
  background: var(--background-color);
  border-radius: 10px;
  width: 90%;
  max-width: 400px;
  padding: 1rem;
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 4px 10px #0000001a;
}

.modal.active {
  display: block;
}

.walletWith {
  max-width: 400px;
}

.toggle-switch {
  height: 24px;
  display: inline-block;
  position: relative;
  width: 50px !important;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  cursor: pointer;
  background-color: #ccc;
  border-radius: 34px;
  transition: all .4s;
  position: absolute;
  inset: 0;
}

.slider:before {
  content: "";
  background-color: #fff;
  border-radius: 50%;
  width: 16px;
  height: 16px;
  transition: all .4s;
  position: absolute;
  bottom: 4px;
  left: 4px;
}

input:checked + .slider {
  background-color: #2196f3;
}

input:checked + .slider:before {
  transform: translateX(26px);
}

@keyframes errorblink {
  0%, 100% {
    opacity: 1;
  }

  50% {
    opacity: 0;
  }
}

@keyframes blink {
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

#campaignDonor {
  color: red;
}

.success-text {
  font-weight: bold;
  animation: .5s linear blink;
  color: green !important;
}

.blink-text {
  color: red;
  animation: .5s linear 3 blink;
}

.error-text {
  color: red;
  font-weight: bold;
  animation: .5s linear blink;
}

</style>
</head>

<body>
    <nav class="container-fluid">


        <!-- Header -->
        <!-- <header class="container">
        <h1>Stealth Donations</h1>
        <hgroup>
          <p>Connect your wallet and donate</p>
        </hgroup>
       
      </header> -->
        <ul>
            <li><strong>Stealth Donations</strong></li>
        </ul>
        <ul>
            <li><button onclick="openSettings()"> ‚öôÔ∏è Settings</button></li>
            <li id="openBUtton"> <button onclick="openWallet()"> Connect Wallet üîå </button> </li>
            <li id="closeBUtton" style="display: none"> <button onclick="closeWallet()"> Disconnect Wallet üö∂‚Äç‚û°Ô∏è
                </button> </li>
        </ul>
    </nav>


    <main class="container">

        <!-- <h1>Stealth Donations</h1> -->

        <!-- Header -->
        <!-- <header class="container">
        <hgroup>
          <p>Connect your wallet and donate</p>
        </hgroup>
       
      </header> -->

        <!-- Campaign Details -->
        <section id="campaignDetails" style="display: none">
            <h2>Campaign Details</h2>
            <p><span id="campaignDonor"> User not connected</span></p>
            <!-- <p><strong>User:</strong> <span id="campaignDonor"> User not connected</span></p> -->
            <p><strong>Recipient:</strong> <span id="campaignRecipient"></span></p>
            <p><strong>Goal:</strong> <span id="campaignGoal"></span> ETH</p>
            <p><strong>Raised:</strong> <span id="campaignRaised"></span> ETH</p>
            <div class="progress-bar">
                <div class="progress-bar-fill" id="progressBarFill"></div>
            </div>
            <div id="campaignEndedBanner" style="color: red; background-color: #ffebee; border-radius: 5px; margin-top: 1rem; padding: 1rem; display: none">
                <strong>CAMPAIGN HAS ENDED</strong>
            </div>

            <!-- Success Banner -->
            <div id="campaignSuccessBanner" style="color: green; background-color: #e8f5e9; border-radius: 5px; margin-top: 1rem; padding: 1rem; display: none">
                <strong>CAMPAIGN SUCCESSFULLY FUNDED!</strong>
            </div>


            <p><strong>Time Left:</strong> <span id="campaignTimeLeft">Loading...</span></p>
        </section>

        <!-- Donate MODAL -->
        <section id="donateSection" style="display: none">
            <h2>Make a Donation</h2>
            <form id="donateForm">
                <label for="amount">Amount (in ETH):</label>
                <input type="number" id="amount" step="0.01" placeholder="Enter Donation Amount" required="">

                <label for="pseudonym">Pseudonym (Optional):</label>
                <input type="text" id="pseudonym" placeholder="Your Pseudonym">

                <button type="submit">Donate</button>
            </form>
        </section>

        <!-- Donor List -->
        <section id="donorListSection" style="display: none">
            <h2>Donors</h2>
            <ul id="donorList"></ul>
        </section>


    </main>


    <!--PAYMENT/SIGN MODAL -->
    <!-- <dialog id="paymentModal" class="modal"> -->
    <dialog id="paymentModal">
        <article>
            <header>
                <a href="#" aria-label="Close" class="close" data-target="paymentModal"></a>
                <h2 id="paymentModalTitle">Scan QR Code to Pay/Sign</h2>
            </header>
            <div id="qrCodeContainer" style="text-align: center"></div>
            <section id="iusConnect"></section>
            <p id="countdown" style="margin-top: 1rem; font-size: 1.2rem">Expires in: 15:00</p>
            <div id="successSection" class="success-section mt-4">
                <svg class="success-icon" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512">
                    <path fill="currentColor" d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm0 448c-110.5 0-200-89.5-200-200S145.5 56 256 56s200 89.5 200 200-89.5 200-200 200zm101.8-262.2L246.6 302.6c-5.7 6.8-15.5 8.3-22.3 2.6l-67.6-56.3c-6.8-5.7-8.3-15.5-2.6-22.3 5.7-6.8 15.5-8.3 22.3-2.6l55.3 46.1 94.7-113.8c5.7-6.8 15.5-8.3 22.3-2.6 6.8 5.7 8.3 15.5 2.6 22.3z"></path>
                </svg>
                <p class="mt-3 fs-5 text-success" id="successMessage">Payment Successful!</p>
            </div>
            <footer>
                <button id="closeModalBtnPaymentModal" class="outline">Close</button>
            </footer>
        </article>
    </dialog>
    <!--fin PAYMENT/SIGN Modal -->



    <!-- Wallet MODAL -->
    <dialog id="walletModal">
        <article class="walletWith">
            <header>
                <a href="#" aria-label="Close" class="close" data-target="walletModal"></a>
                <h3>Select Wallet</h3>
            </header>
            <div id="walletModalContent">

                <div class="wallet-option" onclick="connectWallet('metamask')">
                    <img src="MetaMask_Fox.eff09779.svg" alt="MetaMask" class="wallet-icon">
                    <span>MetaMask</span>
                </div>

                <div class="wallet-option" onclick="connectWallet('iusnaturalis')">
                    <img src="logoius.362d0e49.svg" alt="iusNaturalis" class="wallet-icon">
                    <span>iusNaturalis</span>
                </div>
                <!-- <button onclick="closeWalletModal()">Cancel</button> -->
            </div>
        </article>
    </dialog>


    <!-- Settings MODAL -->
    <dialog id="settingsModal">
        <article>
            <header>
                <a href="#" aria-label="Close" class="close" data-target="settingsModal"></a>
                <h3>Settings</h3>
            </header>



            <label for="theme-toggle">Dark Mode:</label>
            <label class="toggle-switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>


            <!-- <label>
          <input type="checkbox" id="notificationsToggle"> Enable Notifications
      </label> -->
            <!-- Wallet Selector -->
            <!-- <label for="walletSelector">Choose your wallet:</label>
      <select id="walletSelector" onchange="handleWalletChange()">
        <option value="metamask" selected>Metamask</option>
        <option value="iusNaturalis">Ius Naturalis</option>
        <option value="localTest">Local Test</option>
      </select> -->

            <!-- <label>
        <select id="languageSelect">
            <option value="en">English</option>
            <option value="es">Espa√±ol</option>
            <option value="fr">Fran√ßais</option>
        </select> Language
    </label> -->

            <!-- Dynamic Feedback -->
            <!-- <p id="walletFeedback" style="margin-top: 1rem;">Currently selected: Metamask</p> -->
        </article>
    </dialog>


    <div id="overlay" class="overlay"></div>

    <!-- JavaScript -->
    <script src="index.6e2c0198.js"></script>
    <script src="index.35162719.js"></script>
    <script src="index.c8206c68.js"></script>
    <script src="index.92232d46.js"></script>
    <script src="index.d19c7c05.js"></script>



    <script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"cds6l":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "346bcbedb6488f7a";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        if (e.message) console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"lBzic":[function(require,module,exports) {
// XMTP
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _xmtpJs = require("@xmtp/xmtp-js");
var _secp256K1 = require("@noble/secp256k1");
var _sha256 = require("@noble/hashes/sha256");
var _browserStringHexer = require("browser-string-hexer");
var _browserStringHexerDefault = parcelHelpers.interopDefault(_browserStringHexer);
var _sdk = require("@metamask/sdk");
window.Client = (0, _xmtpJs.Client);
window.secp = _secp256K1;
window.utils = (0, _secp256K1.utils);
window.sha256 = (0, _sha256.sha256);
window.getPublicKey = (0, _secp256K1.getPublicKey);
window.utils = (0, _secp256K1.utils);
window.hexer = (0, _browserStringHexerDefault.default);
window.MetaMaskSDK = (0, _sdk.MetaMaskSDK);

},{"@xmtp/xmtp-js":"gMnkF","@noble/secp256k1":"kJGEF","@noble/hashes/sha256":"hPfLW","browser-string-hexer":"gnnkz","@metamask/sdk":"8rhgp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gMnkF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ApiUrls", ()=>tt);
parcelHelpers.export(exports, "AuthCache", ()=>Qe);
parcelHelpers.export(exports, "BrowserStoragePersistence", ()=>yt);
parcelHelpers.export(exports, "Ciphertext", ()=>N);
parcelHelpers.export(exports, "Client", ()=>sr);
parcelHelpers.export(exports, "Compression", ()=>er);
parcelHelpers.export(exports, "ConsentListEntry", ()=>js);
parcelHelpers.export(exports, "ConversationV1", ()=>Ne);
parcelHelpers.export(exports, "ConversationV2", ()=>De);
parcelHelpers.export(exports, "Conversations", ()=>ht);
parcelHelpers.export(exports, "DecodedMessage", ()=>Ue);
parcelHelpers.export(exports, "EncryptedPersistence", ()=>os);
parcelHelpers.export(exports, "HttpApiClient", ()=>ot);
parcelHelpers.export(exports, "InMemoryKeystore", ()=>ns);
parcelHelpers.export(exports, "InMemoryPersistence", ()=>lt);
parcelHelpers.export(exports, "InvitationV1", ()=>xt);
parcelHelpers.export(exports, "KeyGeneratorKeystoreProvider", ()=>ps);
parcelHelpers.export(exports, "LocalAuthenticator", ()=>mt);
parcelHelpers.export(exports, "MessageV1", ()=>_e);
parcelHelpers.export(exports, "MessageV2", ()=>Ve);
parcelHelpers.export(exports, "NetworkKeystoreProvider", ()=>ws);
parcelHelpers.export(exports, "PrefixedPersistence", ()=>cs);
parcelHelpers.export(exports, "PrivateKey", ()=>Y);
parcelHelpers.export(exports, "PrivateKeyBundleV1", ()=>He);
parcelHelpers.export(exports, "PrivateKeyBundleV2", ()=>Ge);
parcelHelpers.export(exports, "PublicKey", ()=>oe);
parcelHelpers.export(exports, "PublicKeyBundle", ()=>de);
parcelHelpers.export(exports, "SealedInvitation", ()=>Ut);
parcelHelpers.export(exports, "Signature", ()=>te);
parcelHelpers.export(exports, "SignedPublicKey", ()=>ae);
parcelHelpers.export(exports, "SignedPublicKeyBundle", ()=>ce);
parcelHelpers.export(exports, "SnapProvider", ()=>Ns);
parcelHelpers.export(exports, "SortDirection", ()=>et);
parcelHelpers.export(exports, "StaticKeystoreProvider", ()=>Ds);
parcelHelpers.export(exports, "Stream", ()=>ye);
parcelHelpers.export(exports, "buildContentTopic", ()=>Pe);
parcelHelpers.export(exports, "buildDirectMessageTopic", ()=>Se);
parcelHelpers.export(exports, "buildDirectMessageTopicV2", ()=>Ae);
parcelHelpers.export(exports, "buildUserContactTopic", ()=>Te);
parcelHelpers.export(exports, "buildUserIntroTopic", ()=>Ce);
parcelHelpers.export(exports, "buildUserInviteTopic", ()=>Ie);
parcelHelpers.export(exports, "buildUserPrivateStoreTopic", ()=>Be);
parcelHelpers.export(exports, "dateToNs", ()=>me);
parcelHelpers.export(exports, "decodeContactBundle", ()=>Os);
parcelHelpers.export(exports, "decodeContent", ()=>qe);
parcelHelpers.export(exports, "decrypt", ()=>U);
parcelHelpers.export(exports, "defaultKeystoreProviders", ()=>ar);
parcelHelpers.export(exports, "encrypt", ()=>V);
parcelHelpers.export(exports, "exportHmacKey", ()=>F);
parcelHelpers.export(exports, "fromNanoString", ()=>be);
parcelHelpers.export(exports, "generateHmacSignature", ()=>G);
parcelHelpers.export(exports, "hkdfHmacKey", ()=>L);
parcelHelpers.export(exports, "importHmacKey", ()=>$);
parcelHelpers.export(exports, "keystoreApiDefs", ()=>Is);
parcelHelpers.export(exports, "mapPaginatedStream", ()=>Ye);
parcelHelpers.export(exports, "nsToDate", ()=>ge);
parcelHelpers.export(exports, "retry", ()=>We);
parcelHelpers.export(exports, "snapKeystoreApiDefs", ()=>Bs);
parcelHelpers.export(exports, "toNanoString", ()=>ve);
parcelHelpers.export(exports, "verifyHmacSignature", ()=>H);
var _proto = require("@xmtp/proto");
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _secp256K1 = require("@noble/secp256k1");
var _viem = require("viem");
var _contentTypeText = require("@xmtp/content-type-text");
var _contentTypePrimitives = require("@xmtp/content-type-primitives");
var _asyncMutex = require("async-mutex");
var _elliptic = require("elliptic");
var _ellipticDefault = parcelHelpers.interopDefault(_elliptic);
var _web = require("@xmtp/user-preferences-bindings-wasm/web");
var _webDefault = parcelHelpers.interopDefault(_web);
var _consentProofSignature = require("@xmtp/consent-proof-signature");
var Buffer = require("eaf94225b1296aaa").Buffer;
class N {
    constructor(e){
        if (!e.aes256GcmHkdfSha256) throw new Error("invalid ciphertext");
        if (e.aes256GcmHkdfSha256.payload.length < 16) throw new Error(`invalid ciphertext ciphertext length: ${e.aes256GcmHkdfSha256.payload.length}`);
        if (32 !== e.aes256GcmHkdfSha256.hkdfSalt.length) throw new Error(`invalid ciphertext salt length: ${e.aes256GcmHkdfSha256.hkdfSalt.length}`);
        if (12 !== e.aes256GcmHkdfSha256.gcmNonce.length) throw new Error(`invalid ciphertext nonce length: ${e.aes256GcmHkdfSha256.gcmNonce.length}`);
        this.aes256GcmHkdfSha256 = e.aes256GcmHkdfSha256;
    }
    toBytes() {
        return (0, _proto.ciphertext).Ciphertext.encode(this).finish();
    }
    static fromBytes(t) {
        return new N((0, _proto.ciphertext).Ciphertext.decode(t));
    }
}
const D = window.crypto, M = (new Uint8Array).buffer, x = (new Uint8Array).buffer;
async function _(e) {
    return new Uint8Array(await D.subtle.digest("SHA-256", e));
}
async function V(e, t, s) {
    const r = D.getRandomValues(new Uint8Array(32)), n = D.getRandomValues(new Uint8Array(12)), i = await q(t, r), a = await D.subtle.encrypt(O(n, s), i, e);
    return new N({
        aes256GcmHkdfSha256: {
            payload: new Uint8Array(a),
            hkdfSalt: r,
            gcmNonce: n
        }
    });
}
async function U(e, t, s) {
    if (!e.aes256GcmHkdfSha256) throw new Error("invalid payload ciphertext");
    const r = await q(t, e.aes256GcmHkdfSha256.hkdfSalt), n = await D.subtle.decrypt(O(e.aes256GcmHkdfSha256.gcmNonce, s), r, e.aes256GcmHkdfSha256.payload);
    return new Uint8Array(n);
}
function O(e, t) {
    const s = {
        name: "AES-GCM",
        iv: e
    };
    return t && (s.additionalData = t), s;
}
async function q(e, t) {
    const s = await D.subtle.importKey("raw", e, "HKDF", !1, [
        "deriveKey"
    ]);
    return D.subtle.deriveKey({
        name: "HKDF",
        hash: "SHA-256",
        salt: t,
        info: M
    }, s, {
        name: "AES-GCM",
        length: 256
    }, !1, [
        "encrypt",
        "decrypt"
    ]);
}
async function L(e, t) {
    const s = await D.subtle.importKey("raw", e, "HKDF", !1, [
        "deriveKey"
    ]);
    return D.subtle.deriveKey({
        name: "HKDF",
        hash: "SHA-256",
        salt: x,
        info: t
    }, s, {
        name: "HMAC",
        hash: "SHA-256",
        length: 256
    }, !0, [
        "sign",
        "verify"
    ]);
}
async function G(e, t, s) {
    const r = await L(e, t), n = await D.subtle.sign("HMAC", r, s);
    return new Uint8Array(n);
}
async function H(e, t, s) {
    return await D.subtle.verify("HMAC", e, t, s);
}
async function F(e) {
    const t = await D.subtle.exportKey("raw", e);
    return new Uint8Array(t);
}
async function $(e) {
    return D.subtle.importKey("raw", e, {
        name: "HMAC",
        hash: "SHA-256",
        length: 256
    }, !0, [
        "sign",
        "verify"
    ]);
}
const j = _secp256K1.utils.bytesToHex;
function X(e, t) {
    if (e.length !== t.length) return !1;
    for(let s = 0; s < e.length; s++)if (e[s] !== t[s]) return !1;
    return !0;
}
function J(e) {
    const t = (0, _viem.hexToSignature)(e), s = (0, _viem.hexToBytes)(t.r), r = (0, _viem.hexToBytes)(t.s);
    let n = Number(t.v);
    0 !== n && 1 !== n || (n += 27);
    const i = 1 - n % 2, a = new Uint8Array(64);
    return a.set(s), a.set(r, s.length), {
        bytes: a,
        recovery: i
    };
}
function z(e) {
    if (32 !== e.bytes.length) throw new Error(`invalid private key length: ${e.bytes.length}`);
}
class W {
    constructor(e){
        if (!e.secp256k1) throw new Error("invalid private key");
        if (z(e.secp256k1), this.secp256k1 = e.secp256k1, this.createdNs = e.createdNs, !e.publicKey) throw new Error("missing public key");
        this.publicKey = new ae(e.publicKey);
    }
    static async generate(e) {
        const t = {
            bytes: _secp256K1.utils.randomPrivateKey()
        }, s = (0, _longDefault.default).fromNumber((new Date).getTime()).mul(1e6), r = new ie({
            secp256k1Uncompressed: {
                bytes: _secp256K1.getPublicKey(t.bytes)
            },
            createdNs: s
        }), n = await e.signKey(r);
        return new W({
            secp256k1: t,
            createdNs: s,
            publicKey: n
        });
    }
    generated() {
        return new Date(this.createdNs.div(1e6).toNumber());
    }
    async sign(e) {
        const [t, s] = await _secp256K1.sign(e, this.secp256k1.bytes, {
            recovered: !0,
            der: !1
        });
        return new te({
            ecdsaCompact: {
                bytes: t,
                recovery: s
            }
        });
    }
    async signKey(e) {
        const t = e.toBytes(), s = await _(t), r = await this.sign(s);
        return new ae({
            keyBytes: t,
            signature: r
        });
    }
    static async signerKey(e, t) {
        return ee(await _(e.bytesToSign()), t);
    }
    sharedSecret(e) {
        return _secp256K1.getSharedSecret(this.secp256k1.bytes, e.secp256k1Uncompressed.bytes, !1);
    }
    encrypt(e, t, s) {
        return V(e, this.sharedSecret(t), s);
    }
    decrypt(e, t, s) {
        return U(e, this.sharedSecret(t), s);
    }
    matches(e) {
        return this.publicKey.equals(e);
    }
    equals(e) {
        return X(this.secp256k1.bytes, e.secp256k1.bytes) && this.publicKey.equals(e.publicKey);
    }
    toBytes() {
        return (0, _proto.privateKey).SignedPrivateKey.encode(this).finish();
    }
    validatePublicKey() {
        return X(_secp256K1.getPublicKey(this.secp256k1.bytes), this.publicKey.secp256k1Uncompressed.bytes);
    }
    static fromBytes(e) {
        return new W((0, _proto.privateKey).SignedPrivateKey.decode(e));
    }
    static fromLegacyKey(e, t) {
        return new W({
            createdNs: e.timestamp.mul(1e6),
            secp256k1: e.secp256k1,
            publicKey: ae.fromLegacyKey(e.publicKey, t)
        });
    }
}
class Y {
    constructor(e){
        if (!e.secp256k1) throw new Error("invalid private key");
        if (z(e.secp256k1), this.timestamp = e.timestamp, this.secp256k1 = e.secp256k1, !e.publicKey) throw new Error("missing public key");
        this.publicKey = new oe(e.publicKey);
    }
    static generate() {
        const e = {
            bytes: _secp256K1.utils.randomPrivateKey()
        }, t = (0, _longDefault.default).fromNumber((new Date).getTime());
        return new Y({
            secp256k1: e,
            timestamp: t,
            publicKey: new oe({
                secp256k1Uncompressed: {
                    bytes: _secp256K1.getPublicKey(e.bytes)
                },
                timestamp: t
            })
        });
    }
    generated() {
        return new Date(this.timestamp.toNumber());
    }
    async sign(e) {
        const [t, s] = await _secp256K1.sign(e, this.secp256k1.bytes, {
            recovered: !0,
            der: !1
        });
        return new te({
            ecdsaCompact: {
                bytes: t,
                recovery: s
            }
        });
    }
    async signKey(e) {
        const t = await _(e.bytesToSign());
        return e.signature = await this.sign(t), e;
    }
    sharedSecret(e) {
        return _secp256K1.getSharedSecret(this.secp256k1.bytes, e.secp256k1Uncompressed.bytes, !1);
    }
    encrypt(e, t, s) {
        return V(e, this.sharedSecret(t), s);
    }
    decrypt(e, t, s) {
        return U(e, this.sharedSecret(t), s);
    }
    matches(e) {
        return this.publicKey.equals(e);
    }
    validatePublicKey() {
        return X(_secp256K1.getPublicKey(this.secp256k1.bytes), this.publicKey.secp256k1Uncompressed.bytes);
    }
    toBytes() {
        return (0, _proto.privateKey).PrivateKey.encode(this).finish();
    }
    static fromBytes(e) {
        return new Y((0, _proto.privateKey).PrivateKey.decode(e));
    }
}
function Q(e) {
    if (64 !== e.bytes.length) throw new Error(`invalid signature length: ${e.bytes.length}`);
    if (0 !== e.recovery && 1 !== e.recovery) throw new Error(`invalid recovery bit: ${e.recovery}`);
}
function Z(e, t) {
    return e.recovery === t.recovery && X(e.bytes, t.bytes);
}
function ee(e, t) {
    const s = _secp256K1.recoverPublicKey(e, t.bytes, t.recovery);
    return s ? new ie({
        secp256k1Uncompressed: {
            bytes: s
        },
        createdNs: (0, _longDefault.default).fromNumber(0)
    }) : void 0;
}
class te {
    constructor(e){
        if (e.ecdsaCompact) Q(e.ecdsaCompact), this.ecdsaCompact = e.ecdsaCompact;
        else {
            if (!e.walletEcdsaCompact) throw new Error("invalid signature");
            Q(e.walletEcdsaCompact), this.walletEcdsaCompact = e.walletEcdsaCompact;
        }
    }
    async signerKey(e) {
        return this.ecdsaCompact ? W.signerKey(e, this.ecdsaCompact) : this.walletEcdsaCompact ? re.signerKey(e, this.walletEcdsaCompact) : void 0;
    }
    getPublicKey(e) {
        let t;
        if (this.ecdsaCompact) t = _secp256K1.recoverPublicKey(e, this.ecdsaCompact.bytes, this.ecdsaCompact.recovery);
        else {
            if (!this.walletEcdsaCompact) throw new Error("invalid v1 signature");
            t = _secp256K1.recoverPublicKey(e, this.walletEcdsaCompact.bytes, this.walletEcdsaCompact.recovery);
        }
        return t ? new oe({
            secp256k1Uncompressed: {
                bytes: t
            },
            timestamp: (0, _longDefault.default).fromNumber(0)
        }) : void 0;
    }
    equals(e) {
        return this.ecdsaCompact && e.ecdsaCompact ? Z(this.ecdsaCompact, e.ecdsaCompact) : !(!this.walletEcdsaCompact || !e.walletEcdsaCompact) && Z(this.walletEcdsaCompact, e.walletEcdsaCompact);
    }
    toBytes() {
        return (0, _proto.signature).Signature.encode(this).finish();
    }
    static fromBytes(e) {
        return new te((0, _proto.signature).Signature.decode(e));
    }
}
var se;
!function(e) {
    e[e.INBOX_KEY = 0] = "INBOX_KEY", e[e.SEND_KEY = 1] = "SEND_KEY";
}(se || (se = {}));
class re {
    constructor(e){
        this.wallet = e;
    }
    static identitySigRequestText(e) {
        return `XMTP : Create Identity\n${j(e)}\n\nFor more info: https://xmtp.org/signatures/`;
    }
    static signerKey(e, t) {
        return ee((0, _viem.hexToBytes)((0, _viem.hashMessage)(this.identitySigRequestText(e.bytesToSign()))), t);
    }
    async signKey(e) {
        const t = e.toBytes(), s = await this.wallet.signMessage(re.identitySigRequestText(t)), { bytes: r, recovery: n } = J(s), i = new te({
            walletEcdsaCompact: {
                bytes: r,
                recovery: n
            }
        });
        return new ae({
            keyBytes: t,
            signature: i
        });
    }
}
const ne = new (0, _longDefault.default)(10 ** 9).mul(10 ** 9);
class ie {
    constructor(e){
        if (!e?.secp256k1Uncompressed) throw new Error("invalid public key");
        !function(e) {
            if (65 !== e.bytes.length) throw new Error(`invalid public key length: ${e.bytes.length}`);
            if (4 !== e.bytes[0]) throw new Error(`unrecognized public key prefix: ${e.bytes[0]}`);
        }(e.secp256k1Uncompressed), this.secp256k1Uncompressed = e.secp256k1Uncompressed, this.createdNs = e.createdNs.toUnsigned();
    }
    generated() {
        return new Date(this.timestamp.toNumber());
    }
    isFromLegacyKey() {
        return this.createdNs.lessThan(ne);
    }
    get timestamp() {
        return (this.isFromLegacyKey() ? this.createdNs : this.createdNs.div(1e6)).toUnsigned();
    }
    verify(e, t) {
        return !!e.ecdsaCompact && _secp256K1.verify(e.ecdsaCompact.bytes, t, this.secp256k1Uncompressed.bytes);
    }
    async verifyKey(e) {
        if (!e.signature) return !1;
        const t = await _(e.bytesToSign());
        return this.verify(e.signature, t);
    }
    equals(e) {
        return X(this.secp256k1Uncompressed.bytes, e.secp256k1Uncompressed.bytes);
    }
    getEthereumAddress() {
        return function(e) {
            const t = (0, _viem.bytesToHex)(e.slice(1)), s = (0, _viem.keccak256)(t), r = s.substring(s.length - 40);
            return (0, _viem.getAddress)(`0x${r}`);
        }(this.secp256k1Uncompressed.bytes);
    }
    toBytes() {
        return (0, _proto.publicKey).UnsignedPublicKey.encode(this).finish();
    }
    static fromBytes(e) {
        return new ie((0, _proto.publicKey).UnsignedPublicKey.decode(e));
    }
}
class ae extends ie {
    constructor(e){
        if (!e.keyBytes) throw new Error("missing key bytes");
        if (super((0, _proto.publicKey).UnsignedPublicKey.decode(e.keyBytes)), this.keyBytes = e.keyBytes, !e.signature) throw new Error("missing key signature");
        this.signature = new te(e.signature);
    }
    get unsignedKey() {
        return new ie({
            createdNs: this.createdNs,
            secp256k1Uncompressed: this.secp256k1Uncompressed
        });
    }
    signerKey() {
        return this.signature.signerKey(this);
    }
    async walletSignatureAddress() {
        if (!this.signature.walletEcdsaCompact) throw new Error("key was not signed by a wallet");
        const e = await this.signerKey();
        if (!e) throw new Error("key signature not valid");
        return e.getEthereumAddress();
    }
    equals(e) {
        return this.unsignedKey.equals(e.unsignedKey) && this.signature.equals(e.signature);
    }
    bytesToSign() {
        return this.keyBytes;
    }
    toBytes() {
        return (0, _proto.publicKey).SignedPublicKey.encode(this).finish();
    }
    static fromBytes(e) {
        return new ae((0, _proto.publicKey).SignedPublicKey.decode(e));
    }
    toLegacyKey() {
        if (!this.isFromLegacyKey()) throw new Error("cannot be converted to legacy key");
        let e = this.signature;
        return e.walletEcdsaCompact && (e = new te({
            ecdsaCompact: e.walletEcdsaCompact
        })), new oe({
            timestamp: this.timestamp,
            secp256k1Uncompressed: this.secp256k1Uncompressed,
            signature: e
        });
    }
    static fromLegacyKey(e, t) {
        if (!e.signature) throw new Error("key is not signed");
        let s = e.signature;
        return t && (s = new te({
            walletEcdsaCompact: s.ecdsaCompact
        })), new ae({
            keyBytes: e.bytesToSign(),
            signature: s
        });
    }
}
class oe extends ie {
    constructor(e){
        super({
            createdNs: e.timestamp.mul(1e6),
            secp256k1Uncompressed: e.secp256k1Uncompressed
        }), e.signature && (!e.signature.ecdsaCompact && e.signature.walletEcdsaCompact ? this.signature = new te({
            ecdsaCompact: {
                bytes: e.signature.walletEcdsaCompact.bytes,
                recovery: e.signature.walletEcdsaCompact.recovery
            }
        }) : this.signature = new te(e.signature));
    }
    get timestamp() {
        return this.createdNs.div(1e6);
    }
    bytesToSign() {
        return (0, _proto.publicKey).PublicKey.encode({
            timestamp: this.timestamp,
            secp256k1Uncompressed: this.secp256k1Uncompressed
        }).finish();
    }
    async signWithWallet(e) {
        const t = await e.signMessage(re.identitySigRequestText(this.bytesToSign())), { bytes: s, recovery: r } = J(t);
        this.signature = new te({
            ecdsaCompact: {
                bytes: s,
                recovery: r
            }
        });
    }
    walletSignatureAddress() {
        if (!this.signature) throw new Error("key is not signed");
        const e = (0, _viem.hexToBytes)((0, _viem.hashMessage)(re.identitySigRequestText(this.bytesToSign()))), t = this.signature.getPublicKey(e);
        if (!t) throw new Error("key signature is malformed");
        return t.getEthereumAddress();
    }
    toBytes() {
        return (0, _proto.publicKey).PublicKey.encode(this).finish();
    }
    static fromBytes(e) {
        return new oe((0, _proto.publicKey).PublicKey.decode(e));
    }
}
class ce {
    constructor(e){
        if (!e.identityKey) throw new Error("missing identity key");
        if (!e.preKey) throw new Error("missing pre-key");
        this.identityKey = new ae(e.identityKey), this.preKey = new ae(e.preKey);
    }
    walletSignatureAddress() {
        return this.identityKey.walletSignatureAddress();
    }
    equals(e) {
        return this.identityKey.equals(e.identityKey) && this.preKey.equals(e.preKey);
    }
    toBytes() {
        return (0, _proto.publicKey).SignedPublicKeyBundle.encode(this).finish();
    }
    isFromLegacyBundle() {
        return this.identityKey.isFromLegacyKey() && this.preKey.isFromLegacyKey();
    }
    toLegacyBundle() {
        return new de({
            identityKey: this.identityKey.toLegacyKey(),
            preKey: this.preKey.toLegacyKey()
        });
    }
    static fromBytes(e) {
        const t = (0, _proto.publicKey).SignedPublicKeyBundle.decode(e);
        return new ce(t);
    }
    static fromLegacyBundle(e) {
        return new ce({
            identityKey: ae.fromLegacyKey(e.identityKey, !0),
            preKey: ae.fromLegacyKey(e.preKey)
        });
    }
}
class de {
    constructor(e){
        if (!e.identityKey) throw new Error("missing identity key");
        if (!e.preKey) throw new Error("missing pre-key");
        this.identityKey = new oe(e.identityKey), this.preKey = new oe(e.preKey);
    }
    equals(e) {
        return this.identityKey.equals(e.identityKey) && this.preKey.equals(e.preKey);
    }
    walletSignatureAddress() {
        return this.identityKey.walletSignatureAddress();
    }
    toBytes() {
        return (0, _proto.publicKey).PublicKeyBundle.encode(this).finish();
    }
    static fromBytes(e) {
        const t = (0, _proto.publicKey).PublicKeyBundle.decode(e);
        return new de(t);
    }
}
class he {
    constructor(e, t){
        this.messageEnvelope = e, this.onSend = t;
    }
    async messageID() {
        if (!this.messageEnvelope.message) throw new Error("no envelope message");
        return j(await _(this.messageEnvelope.message));
    }
    async send() {
        return this.onSend();
    }
}
class ye {
    constructor(e, t, s, r, n){
        this.messages = [], this.resolvers = [], this.topics = t, this.client = e, this.callback = this.newMessageCallback(s, r), this.onConnectionLost = n;
    }
    newMessageCallback(e, t) {
        return async (s)=>{
            if (s.message) try {
                const r = await e(s);
                if (!r) return;
                if (t) {
                    const e = t(r);
                    e && this.resubscribeToTopics(e);
                }
                const n = this.resolvers.pop();
                n ? n({
                    value: r
                }) : this.messages.unshift(r);
            } catch (e) {
                console.warn(e);
            }
        };
    }
    async start() {
        if (!this.callback) throw new Error("Missing callback for stream");
        this.subscriptionManager = this.client.apiClient.subscribe({
            contentTopics: this.topics
        }, async (e)=>{
            this.callback && await this?.callback(e);
        }, this.onConnectionLost);
    }
    static async create(e, t, s, r, n) {
        const i = new ye(e, t, s, r, n);
        return await i.start(), i;
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    async return() {
        return this.subscriptionManager && await this.subscriptionManager.unsubscribe(), this.callback ? (this.callback = void 0, this.resolvers.forEach((e)=>e({
                value: void 0,
                done: !0
            })), {
            value: void 0,
            done: !0
        }) : {
            value: void 0,
            done: !0
        };
    }
    next() {
        const e = this.messages.pop();
        return e ? Promise.resolve({
            value: e
        }) : this.callback ? new Promise((e)=>this.resolvers.unshift(e)) : Promise.resolve({
            value: void 0,
            done: !0
        });
    }
    async resubscribeToTopics(e) {
        if (!this.callback || !this.subscriptionManager) throw new Error("Missing callback for stream");
        if ("function" == typeof this.subscriptionManager?.updateContentTopics) return this.subscriptionManager.updateContentTopics(e);
        await this.subscriptionManager.unsubscribe(), this.topics = e, this.subscriptionManager = this.client.apiClient.subscribe({
            contentTopics: this.topics
        }, async (e)=>{
            this.callback && await this?.callback(e);
        }, this.onConnectionLost);
    }
}
const { b64Decode: ue, b64Encode: le } = (0, _proto.fetcher);
function pe(e, t) {
    const s = new Uint8Array(e.length + t.length);
    return s.set(e), s.set(t, e.length), s;
}
function we(e) {
    const t = new ArrayBuffer(4);
    return new DataView(t).setInt32(0, e, !0), new Uint8Array(t);
}
function fe(e) {
    const t = e.buffer;
    return new DataView(t).getInt32(0, !0);
}
function me(e) {
    return (0, _longDefault.default).fromNumber(e.valueOf()).multiply(1e6);
}
function ge(e) {
    return new Date(e.divide(1e6).toNumber());
}
const ve = (e)=>e && me(e).toString(), be = (e)=>{
    if (e) return ge((0, _longDefault.default).fromString(e));
};
class Ee extends Error {
    constructor(e, t){
        super(t), this.code = e;
    }
}
const Ke = (e)=>{
    if (e.error) throw new Ee(e.error.code, e.error.message);
    if (!e.result) throw new Ee((0, _proto.keystore).ErrorCode.ERROR_CODE_UNSPECIFIED, "No result from Keystore");
    if ("encrypted" in e.result && !e.result.encrypted) throw new Error("Missing ciphertext");
    if ("decrypted" in e.result && !e.result.decrypted) throw new Error("Missing decrypted result");
    return e.result;
}, ke = (e, t)=>({
        requests: e.map((e)=>{
            const s = new de({
                identityKey: e.header.sender?.identityKey,
                preKey: e.header.sender?.preKey
            }), r = t.equals(s);
            return {
                payload: e.ciphertext,
                peerKeys: r ? new de({
                    identityKey: e.header.recipient?.identityKey,
                    preKey: e.header.recipient?.preKey
                }) : s,
                headerBytes: e.headerBytes,
                isSender: r
            };
        })
    }), Pe = (e)=>`/xmtp/0/${e}/proto`, Se = (e, t)=>{
    const s = [
        (0, _viem.getAddress)(e),
        (0, _viem.getAddress)(t)
    ];
    return s.sort(), Pe(`dm-${s.join("-")}`);
}, Ae = (e)=>Pe(`m-${e}`), Te = (e)=>Pe(`contact-${(0, _viem.getAddress)(e)}`), Ce = (e)=>Pe(`intro-${(0, _viem.getAddress)(e)}`), Ie = (e)=>Pe(`invite-${(0, _viem.getAddress)(e)}`), Be = (e)=>Pe(`privatestore-${e}`), Re = (e)=>{
    const t = /^[\x21-\x7F]+$/, s = e.indexOf("0/");
    if (-1 !== s) {
        const r = e.substring(s + 2, e.lastIndexOf("/proto"));
        return t.test(r);
    }
    return !1;
};
class Ne {
    constructor(e, t, s){
        this.conversationVersion = "v1", this.context = void 0, this.peerAddress = (0, _viem.getAddress)(t), this.client = e, this.createdAt = s;
    }
    get clientAddress() {
        return this.client.address;
    }
    async allow() {
        await this.client.contacts.allow([
            this.peerAddress
        ]);
    }
    async deny() {
        await this.client.contacts.deny([
            this.peerAddress
        ]);
    }
    get isAllowed() {
        return this.client.contacts.isAllowed(this.peerAddress);
    }
    get isDenied() {
        return this.client.contacts.isDenied(this.peerAddress);
    }
    get consentState() {
        return this.client.contacts.consentState(this.peerAddress);
    }
    get topic() {
        return Se(this.peerAddress, this.client.address);
    }
    get ephemeralTopic() {
        return Se(this.peerAddress, this.client.address).replace("/xmtp/0/dm-", "/xmtp/0/dmE-");
    }
    async messages(e) {
        const t = Se(this.peerAddress, this.client.address), s = await this.client.listEnvelopes(t, this.processEnvelope.bind(this), e);
        return this.decryptBatch(s, t, !1);
    }
    messagesPaginated(e) {
        return this.client.listEnvelopesPaginated(this.topic, this.decodeMessage.bind(this), e);
    }
    async decodeMessage(e) {
        if (!e.contentTopic) throw new Error("Missing content topic");
        const t = await this.processEnvelope(e), s = await this.decryptBatch([
            t
        ], e.contentTopic, !0);
        if (!s.length) throw new Error("No results");
        return s[0];
    }
    async prepareMessage(e, t) {
        let s, r = await this.client.getUserContact(this.peerAddress);
        if (!r) throw new Error(`recipient ${this.peerAddress} is not registered`);
        r instanceof de || (r = r.toLegacyBundle());
        const n = t?.ephemeral ? this.ephemeralTopic : this.topic;
        this.client.contacts.addresses.has(this.peerAddress) ? s = [
            n
        ] : (s = [
            Ce(this.peerAddress),
            Ce(this.client.address),
            n
        ], this.client.contacts.addresses.add(this.peerAddress));
        const { payload: i } = await this.client.encodeContent(e, t), a = await this.createMessage(i, r, t?.timestamp), o = a.toBytes(), c = {
            contentTopic: n,
            message: o,
            timestampNs: ve(a.sent)
        };
        return new he(c, async ()=>(await this.client.publishEnvelopes(s.map((e)=>({
                    contentTopic: e,
                    message: o,
                    timestamp: a.sent
                }))), Ue.fromV1Message(a, e, t?.contentType || (0, _contentTypeText.ContentTypeText), i, n, this)));
    }
    streamMessages(e) {
        return ye.create(this.client, [
            this.topic
        ], async (e)=>this.decodeMessage(e), void 0, e);
    }
    async processEnvelope({ message: e, contentTopic: t }) {
        if (!e || !e.length) throw new Error("empty envelope");
        const s = await _e.fromBytes(e), { senderAddress: r, recipientAddress: n } = s;
        if (!r || !n || !t || Se(r, n) !== this.topic) throw new Error("Headers do not match intended recipient");
        return s;
    }
    streamEphemeral(e) {
        return ye.create(this.client, [
            this.ephemeralTopic
        ], this.decodeMessage.bind(this), void 0, e);
    }
    async send(e, t) {
        let s, r = await this.client.getUserContact(this.peerAddress);
        if (!r) throw new Error(`recipient ${this.peerAddress} is not registered`);
        r instanceof de || (r = r.toLegacyBundle());
        const n = t?.ephemeral ? this.ephemeralTopic : this.topic;
        this.client.contacts.addresses.has(this.peerAddress) ? s = [
            n
        ] : (s = [
            Ce(this.peerAddress),
            Ce(this.client.address),
            n
        ], this.client.contacts.addresses.add(this.peerAddress));
        const i = t?.contentType || (0, _contentTypeText.ContentTypeText), { payload: a } = await this.client.encodeContent(e, t), o = await this.createMessage(a, r, t?.timestamp);
        return await this.client.publishEnvelopes(s.map((e)=>({
                contentTopic: e,
                message: o.toBytes(),
                timestamp: o.sent
            }))), "unknown" === this.consentState && await this.allow(), Ue.fromV1Message(o, e, i, a, n, this);
    }
    async decryptBatch(e, t, s = !1) {
        const r = (await this.client.keystore.decryptV1(ke(e, this.client.publicKeyBundle))).responses, n = [];
        for(let i = 0; i < r.length; i++){
            const a = r[i], o = e[i];
            try {
                const { decrypted: e } = Ke(a);
                n.push(await this.buildDecodedMessage(o, e, t));
            } catch (e) {
                if (s) throw e;
                console.warn("Error decoding content", e);
            }
        }
        return n;
    }
    async buildDecodedMessage(e, t, s) {
        const { content: r, contentType: n, error: i, contentFallback: a } = await this.client.decodeContent(t);
        return Ue.fromV1Message(e, r, n, t, s, this, i, a);
    }
    async createMessage(e, t, s) {
        return s = s || new Date, _e.encode(this.client.keystore, e, this.client.publicKeyBundle, t, s);
    }
}
class De {
    constructor(e, t, s, r, n, i){
        this.conversationVersion = "v2", this.topic = t, this.createdAt = r, this.context = n, this.client = e, this.peerAddress = s, this.consentProof = i;
    }
    get clientAddress() {
        return this.client.address;
    }
    async allow() {
        await this.client.contacts.allow([
            this.peerAddress
        ]);
    }
    async deny() {
        await this.client.contacts.deny([
            this.peerAddress
        ]);
    }
    get isAllowed() {
        return this.client.contacts.isAllowed(this.peerAddress);
    }
    get isDenied() {
        return this.client.contacts.isDenied(this.peerAddress);
    }
    get consentState() {
        return this.client.contacts.consentState(this.peerAddress);
    }
    get consentProofPayload() {
        return this.consentProof;
    }
    async messages(e) {
        const t = await this.client.listEnvelopes(this.topic, this.processEnvelope.bind(this), e);
        return this.decryptBatch(t, !1);
    }
    messagesPaginated(e) {
        return this.client.listEnvelopesPaginated(this.topic, this.decodeMessage.bind(this), e);
    }
    get ephemeralTopic() {
        return this.topic.replace("/xmtp/0/m", "/xmtp/0/mE");
    }
    streamEphemeral(e) {
        return ye.create(this.client, [
            this.ephemeralTopic
        ], this.decodeMessage.bind(this), void 0, e);
    }
    streamMessages(e) {
        return ye.create(this.client, [
            this.topic
        ], this.decodeMessage.bind(this), void 0, e);
    }
    async send(e, t) {
        const { payload: s, shouldPush: r } = await this.client.encodeContent(e, t), n = await this.createMessage(s, r, t?.timestamp), i = t?.ephemeral ? this.ephemeralTopic : this.topic;
        await this.client.publishEnvelopes([
            {
                contentTopic: i,
                message: n.toBytes(),
                timestamp: n.sent
            }
        ]);
        const a = t?.contentType || (0, _contentTypeText.ContentTypeText);
        return "unknown" === this.consentState && await this.allow(), Ue.fromV2Message(n, e, a, i, s, this, this.client.address);
    }
    async createMessage(e, t, s) {
        const r = {
            topic: this.topic,
            createdNs: me(s || new Date)
        }, n = (0, _proto.message).MessageHeaderV2.encode(r).finish(), i = await _(pe(n, e)), c = {
            payload: e,
            sender: this.client.signedPublicKeyBundle,
            signature: await this.client.keystore.signDigest({
                digest: i,
                prekeyIndex: 0,
                identityKey: void 0
            })
        }, d = (0, _proto.content).SignedContent.encode(c).finish(), { encrypted: h, senderHmac: y } = await this.encryptMessage(d, n), u = {
            v1: void 0,
            v2: {
                headerBytes: n,
                ciphertext: h,
                senderHmac: y,
                shouldPush: t
            }
        }, l = (0, _proto.message).Message.encode(u).finish();
        return Ve.create(u, r, l, y, t);
    }
    async decryptBatch(e, t = !1) {
        const s = (await this.client.keystore.decryptV2(this.buildDecryptRequest(e))).responses, r = [];
        for(let n = 0; n < s.length; n++){
            const i = s[n], a = e[n];
            try {
                const { decrypted: e } = Ke(i);
                r.push(await this.buildDecodedMessage(a, e));
            } catch (e) {
                if (t) throw e;
                console.warn("Error decoding content", e);
            }
        }
        return r;
    }
    buildDecryptRequest(e) {
        return {
            requests: e.map((e)=>({
                    payload: e.ciphertext,
                    headerBytes: e.headerBytes,
                    contentTopic: this.topic
                }))
        };
    }
    async encryptMessage(e, t) {
        const { responses: s } = await this.client.keystore.encryptV2({
            requests: [
                {
                    payload: e,
                    headerBytes: t,
                    contentTopic: this.topic
                }
            ]
        });
        if (1 !== s.length) throw new Error("Invalid response length");
        const { encrypted: r, senderHmac: n } = Ke(s[0]);
        return {
            encrypted: r,
            senderHmac: n
        };
    }
    async buildDecodedMessage(e, t) {
        const s = (0, _proto.content).SignedContent.decode(t);
        if (!s.sender?.identityKey || !s.sender?.preKey || !s.signature) throw new Error("incomplete signed content");
        await async function(e) {
            const t = e.sender?.preKey;
            if (!t || !t.signature || !t.keyBytes) throw new Error("missing pre-key or pre-key signature");
            const s = e.sender?.identityKey;
            if (!s) throw new Error("missing identity key in bundle");
            if (!await new ae(s).verifyKey(new ae(t))) throw new Error("pre key not signed by identity key");
        }(s);
        const r = await _(pe(e.headerBytes, s.payload));
        if (!new ae(s.sender?.preKey).verify(new te(s.signature), r)) throw new Error("invalid signature");
        const n = await new ce(s.sender).walletSignatureAddress(), { content: i, contentType: a, error: c, contentFallback: d } = await this.client.decodeContent(s.payload);
        return Ue.fromV2Message(e, i, a, this.topic, s.payload, this, n, c, d);
    }
    async prepareMessage(e, t) {
        const { payload: s, shouldPush: r } = await this.client.encodeContent(e, t), n = await this.createMessage(s, r, t?.timestamp), i = n.toBytes(), a = t?.ephemeral ? this.ephemeralTopic : this.topic, o = {
            contentTopic: a,
            message: i,
            timestampNs: ve(n.sent)
        };
        return new he(o, async ()=>(await this.client.publishEnvelopes([
                {
                    contentTopic: a,
                    message: i,
                    timestamp: n.sent
                }
            ]), Ue.fromV2Message(n, e, t?.contentType || (0, _contentTypeText.ContentTypeText), a, s, this, this.client.address)));
    }
    async processEnvelope(e) {
        if (!e.message || !e.contentTopic) throw new Error("empty envelope");
        const t = (0, _proto.message).Message.decode(e.message);
        if (!t.v2) throw new Error("unknown message version");
        const s = (0, _proto.message).MessageHeaderV2.decode(t.v2.headerBytes);
        if (s.topic !== this.topic) throw new Error("topic mismatch");
        return Ve.create(t, s, e.message, t.v2.senderHmac, t.v2.shouldPush);
    }
    async decodeMessage(e) {
        if (!e.contentTopic) throw new Error("Missing content topic");
        const t = await this.processEnvelope(e), s = await this.decryptBatch([
            t
        ], !0);
        if (!s.length) throw new Error("No results");
        return s[0];
    }
}
const Me = (e)=>{
    if (e.v1?.ciphertext) return [
        e.v1.headerBytes,
        new N(e.v1.ciphertext)
    ];
    if (e.v2?.ciphertext) return [
        e.v2.headerBytes,
        new N(e.v2.ciphertext)
    ];
    throw new Error("unknown message version");
};
class xe {
    constructor(e, t, s){
        [this.headerBytes, this.ciphertext] = Me(s), this.id = e, this.bytes = t;
    }
    toBytes() {
        return this.bytes;
    }
}
class _e extends xe {
    constructor(e, t, s, r, n){
        super(e, t, s), this.conversation = void 0, this.senderAddress = n, this.header = r;
    }
    static async create(e, t, s) {
        if (!t.sender) throw new Error("missing message sender");
        const r = new de(t.sender).walletSignatureAddress(), n = j(await _(s));
        return new _e(n, s, e, t, r);
    }
    get sent() {
        return new Date(this.header.timestamp.toNumber());
    }
    get recipientAddress() {
        if (this.header?.recipient?.identityKey) return new oe(this.header.recipient.identityKey).walletSignatureAddress();
    }
    async decrypt(e, t) {
        const s = (await e.decryptV1(ke([
            this
        ], t))).responses;
        if (!s.length) throw new Error("No response from Keystore");
        const { decrypted: r } = Ke(s[0]);
        return r;
    }
    static fromBytes(e) {
        const t = (0, _proto.message).Message.decode(e), [s] = Me(t), r = (0, _proto.message).MessageHeaderV1.decode(s);
        if (!r) throw new Error("missing message header");
        if (!r.sender) throw new Error("missing message sender");
        if (!r.sender.identityKey) throw new Error("missing message sender identity key");
        if (!r.sender.preKey) throw new Error("missing message sender pre-key");
        if (!r.recipient) throw new Error("missing message recipient");
        if (!r.recipient.identityKey) throw new Error("missing message recipient identity-key");
        if (!r.recipient.preKey) throw new Error("missing message recipient pre-key");
        return _e.create(t, r, e);
    }
    static async encode(e, t, s, r, n) {
        const i = {
            sender: s,
            recipient: r,
            timestamp: (0, _longDefault.default).fromNumber(n.getTime())
        }, o = (0, _proto.message).MessageHeaderV1.encode(i).finish(), c = await e.encryptV1({
            requests: [
                {
                    recipient: r,
                    headerBytes: o,
                    payload: t
                }
            ]
        });
        if (!c.responses.length) throw new Error("No response from Keystore");
        const { encrypted: d } = Ke(c.responses[0]), h = {
            v1: {
                headerBytes: o,
                ciphertext: d
            },
            v2: void 0
        }, y = (0, _proto.message).Message.encode(h).finish();
        return _e.create(h, i, y);
    }
}
class Ve extends xe {
    constructor(e, t, s, r, n, i){
        super(e, t, s), this.header = r, this.senderHmac = n, this.shouldPush = i;
    }
    static async create(e, t, s, r, n) {
        const i = j(await _(s));
        return new Ve(i, s, e, t, r, n);
    }
    get sent() {
        return ge(this.header.createdNs);
    }
}
class Ue {
    constructor({ id: e, messageVersion: t, senderAddress: s, recipientAddress: r, conversation: n, contentBytes: i, contentType: a, contentTopic: o, content: c, sent: d, error: h, contentFallback: y }){
        this.id = e, this.messageVersion = t, this.senderAddress = s, this.recipientAddress = r, this.conversation = n, this.contentType = a, this.sent = d, this.error = h, this.content = c, this.contentTopic = o, this.contentBytes = i, this.contentFallback = y;
    }
    toBytes() {
        return (0, _proto.message).DecodedMessage.encode({
            ...this,
            conversation: {
                topic: this.conversation.topic,
                context: this.conversation.context ?? void 0,
                createdNs: me(this.conversation.createdAt),
                peerAddress: this.conversation.peerAddress,
                consentProofPayload: this.conversation.consentProof ?? void 0
            },
            sentNs: me(this.sent)
        }).finish();
    }
    static async fromBytes(e, t) {
        const s = (0, _proto.message).DecodedMessage.decode(e), r = s.messageVersion;
        if ("v1" !== r && "v2" !== r) throw new Error("Invalid message version");
        if (!s.conversation) throw new Error("No conversation reference found");
        const { content: n, contentType: i, error: o, contentFallback: c } = await t.decodeContent(s.contentBytes);
        return new Ue({
            ...s,
            content: n,
            contentType: i,
            error: o,
            messageVersion: r,
            sent: ge(s.sentNs),
            conversation: Oe(s.conversation, t, r),
            contentFallback: c
        });
    }
    static fromV1Message(e, t, s, r, n, i, a, o) {
        const { id: c, senderAddress: d, recipientAddress: h, sent: y } = e;
        if (!d) throw new Error("Sender address is required");
        return new Ue({
            id: c,
            messageVersion: "v1",
            senderAddress: d,
            recipientAddress: h,
            sent: y,
            content: t,
            contentBytes: r,
            contentType: s,
            contentTopic: n,
            conversation: i,
            error: a,
            contentFallback: o
        });
    }
    static fromV2Message(e, t, s, r, n, i, a, o, c) {
        const { id: d, sent: h } = e;
        return new Ue({
            id: d,
            messageVersion: "v2",
            senderAddress: a,
            sent: h,
            content: t,
            contentBytes: n,
            contentType: s,
            contentTopic: r,
            conversation: i,
            error: o,
            contentFallback: c
        });
    }
}
function Oe(e, t, s) {
    if ("v1" === s) return new Ne(t, e.peerAddress, ge(e.createdNs));
    if ("v2" === s) return new De(t, e.topic, e.peerAddress, ge(e.createdNs), e.context, e.consentProofPayload);
    throw new Error(`Unknown conversation version ${s}`);
}
function qe(e, t) {
    return t.decodeContent(e);
}
class Le extends Error {
    constructor(e){
        super(`no pre-key matches: ${j(e.secp256k1Uncompressed.bytes)}`);
    }
}
class Ge {
    constructor(e){
        if (this.version = 2, !e.identityKey) throw new Error("missing identity key");
        this.identityKey = new W(e.identityKey), this.preKeys = (e.preKeys || []).map((e)=>new W(e));
    }
    static async generate(e) {
        const t = await W.generate(new re(e)), s = new Ge({
            identityKey: t,
            preKeys: []
        });
        return await s.addPreKey(), s;
    }
    getCurrentPreKey() {
        return this.preKeys[0];
    }
    findPreKey(e) {
        const t = this.preKeys.find((t)=>t.matches(e));
        if (!t) throw new Le(e);
        return t;
    }
    async addPreKey() {
        this._publicKeyBundle = void 0;
        const e = await W.generate(this.identityKey);
        this.preKeys.unshift(e);
    }
    getPublicKeyBundle() {
        return this._publicKeyBundle || (this._publicKeyBundle = new ce({
            identityKey: this.identityKey.publicKey,
            preKey: this.getCurrentPreKey().publicKey
        })), this._publicKeyBundle;
    }
    async sharedSecret(e, t, s) {
        if (!e.identityKey || !e.preKey) throw new Error("invalid peer key bundle");
        if (!await e.identityKey.verifyKey(e.preKey)) throw new Error("peer preKey signature invalid");
        if (!this.identityKey) throw new Error("missing identity key");
        let r, n, i;
        s ? (i = this.findPreKey(t), r = i.sharedSecret(e.identityKey), n = this.identityKey.sharedSecret(e.preKey)) : (i = this.findPreKey(t), r = this.identityKey.sharedSecret(e.preKey), n = i.sharedSecret(e.identityKey));
        const a = i.sharedSecret(e.preKey), o = new Uint8Array(r.length + n.length + a.length);
        return o.set(r, 0), o.set(n, r.length), o.set(a, r.length + n.length), o;
    }
    encode() {
        return (0, _proto.privateKey).PrivateKeyBundle.encode({
            v1: void 0,
            v2: this
        }).finish();
    }
    validatePublicKeys() {
        return !!this.identityKey.validatePublicKey() && this.preKeys.every((e)=>e.validatePublicKey());
    }
    equals(e) {
        if (this.preKeys.length !== e.preKeys.length) return !1;
        for(let t = 0; t < this.preKeys.length; t++)if (!this.preKeys[t].equals(e.preKeys[t])) return !1;
        return this.identityKey.equals(e.identityKey);
    }
    static fromLegacyBundle(e) {
        return new Ge({
            identityKey: W.fromLegacyKey(e.identityKey, !0),
            preKeys: e.preKeys.map((e)=>W.fromLegacyKey(e))
        });
    }
}
class He {
    constructor(e){
        if (this.version = 1, !e.identityKey) throw new Error("missing identity key");
        this.identityKey = new Y(e.identityKey), this.preKeys = (e.preKeys || []).map((e)=>new Y(e));
    }
    static async generate(e) {
        const t = Y.generate();
        e && await t.publicKey.signWithWallet(e);
        const s = new He({
            identityKey: t,
            preKeys: []
        });
        return await s.addPreKey(), s;
    }
    getCurrentPreKey() {
        return this.preKeys[0];
    }
    findPreKey(e) {
        const t = this.preKeys.find((t)=>t.matches(e));
        if (!t) throw new Le(e);
        return t;
    }
    async addPreKey() {
        this._publicKeyBundle = void 0;
        const e = Y.generate();
        await this.identityKey.signKey(e.publicKey), this.preKeys.unshift(e);
    }
    getPublicKeyBundle() {
        return this._publicKeyBundle || (this._publicKeyBundle = new de({
            identityKey: this.identityKey.publicKey,
            preKey: this.getCurrentPreKey().publicKey
        })), this._publicKeyBundle;
    }
    validatePublicKeys() {
        return !!this.identityKey.validatePublicKey() && this.preKeys.every((e)=>e.validatePublicKey());
    }
    async sharedSecret(e, t, s) {
        if (!e.identityKey || !e.preKey) throw new Error("invalid peer key bundle");
        if (!await e.identityKey.verifyKey(e.preKey)) throw new Error("peer preKey signature invalid");
        if (!this.identityKey) throw new Error("missing identity key");
        let r, n, i;
        s ? (i = this.findPreKey(t), r = i.sharedSecret(e.identityKey), n = this.identityKey.sharedSecret(e.preKey)) : (i = this.findPreKey(t), r = this.identityKey.sharedSecret(e.preKey), n = i.sharedSecret(e.identityKey));
        const a = i.sharedSecret(e.preKey), o = new Uint8Array(r.length + n.length + a.length);
        return o.set(r, 0), o.set(n, r.length), o.set(a, r.length + n.length), o;
    }
    encode() {
        return (0, _proto.privateKey).PrivateKeyBundle.encode({
            v1: this,
            v2: void 0
        }).finish();
    }
}
function Fe(e) {
    const s = (0, _proto.privateKey).PrivateKeyBundle.decode(e);
    if (s.v1) return new He(s.v1);
    if (s.v2) return new Ge(s.v2);
    throw new Error("unknown private key bundle version");
}
class $e {
    constructor({ walletAddr: e, createdNs: t }){
        this.walletAddr = e, this.createdNs = t;
    }
    static create(e, t) {
        return t = t || new Date, new $e({
            walletAddr: e,
            createdNs: me(t)
        });
    }
    static fromBytes(e) {
        const t = (0, _proto.authn).AuthData.decode(e);
        return new $e(t);
    }
    toBytes() {
        return (0, _proto.authn).AuthData.encode(this).finish();
    }
}
class je {
    constructor({ identityKey: e, authDataBytes: t, authDataSignature: s }){
        if (!e) throw new Error("Missing identity key in token");
        if (!s) throw new Error("Missing authDataSignature in token");
        this.identityKey = e, this.authDataBytes = t, this.authDataSignature = s;
    }
    get authData() {
        return this._authData || (this._authData = $e.fromBytes(this.authDataBytes)), this._authData;
    }
    get ageMs() {
        return (new Date).valueOf() - this.authData.createdNs.div(1e6).toNumber();
    }
    toBytes() {
        return (0, _proto.authn).Token.encode(this).finish();
    }
    static fromBytes(e) {
        return new je((0, _proto.authn).Token.decode(e));
    }
    toBase64() {
        return Buffer.from(this.toBytes()).toString("base64");
    }
}
class Xe {
    constructor(e){
        this.keystore = e;
    }
    async createToken(e) {
        return ((e)=>e instanceof je ? e : new je(e))(await this.keystore.createAuthToken({
            timestampNs: e ? me(e) : void 0
        }));
    }
}
const Je = (e)=>new Promise((t)=>setTimeout(t, e)), ze = (e)=>!!e;
async function We(e, t, s, r, n = ze, i = 1) {
    const a = "number" == typeof i ? i : 1;
    try {
        return await e(...t);
    } catch (i) {
        if (!n(i) || a > s) throw i;
        return await Je(r), We(e, t, s, r, n, a + 1);
    }
}
async function* Ye(e, t) {
    for await (const s of e){
        const e = await Promise.allSettled(s.map(t)), r = [];
        for (const t of e)"fulfilled" === t.status ? r.push(t.value) : console.warn("Failed to process envelope due to reason: ", t.reason);
        yield r;
    }
}
class Qe {
    constructor(e, t = 3590){
        this.authenticator = e, this.maxAgeMs = 1e3 * t;
    }
    async getToken() {
        return (!this.token || this.token.ageMs > this.maxAgeMs) && await this.refresh(), this.token.toBase64();
    }
    async refresh() {
        this.token = await this.authenticator.createToken();
    }
}
const { MessageApi: Ze, SortDirection: et } = (0, _proto.messageApi), tt = {
    local: "http://localhost:5555",
    dev: "https://dev.xmtp.network",
    production: "https://production.xmtp.network"
};
var st;
!function(e) {
    e[e.OK = 0] = "OK", e[e.CANCELLED = 1] = "CANCELLED", e[e.UNKNOWN = 2] = "UNKNOWN", e[e.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", e[e.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", e[e.NOT_FOUND = 5] = "NOT_FOUND", e[e.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", e[e.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", e[e.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", e[e.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", e[e.ABORTED = 10] = "ABORTED", e[e.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", e[e.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", e[e.INTERNAL = 13] = "INTERNAL", e[e.UNAVAILABLE = 14] = "UNAVAILABLE", e[e.DATA_LOSS = 15] = "DATA_LOSS", e[e.UNAUTHENTICATED = 16] = "UNAUTHENTICATED";
}(st || (st = {}));
class rt extends Error {
    constructor(e, t){
        super(e), this.code = t;
    }
    static fromObject(e) {
        return new rt(e.message, e.code);
    }
}
const nt = (e)=>!!e && !("AbortError" !== e.name && !e.message.includes("aborted")), it = (e)=>!((e)=>!(!e || !("code" in e) || 16 !== e.code))(e), at = (e)=>e.message && e.message.length ? ("string" == typeof e.message && (e.message = ue(e.message)), e) : e;
class ot {
    constructor(e, t){
        this.pathPrefix = e, this.maxRetries = t?.maxRetries || 5, this.appVersion = t?.appVersion, this.version = "xmtp-js/13.0.4", e === tt.dev && console.info("\nXX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV \n XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV \n  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  \n XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   \nXX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    \n\nConnected to the XMTP 'dev' network. Use 'production' for production messages.\nhttps://github.com/xmtp/xmtp-js#xmtp-production-and-dev-network-environments\n");
    }
    async _query(e) {
        try {
            return await We(Ze.Query, [
                e,
                {
                    pathPrefix: this.pathPrefix,
                    mode: "cors",
                    headers: this.headers()
                }
            ], this.maxRetries, 100);
        } catch (e) {
            throw rt.fromObject(e);
        }
    }
    _batchQuery(e) {
        return We(Ze.BatchQuery, [
            e,
            {
                pathPrefix: this.pathPrefix,
                mode: "cors",
                headers: this.headers()
            }
        ], this.maxRetries, 100);
    }
    async _publish(e, t = 0) {
        const s = await this.getToken(), r = this.headers();
        r.set("Authorization", `Bearer ${s}`);
        try {
            return await We(Ze.Publish, [
                e,
                {
                    pathPrefix: this.pathPrefix,
                    mode: "cors",
                    headers: r
                }
            ], this.maxRetries, 100, it);
        } catch (s) {
            if (it(s) || t >= 1) throw rt.fromObject(s);
            return await this.authCache?.refresh(), this._publish(e, t + 1);
        }
    }
    _subscribe(e, t, s) {
        const r = new AbortController;
        return (async ()=>{
            for(;;){
                const n = (new Date).getTime();
                try {
                    if (await Ze.Subscribe(e, t, {
                        pathPrefix: this.pathPrefix,
                        signal: r.signal,
                        mode: "cors",
                        headers: this.headers()
                    }), r.signal.aborted) return;
                    console.info("Stream connection closed. Resubscribing"), (new Date).getTime() - n < 1e3 && await Je(1e3), s?.();
                } catch (e) {
                    if (nt(e) || r.signal.aborted) return;
                    console.info("Stream connection closed. Resubscribing"), (new Date).getTime() - n < 1e3 && await Je(1e3), s?.();
                }
            }
        })(), {
            unsubscribe: async ()=>{
                r?.abort();
            }
        };
    }
    async query(e, { direction: t = et.SORT_DIRECTION_ASCENDING, limit: s, pageSize: r }) {
        const n = [], i = e.contentTopic.startsWith("userpreferences-") ? 500 : 100;
        for await (const a of this.queryIteratePages(e, {
            direction: t,
            pageSize: r ? Math.min(r, i) : i
        }))for (const e of a)if (n.push(e), s && n.length === s) return n;
        return n;
    }
    async *queryIterator(e, t) {
        for await (const s of this.queryIteratePages(e, t))for (const e of s)yield e;
    }
    async *queryIteratePages({ contentTopic: e, startTime: t, endTime: s }, { direction: r, pageSize: n = 10 }) {
        if (!e || !e.length) throw new Error("Must specify content topics");
        const i = ve(t), a = ve(s);
        let o;
        for(;;){
            const t = {
                limit: n,
                direction: r,
                cursor: o
            }, s = await this._query({
                contentTopics: [
                    e
                ],
                startTimeNs: i,
                endTimeNs: a,
                pagingInfo: t
            });
            if (!s.envelopes?.length) return;
            if (yield s.envelopes.map(at), !s.pagingInfo?.cursor) return;
            o = s.pagingInfo?.cursor;
        }
    }
    async batchQuery(e) {
        const t = [];
        for(let s = 0; s < e.length; s += 50){
            const r = e.slice(s, s + 50), n = [];
            for (const e of r)n.push({
                contentTopics: [
                    e.contentTopic
                ],
                startTimeNs: ve(e.startTime),
                endTimeNs: ve(e.endTime),
                pagingInfo: {
                    limit: e.pageSize || 10,
                    direction: e.direction || et.SORT_DIRECTION_ASCENDING
                }
            });
            const i = {
                requests: n
            };
            t.push(i);
        }
        const s = await Promise.all(t.map(async (e)=>this._batchQuery(e))), r = [];
        for (const e of s){
            if (!e.responses) throw new Error("BatchQueryResponse missing responses");
            for (const t of e.responses)t.envelopes ? r.push(t.envelopes.map(at)) : r.push([]);
        }
        return r;
    }
    async publish(e) {
        const t = [];
        for (const { contentTopic: s, message: r, timestamp: n } of e){
            if (!s.length) throw new Error("Content topic cannot be empty string");
            if (!r.length) throw new Error("0 length messages not allowed");
            const e = n || new Date;
            t.push({
                contentTopic: s,
                timestampNs: ve(e),
                message: Uint8Array.from(r)
            });
        }
        return this._publish({
            envelopes: t
        });
    }
    subscribe(e, t, s) {
        if (!e.contentTopics.length) throw new Error("Must provide list of contentTopics to subscribe to");
        return this._subscribe(e, (e)=>t(at(e)), s);
    }
    getToken() {
        if (!this.authCache) throw new Error("AuthCache is not set on API Client");
        return this.authCache.getToken();
    }
    setAuthenticator(e, t) {
        this.authCache = new Qe(e, t);
    }
    headers() {
        const e = new Headers;
        return e.set("X-Client-Version", this.version), this.appVersion && e.set("X-App-Version", this.appVersion), e;
    }
}
class ct {
    constructor(e, t){
        this.disableOffset = !1, this.jobType = e, this.mutex = new (0, _asyncMutex.Mutex), this.keystore = t;
    }
    get protoJobType() {
        return function(e) {
            const t = {
                v1: (0, _proto.keystore).JobType.JOB_TYPE_REFRESH_V1,
                v2: (0, _proto.keystore).JobType.JOB_TYPE_REFRESH_V2,
                "user-preferences": (0, _proto.keystore).JobType.JOB_TYPE_REFRESH_PPPP
            }[e];
            if (!t) throw new Error(`unknown job type: ${e}`);
            return t;
        }(this.jobType);
    }
    async run(e) {
        return this.mutex.runExclusive(async ()=>{
            const t = await this.getLastRunTime(), s = new Date, r = await e(t ? this.disableOffset ? t : new Date(t.getTime() - 1e4) : void 0);
            return await this.setLastRunTime(s), r;
        });
    }
    async resetLastRunTime() {
        await this.keystore.setRefreshJob({
            jobType: this.protoJobType,
            lastRunNs: me(new Date(0))
        });
    }
    async getLastRunTime() {
        const { lastRunNs: e } = await this.keystore.getRefreshJob((0, _proto.keystore).GetRefreshJobRequest.fromPartial({
            jobType: this.protoJobType
        }));
        if (!e.equals((0, _longDefault.default).fromNumber(0))) return ge(e);
    }
    async setLastRunTime(e) {
        await this.keystore.setRefreshJob({
            jobType: this.protoJobType,
            lastRunNs: me(e)
        });
    }
}
const dt = (e)=>Boolean(e.recipientAddress && e.senderAddress);
class ht {
    constructor(e){
        this.client = e, this.v1JobRunner = new ct("v1", e.keystore), this.v2JobRunner = new ct("v2", e.keystore);
    }
    async list() {
        const [e, t] = await Promise.all([
            this.listV1Conversations(),
            this.listV2Conversations()
        ]), s = e.concat(t);
        return s.sort((e, t)=>e.createdAt.getTime() - t.createdAt.getTime()), s;
    }
    async listFromCache() {
        const [e, t] = await Promise.all([
            this.getV1ConversationsFromKeystore(),
            this.getV2ConversationsFromKeystore()
        ]), s = e.concat(t);
        return s.sort((e, t)=>e.createdAt.getTime() - t.createdAt.getTime()), s;
    }
    async listV1Conversations() {
        return this.v1JobRunner.run(async (e)=>{
            const t = await this.getIntroductionPeers({
                startTime: e,
                direction: et.SORT_DIRECTION_ASCENDING
            });
            return await this.client.keystore.saveV1Conversations({
                conversations: Array.from(t).map(([e, t])=>({
                        peerAddress: e,
                        createdNs: me(t),
                        topic: Se(e, this.client.address),
                        context: void 0,
                        consentProofPayload: void 0
                    })).filter((e)=>Re(e.topic))
            }), (await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this));
        });
    }
    async listV2Conversations() {
        return this.v2JobRunner.run(async (e)=>{
            const t = await this.getV2ConversationsFromKeystore(), s = await this.updateV2Conversations(e), r = new Set(t.map((e)=>e.topic));
            for (const e of s)r.has(e.topic) || (t.push(e), r.add(e.topic));
            return t.sort((e, t)=>e.createdAt.getTime() - t.createdAt.getTime()), t;
        });
    }
    async getV2ConversationsFromKeystore() {
        return (await this.client.keystore.getV2Conversations()).conversations.map(this.conversationReferenceToV2.bind(this));
    }
    async getV1ConversationsFromKeystore() {
        return (await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this));
    }
    async updateV2Conversations(e) {
        const t = await this.client.listInvitations({
            startTime: e,
            direction: et.SORT_DIRECTION_ASCENDING
        });
        return this.decodeInvites(t);
    }
    async decodeInvites(e, t = !1) {
        const { responses: s } = await this.client.keystore.saveInvites({
            requests: e.map((e)=>({
                    payload: e.message,
                    timestampNs: (0, _longDefault.default).fromString(e.timestampNs),
                    contentTopic: e.contentTopic
                })).filter((e)=>Re(e.contentTopic))
        }), r = [];
        for (const e of s)try {
            r.push(this.saveInviteResponseToConversation(e));
        } catch (e) {
            if (console.warn("Error saving invite response to conversation: ", e), t) throw e;
        }
        return r;
    }
    saveInviteResponseToConversation({ result: e, error: t }) {
        if (t || !e || !e.conversation) throw new Error(`Error from keystore: ${t?.code} ${t?.message}}`);
        return this.conversationReferenceToV2(e.conversation);
    }
    conversationReferenceToV2(e) {
        return new De(this.client, e.topic, e.peerAddress, ge(e.createdNs), e.context, e.consentProofPayload);
    }
    conversationReferenceToV1(e) {
        return new Ne(this.client, e.peerAddress, ge(e.createdNs));
    }
    async stream(e) {
        const t = new Set, s = Ce(this.client.address), r = Ie(this.client.address), n = [
            s,
            r
        ];
        return ye.create(this.client, n, (async (e)=>{
            if (e.contentTopic === s) {
                if (!e.message) throw new Error("empty envelope");
                const s = await _e.fromBytes(e.message), r = this.getPeerAddress(s);
                if (!((e)=>!t.has(e) && (t.add(e), !0))(r)) return;
                return await s.decrypt(this.client.keystore, this.client.publicKeyBundle), new Ne(this.client, r, s.sent);
            }
            if (e.contentTopic === r) {
                const t = await this.decodeInvites([
                    e
                ], !0);
                if (t.length) return t[0];
            }
            throw new Error("unrecognized invite topic");
        }).bind(this), void 0, e);
    }
    async streamAllMessages(e) {
        const t = Ce(this.client.address), s = Ie(this.client.address), r = new Set([
            t,
            s
        ]), n = new Map;
        for (const e of (await this.list()))r.add(e.topic), n.set(e.topic, e);
        const i = (e, t)=>!r.has(e) && (n.set(e, t), r.add(e), !0), a = await ye.create(this.client, Array.from(r.values()), async (e)=>{
            const r = e.contentTopic;
            if (!r || !e.message) return null;
            if (r === t) {
                const t = await _e.fromBytes(e.message);
                if (!dt(t)) return null;
                const s = this.getPeerAddress(t);
                return new Ne(this.client, s, t.sent).decodeMessage(e);
            }
            if (r === s) return (await this.decodeInvites([
                e
            ], !0))[0];
            const i = n.get(r);
            if (i instanceof Ne) return i.decodeMessage(e);
            if (i instanceof De) return i.decodeMessage(e);
            throw console.log("Unknown topic"), new Error("Unknown topic");
        }, (e)=>{
            if (e instanceof Ue && e.contentTopic === t) {
                const t = new Ne(this.client, e.recipientAddress?.toLowerCase() === this.client.address.toLowerCase() ? e.senderAddress : e.recipientAddress, e.sent);
                return i(t.topic, t) ? Array.from(r.values()) : void 0;
            }
            if (e instanceof De) return i(e.topic, e) ? Array.from(r.values()) : void 0;
        }, e), o = async function*() {
            for await (const e of a)if (e instanceof Ue && (yield e), e instanceof De) for (const t of (await e.messages()))yield t;
        }();
        return o.return = async ()=>(await a?.return(), {
                value: void 0,
                done: !0
            }), o;
    }
    async getIntroductionPeers(e) {
        const t = Ce(this.client.address), s = await this.client.listEnvelopes(t, (e)=>{
            if (!e.message) throw new Error("empty envelope");
            return _e.fromBytes(e.message);
        }, e), r = new Map;
        for (const e of s){
            if (!dt(e)) continue;
            const t = this.getPeerAddress(e);
            if (t) {
                const s = r.get(t);
                if (!s || s > e.sent) try {
                    await e.decrypt(this.client.keystore, this.client.publicKeyBundle), r.set(t, e.sent);
                } catch (e) {
                    continue;
                }
            }
        }
        return r;
    }
    async newConversation(e, t, s) {
        const r = (s)=>{
            var r, n;
            return s.peerAddress.toLowerCase() === e.toLowerCase() && (r = t, n = s.context ?? void 0, r?.conversationId === n?.conversationId);
        }, n = (await this.getV2ConversationsFromKeystore()).find(r);
        if (n) return n;
        let i = await this.client.getUserContact(e);
        if (!i) throw new Error(`Recipient ${e} is not on the XMTP network`);
        if (e.toLowerCase() === this.client.address.toLowerCase()) throw new Error("self messaging not supported");
        if (i instanceof de && !t?.conversationId) return new Ne(this.client, e, new Date);
        if (!t?.conversationId) {
            const t = (await this.listV1Conversations()).find((t)=>t.peerAddress.toLowerCase() === e.toLowerCase());
            if (t) {
                if (!this.client.signedPublicKeyBundle.isFromLegacyBundle()) throw new Error("cannot resume pre-existing V1 conversation; client keys not compatible");
                if (!(i instanceof de || i.isFromLegacyBundle())) throw new Error("cannot resume pre-existing V1 conversation; peer keys not compatible");
                return t;
            }
        }
        return i instanceof de && (i = ce.fromLegacyBundle(i)), this.v2JobRunner.run(async (e)=>{
            const n = (await this.updateV2Conversations(e)).find(r);
            return n || this.createV2Convo(i, t, s);
        });
    }
    async createV2Convo(e, t, s) {
        const r = new Date, { payload: n, conversation: i } = await this.client.keystore.createInvite({
            recipient: e,
            context: t,
            createdNs: me(r),
            consentProof: s
        });
        if (!n || !i) throw new Error("Required field not returned from Keystore");
        const a = await e.walletSignatureAddress();
        return await this.client.publishEnvelopes([
            {
                contentTopic: Ie(a),
                message: n,
                timestamp: r
            },
            {
                contentTopic: Ie(this.client.address),
                message: n,
                timestamp: r
            }
        ]), await this.client.contacts.allow([
            a
        ]), this.conversationReferenceToV2(i);
    }
    getPeerAddress(e) {
        return e.recipientAddress?.toLowerCase() === this.client.address.toLowerCase() ? e.senderAddress : e.recipientAddress;
    }
}
class yt {
    constructor(e){
        this.storage = e;
    }
    static create() {
        if ("undefined" == typeof localStorage) throw new Error("Missing LocalStorage. Use ephemeralPersistence instead");
        return new yt(localStorage);
    }
    async getItem(e) {
        const t = this.storage.getItem(e);
        return null === t ? null : Uint8Array.from(Buffer.from(t, "binary"));
    }
    async setItem(e, t) {
        this.storage.setItem(e, Buffer.from(t).toString("binary"));
    }
}
class ut {
    constructor(){
        this.store = new Map;
    }
    get length() {
        return this.store.size;
    }
    clear() {
        this.store = new Map;
    }
    getItem(e) {
        return this.validateString(e), this.store.has(e) ? String(this.store.get(e)) : null;
    }
    key(e) {
        if (void 0 === e) throw new TypeError("Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.");
        const t = [
            ...this.store.keys()
        ];
        return e >= t.length ? null : t[e];
    }
    removeItem(e) {
        this.validateString(e), this.store.delete(e);
    }
    setItem(e, t) {
        this.validateString(e), this.validateString(t), this.store.set(String(e), String(t));
    }
    validateString(e) {
        if ("string" != typeof e) throw new TypeError("Key must be a string");
    }
}
class lt extends yt {
    static create() {
        return new yt(new ut);
    }
}
class pt extends Error {
}
function wt(e, t, s, r) {
    if ("a" === s && !r) throw new TypeError("Private accessor was defined without a getter");
    if ("function" == typeof t ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return "m" === s ? r : "a" === s ? r.call(e) : r ? r.value : t.get(e);
}
function ft(e, t, s, r, n) {
    if ("m" === r) throw new TypeError("Private method is not writable");
    if ("a" === r && !n) throw new TypeError("Private accessor was defined without a setter");
    if ("function" == typeof t ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return "a" === r ? n.call(e, s) : n ? n.value = s : t.set(e, s), s;
}
"function" == typeof SuppressedError && SuppressedError;
class mt {
    constructor(e){
        if (!e.publicKey.signature) throw new Error("Provided public key is not signed");
        this.identityKey = e;
    }
    async createToken(e) {
        const t = $e.create(this.identityKey.publicKey.walletSignatureAddress(), e || new Date).toBytes(), n = (0, _viem.keccak256)(t), i = await this.identityKey.sign((0, _viem.hexToBytes)(n));
        return new je((0, _proto.authn).Token.fromPartial({
            identityKey: (0, _proto.publicKey).PublicKey.fromPartial(this.identityKey.publicKey),
            authDataBytes: t,
            authDataSignature: (0, _proto.signature).Signature.fromPartial(i)
        }));
    }
}
const gt = new (0, _ellipticDefault.default).ec("secp256k1"), vt = D.subtle, bt = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex"), Et = Buffer.alloc(32, 0);
function Kt(e, t) {
    if (!e) throw new Error(t || "Assertion failed");
}
function kt(e) {
    var t;
    return t = e, !(!Buffer.isBuffer(t) || 32 !== t.length) && e.compare(Et) > 0 && e.compare(bt) < 0;
}
function Pt(e) {
    const t = new Uint8Array(e);
    return D.getRandomValues(t), Buffer.from(t);
}
async function St(e) {
    const t = await vt.digest("SHA-512", e);
    return Buffer.from(t);
}
function At(e) {
    return function(t, s, r) {
        return new Promise(function(n) {
            return vt.importKey("raw", s, {
                name: "AES-CBC"
            }, !1, [
                e
            ]).then(function(s) {
                const n = {
                    name: "AES-CBC",
                    iv: t
                };
                return vt[e](n, s, r);
            }).then(function(e) {
                n(Buffer.from(new Uint8Array(e)));
            });
        });
    };
}
const Tt = At("encrypt"), Ct = At("decrypt");
async function It(e, t) {
    const s = await vt.importKey("raw", e, {
        name: "HMAC",
        hash: {
            name: "SHA-256"
        }
    }, !1, [
        "sign"
    ]);
    return Buffer.from(await vt.sign({
        name: "HMAC",
        hash: "SHA-256"
    }, s, t));
}
function Bt(e) {
    return Kt(32 === e.length, "Bad private key"), Kt(kt(e), "Bad private key"), Buffer.from(gt.keyFromPrivate(e).getPublic("array"));
}
function Rt(e, t) {
    return new Promise(function(s) {
        Kt(Buffer.isBuffer(e), "Bad private key"), Kt(Buffer.isBuffer(t), "Bad public key"), Kt(32 === e.length, "Bad private key"), Kt(kt(e), "Bad private key"), Kt(65 === t.length || 33 === t.length, "Bad public key"), 65 === t.length && Kt(4 === t[0], "Bad public key"), 33 === t.length && Kt(2 === t[0] || 3 === t[0], "Bad public key");
        const r = gt.keyFromPrivate(e), n = gt.keyFromPublic(t), i = r.derive(n.getPublic());
        s(Buffer.from(i.toArray()));
    });
}
async function Nt(e, t) {
    const s = await Rt(e, t.ephemeralPublicKey), r = await St(s), n = r.slice(0, 32), i = r.slice(32), a = Buffer.concat([
        t.iv,
        t.ephemeralPublicKey,
        t.ciphertext
    ]);
    return Kt(await async function(e, t, s) {
        return function(e, t) {
            if (e.length !== t.length) return !1;
            let s = 0;
            for(let r = 0; r < e.length; r++)s |= e[r] ^ t[r];
            return 0 === s;
        }(await It(e, t), s);
    }(i, a, t.mac), "Bad mac"), Ct(t.iv, n, t.ciphertext);
}
async function Dt(e, t) {
    await (0, _webDefault.default)();
    const s = e.publicKey.secp256k1Uncompressed.bytes, r = e.secp256k1.bytes;
    return (0, _web.user_preferences_encrypt)(s, r, t);
}
async function Mt(e, t) {
    await (0, _webDefault.default)();
    const s = e.publicKey.secp256k1Uncompressed.bytes, r = e.secp256k1.bytes;
    return (0, _web.user_preferences_decrypt)(s, r, t);
}
class xt {
    constructor({ topic: e, context: t, aes256GcmHkdfSha256: s, consentProof: r }){
        if (!e || !e.length) throw new Error("Missing topic");
        if (!s || !s.keyMaterial || !s.keyMaterial.length) throw new Error("Missing key material");
        this.topic = e, this.context = t, this.aes256GcmHkdfSha256 = s, this.consentProof = r;
    }
    static createRandom(e, t) {
        const s = Ae(Buffer.from(D.getRandomValues(new Uint8Array(32))).toString("base64").replace(/=*$/g, "").replace(/\//g, "-")), r = D.getRandomValues(new Uint8Array(32));
        return new xt({
            topic: s,
            aes256GcmHkdfSha256: {
                keyMaterial: r
            },
            context: e,
            consentProof: t
        });
    }
    toBytes() {
        return (0, _proto.invitation).InvitationV1.encode(this).finish();
    }
    static fromBytes(e) {
        return new xt((0, _proto.invitation).InvitationV1.decode(e));
    }
}
class _t {
    constructor({ sender: e, recipient: t, createdNs: s }){
        if (!e) throw new Error("Missing sender");
        if (!t) throw new Error("Missing recipient");
        this.sender = new ce(e), this.recipient = new ce(t), this.createdNs = s;
    }
    toBytes() {
        return (0, _proto.invitation).SealedInvitationHeaderV1.encode(this).finish();
    }
    static fromBytes(e) {
        return new _t((0, _proto.invitation).SealedInvitationHeaderV1.decode(e));
    }
}
class Vt {
    constructor({ headerBytes: e, ciphertext: t }){
        if (!e || !e.length) throw new Error("Missing header bytes");
        if (!t) throw new Error("Missing ciphertext");
        this.headerBytes = e, this.ciphertext = new N(t);
    }
    get header() {
        return this._header || (this._header = _t.fromBytes(this.headerBytes)), this._header;
    }
    async getInvitation(e) {
        if (this._invitation) return this._invitation;
        const t = this.header;
        let s;
        s = e.identityKey.matches(this.header.sender.identityKey) ? await e.sharedSecret(t.recipient, t.sender.preKey, !1) : await e.sharedSecret(t.sender, t.recipient.preKey, !0);
        const r = await U(this.ciphertext, s, this.headerBytes);
        return this._invitation = xt.fromBytes(r), this._invitation;
    }
    toBytes() {
        return (0, _proto.invitation).SealedInvitationV1.encode(this).finish();
    }
    static fromBytes(e) {
        return new Vt((0, _proto.invitation).SealedInvitationV1.decode(e));
    }
}
class Ut {
    constructor({ v1: e }){
        if (!e) throw new Error("Missing v1 or v2 invitation");
        this.v1 = new Vt(e);
    }
    toBytes() {
        return (0, _proto.invitation).SealedInvitation.encode(this).finish();
    }
    static fromBytes(e) {
        return new Ut((0, _proto.invitation).SealedInvitation.decode(e));
    }
    static async fromEnvelope(e) {
        if (!e.message || !e.timestampNs) throw new Error("invalid invitation envelope");
        const t = Ut.fromBytes(e.message), s = (0, _longDefault.default).fromString(e.timestampNs), r = t.v1?.header.createdNs;
        if (!r || !r.equals(s)) throw new Error("envelope and header timestamp mistmatch");
        return t;
    }
    static async createV1({ sender: e, recipient: t, created: s, invitation: r }) {
        const n = new _t({
            sender: e.getPublicKeyBundle(),
            recipient: t,
            createdNs: me(s)
        }).toBytes(), i = await e.sharedSecret(t, e.getCurrentPreKey().publicKey, !1), a = r.toBytes(), o = await V(a, i, n);
        return new Ut({
            v1: {
                headerBytes: n,
                ciphertext: o
            }
        });
    }
}
var Ot, qt, Lt, Gt, Ht, Ft;
class $t {
    constructor(e, t, s = new Map){
        Ot.add(this), qt.set(this, void 0), Lt.set(this, void 0), Gt.set(this, void 0), Ht.set(this, void 0), ft(this, Lt, t, "f"), ft(this, qt, e, "f"), ft(this, Ht, 0, "f"), ft(this, Gt, new (0, _asyncMutex.Mutex), "f"), this.actionsMap = s;
    }
    get revisionKey() {
        return wt(this, Lt, "f") + "/revision";
    }
    static async create(e) {
        const t = new $t(e, "private-preferences/actions");
        return await t.refresh(), t;
    }
    async refresh() {
        const e = await this.getRevision();
        e > wt(this, Ht, "f") && (this.actionsMap = await this.loadFromPersistence()), ft(this, Ht, e, "f");
    }
    async getRevision() {
        const e = await wt(this, qt, "f").getItem(this.revisionKey);
        return e ? fe(e) : 0;
    }
    async setRevision(e) {
        await wt(this, qt, "f").setItem(this.revisionKey, we(e));
    }
    async loadFromPersistence() {
        const e = await wt(this, qt, "f").getItem(wt(this, Lt, "f"));
        if (!e) return new Map;
        const t = (0, _proto.keystore).PrivatePreferencesActionMap.decode(e), s = new Map, r = Object.entries(t.actions);
        for(let e = 0; e < r.length; e++)s.set(r[e][0], r[e][1]);
        return s;
    }
    async store() {
        var e;
        await wt(this, qt, "f").setItem(wt(this, Lt, "f"), wt(this, Ot, "m", Ft).call(this)), ft(this, Ht, (e = wt(this, Ht, "f"), ++e), "f"), await this.setRevision(wt(this, Ht, "f"));
    }
    async add(e) {
        await wt(this, Gt, "f").runExclusive(async ()=>{
            await this.refresh();
            let t = !1;
            const s = Array.from(e.keys());
            for(let r = 0; r < s.length; r++)this.actionsMap.has(s[r]) || (this.actionsMap.set(s[r], e.get(s[r])), t = !0);
            t && await this.store();
        });
    }
    get actions() {
        return new Map([
            ...this.actionsMap.entries()
        ].sort((e, t)=>be(e[0]).getTime() - be(t[0]).getTime()));
    }
    lookup(e) {
        return this.actionsMap.get(e);
    }
}
qt = new WeakMap, Lt = new WeakMap, Gt = new WeakMap, Ht = new WeakMap, Ot = new WeakSet, Ft = function() {
    return (0, _proto.keystore).PrivatePreferencesActionMap.encode({
        actions: Object.fromEntries(this.actionsMap)
    }).finish();
};
const jt = (e, t)=>e instanceof Ee ? e : new Ee(t, e.message), Xt = (e, t, s)=>Promise.all(e.map(async (e)=>{
        try {
            return {
                result: await t(e)
            };
        } catch (e) {
            return {
                error: jt(e, s)
            };
        }
    })), Jt = (e)=>e instanceof de ? e : new de(e), zt = (e, t, s)=>{
    for (const s of t)if (!e[s]) throw new Ee((0, _proto.keystore).ErrorCode.ERROR_CODE_INVALID_INPUT, `Missing field ${String(s)}`);
    for (const t of s){
        const s = e[t];
        if (!s || !s?.length) throw new Ee((0, _proto.keystore).ErrorCode.ERROR_CODE_INVALID_INPUT, `Missing field ${String(t)}`);
    }
    return !0;
}, Wt = (e)=>{
    if (!e?.aes256GcmHkdfSha256?.keyMaterial) throw new Ee((0, _proto.keystore).ErrorCode.ERROR_CODE_INVALID_INPUT, "Missing key material");
    return e.aes256GcmHkdfSha256.keyMaterial;
}, Yt = ({ invitation: e, createdNs: t, peerAddress: s })=>({
        context: e.context,
        topic: e.topic,
        peerAddress: s,
        createdNs: t,
        consentProofPayload: e.consentProof
    });
class Qt {
    constructor(e, t, s = new Map){
        this.persistenceKey = t, this.persistence = e, this.revision = 0, this.mutex = new (0, _asyncMutex.Mutex), this.topicMap = s;
    }
    get revisionKey() {
        return this.persistenceKey + "/revision";
    }
    static async create(e) {
        const t = new Qt(e, "invitations/v1");
        return await t.refresh(), t;
    }
    validate(e) {
        return !!e.topic && e.topic.length > 0 && !!e.invitation;
    }
    async refresh() {
        const e = await this.getRevision();
        if (e > this.revision) for (const [e, t] of (await this.loadFromPersistence()))this.topicMap.set(e, t);
        this.revision = e;
    }
    async getRevision() {
        const e = await this.persistence.getItem(this.revisionKey);
        return e ? fe(e) : 0;
    }
    async setRevision(e) {
        await this.persistence.setItem(this.revisionKey, we(e));
    }
    async loadFromPersistence() {
        const e = await this.persistence.getItem(this.persistenceKey);
        return e ? ((e)=>{
            const t = new Map;
            for (const [s, r] of Object.entries(e.topics))t.set(s, r);
            return t;
        })((0, _proto.keystore).TopicMap.decode(e)) : new Map;
    }
    async store() {
        await this.persistence.setItem(this.persistenceKey, this.toBytes()), this.revision++, await this.setRevision(this.revision);
    }
    async add(e) {
        await this.mutex.runExclusive(async ()=>{
            await this.refresh();
            let t = !1;
            for (const s of e){
                if (!this.validate(s)) {
                    console.warn("Invalid topic data", s.topic);
                    continue;
                }
                const { topic: e, ...r } = s;
                this.topicMap.has(e) || (this.topicMap.set(e, r), t = !0);
            }
            t && await this.store();
        });
    }
    get topics() {
        return [
            ...this.topicMap.values()
        ];
    }
    lookup(e) {
        return this.topicMap.get(e);
    }
    toBytes() {
        return (0, _proto.keystore).TopicMap.encode({
            topics: Object.fromEntries(this.topicMap)
        }).finish();
    }
}
class Zt extends Qt {
    static async create(e) {
        const t = new Zt(e, "conversation-v1/v1");
        return await t.refresh(), t;
    }
    validate(e) {
        return !!(e.topic && e.topic.length && e.peerAddress?.length > 0);
    }
}
const es = async (e, t, s, r)=>V(s, await e.sharedSecret(t, e.getCurrentPreKey().publicKey, !1), r);
var ts;
const { ErrorCode: ss } = (0, _proto.keystore), rs = (new TextEncoder).encode("__XMTP__INVITATION__SALT__XMTP__");
class ns {
    constructor(e, t, s, r, n){
        ts.set(this, void 0), this.v1Keys = e, this.v2Keys = Ge.fromLegacyBundle(e), this.v1Store = t, this.v2Store = s, this.privatePreferencesStore = r, this.authenticator = new mt(e.identityKey), this.jobStatePersistence = n;
    }
    static async create(e, t) {
        return new ns(e, await Zt.create(t), await Qt.create(t), await $t.create(t), t);
    }
    get walletAddress() {
        return this.v1Keys.identityKey.publicKey.walletSignatureAddress();
    }
    async decryptV1(e) {
        const t = await Xt(e.requests, async (e)=>{
            zt(e, [
                "payload",
                "peerKeys"
            ], [
                "headerBytes"
            ]);
            const { payload: t, peerKeys: s, headerBytes: r, isSender: n } = e, i = await (async (e, t, s, r, n)=>U(s, await e.sharedSecret(t, e.getCurrentPreKey().publicKey, !n), r))(this.v1Keys, Jt(s), t, r, n);
            return {
                decrypted: i
            };
        }, (0, _proto.keystore).ErrorCode.ERROR_CODE_UNSPECIFIED);
        return (0, _proto.keystore).DecryptResponse.fromPartial({
            responses: t
        });
    }
    async decryptV2(e) {
        const t = await Xt(e.requests, async (e)=>{
            zt(e, [
                "payload"
            ], [
                "headerBytes"
            ]);
            const { payload: t, headerBytes: s, contentTopic: r } = e, n = this.v2Store.lookup(r);
            if (!n) throw new Ee((0, _proto.keystore).ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY, "no topic key");
            const a = await ((e, t, s)=>U(e, t, s))(t, Wt(n.invitation), s);
            return {
                decrypted: a
            };
        }, ss.ERROR_CODE_UNSPECIFIED);
        return (0, _proto.keystore).DecryptResponse.fromPartial({
            responses: t
        });
    }
    async encryptV1(e) {
        const t = await Xt(e.requests, async (e)=>{
            zt(e, [
                "payload",
                "recipient"
            ], [
                "headerBytes"
            ]);
            const { recipient: t, payload: s, headerBytes: r } = e;
            return {
                encrypted: await es(this.v1Keys, Jt(t), s, r)
            };
        }, ss.ERROR_CODE_UNSPECIFIED);
        return (0, _proto.keystore).EncryptResponse.fromPartial({
            responses: t
        });
    }
    async createAuthToken({ timestampNs: e }) {
        return this.authenticator.createToken(e ? ge(e) : void 0);
    }
    async selfEncrypt(e) {
        const t = await Xt(e.requests, async (e)=>{
            const { payload: t } = e;
            if (!t) throw new Ee(ss.ERROR_CODE_INVALID_INPUT, "Missing field payload");
            return {
                encrypted: await Dt(this.v1Keys.identityKey, t)
            };
        }, ss.ERROR_CODE_INVALID_INPUT);
        return (0, _proto.keystore).SelfEncryptResponse.fromPartial({
            responses: t
        });
    }
    async selfDecrypt(e) {
        const t = await Xt(e.requests, async (e)=>{
            const { payload: t } = e;
            if (!t) throw new Ee(ss.ERROR_CODE_INVALID_INPUT, "Missing field payload");
            return {
                decrypted: await Mt(this.v1Keys.identityKey, t)
            };
        }, ss.ERROR_CODE_INVALID_INPUT);
        return (0, _proto.keystore).DecryptResponse.fromPartial({
            responses: t
        });
    }
    async getPrivatePreferencesTopicIdentifier() {
        const e = await async function(e) {
            await (0, _webDefault.default)();
            const t = e.secp256k1.bytes;
            return (0, _web.generate_private_preferences_topic)(t);
        }(this.v1Keys.identityKey);
        return (0, _proto.keystore).GetPrivatePreferencesTopicIdentifierResponse.fromPartial({
            identifier: e
        });
    }
    async encryptV2(e) {
        const t = await Xt(e.requests, async (e)=>{
            zt(e, [
                "payload"
            ], [
                "headerBytes"
            ]);
            const { payload: t, headerBytes: s, contentTopic: r } = e, n = this.v2Store.lookup(r);
            if (!n) throw new Ee(ss.ERROR_CODE_NO_MATCHING_PREKEY, "no topic key");
            const i = Wt(n.invitation), a = await ((e, t, s)=>V(e, t, s))(t, i, s), o = `${Math.floor(Date.now() / 1e3 / 60 / 60 / 24 / 30)}-${await this.getAccountAddress()}`;
            return {
                encrypted: a,
                senderHmac: await G(i, (new TextEncoder).encode(o), s)
            };
        }, ss.ERROR_CODE_INVALID_INPUT);
        return (0, _proto.keystore).EncryptResponse.fromPartial({
            responses: t
        });
    }
    async saveInvites(e) {
        const t = [], s = await Xt(e.requests, async ({ payload: e, timestampNs: s })=>{
            const r = Ut.fromBytes(e);
            if (r.v1) {
                if (!r.v1.header.createdNs.equals(s)) throw new Error("envelope and header timestamp mismatch");
                const e = r.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle()), n = await r.v1.getInvitation(this.v2Keys), i = {
                    invitation: n,
                    createdNs: r.v1.header.createdNs,
                    peerAddress: e ? await r.v1.header.recipient.walletSignatureAddress() : await r.v1.header.sender.walletSignatureAddress()
                };
                return t.push({
                    ...i,
                    topic: n.topic
                }), {
                    conversation: Yt(i)
                };
            }
        }, ss.ERROR_CODE_INVALID_INPUT);
        return await this.v2Store.add(t), (0, _proto.keystore).SaveInvitesResponse.fromPartial({
            responses: s
        });
    }
    async createInvite(e) {
        try {
            zt(e, [
                "recipient"
            ], []);
            const s = ge(e.createdNs), r = (t = e.recipient) instanceof ce ? t : new ce(t), n = await this.getAccountAddress(), a = await r.walletSignatureAddress(), o = await this.v2Keys.sharedSecret(r, this.v2Keys.getCurrentPreKey().publicKey, n < a), c = [
                n,
                a
            ].sort(), d = (e.context?.conversationId || "") + c.join(), h = (new TextEncoder).encode(d), y = j(await It(Buffer.from(o), Buffer.from(h))), u = [
                "0",
                ...c
            ].join("|"), l = (new TextEncoder).encode(u), p = await async function(e, t) {
                const s = await D.subtle.importKey("raw", e, "HKDF", !1, [
                    "deriveKey"
                ]);
                return D.subtle.deriveKey({
                    name: "HKDF",
                    hash: "SHA-256",
                    salt: rs,
                    info: t
                }, s, {
                    name: "AES-GCM",
                    length: 256
                }, !0, [
                    "encrypt",
                    "decrypt"
                ]);
            }(o, l), w = new Uint8Array(await D.subtle.exportKey("raw", p)), f = new xt({
                topic: Ae(y),
                aes256GcmHkdfSha256: {
                    keyMaterial: w
                },
                context: e.context,
                consentProof: e.consentProof
            }), m = await Ut.createV1({
                sender: this.v2Keys,
                recipient: r,
                created: s,
                invitation: f
            }), g = {
                invitation: f,
                topic: f.topic,
                createdNs: e.createdNs,
                peerAddress: await r.walletSignatureAddress()
            };
            return await this.v2Store.add([
                g
            ]), (0, _proto.keystore).CreateInviteResponse.fromPartial({
                conversation: Yt(g),
                payload: m.toBytes()
            });
        } catch (e) {
            throw jt(e, ss.ERROR_CODE_INVALID_INPUT);
        }
        var t;
    }
    async signDigest(e) {
        zt(e, [
            "digest"
        ], []);
        const { digest: t, identityKey: s, prekeyIndex: r } = e;
        let n;
        if (s) n = this.v1Keys.identityKey;
        else {
            if (void 0 === r || !Number.isInteger(r)) throw new Ee(ss.ERROR_CODE_INVALID_INPUT, "must specifify identityKey or prekeyIndex");
            if (n = this.v1Keys.preKeys[r], !n) throw new Ee(ss.ERROR_CODE_NO_MATCHING_PREKEY, "no prekey found");
        }
        return n.sign(t);
    }
    async saveV1Conversations({ conversations: e }) {
        return await this.v1Store.add(e.map((e)=>({
                topic: Se(e.peerAddress, this.walletAddress),
                peerAddress: e.peerAddress,
                createdNs: e.createdNs,
                invitation: void 0
            }))), {};
    }
    async getV1Conversations() {
        return {
            conversations: this.v1Store.topics.map(this.topicDataToV1ConversationReference.bind(this))
        };
    }
    async getV2Conversations() {
        const e = this.v2Store.topics.map((e)=>Yt(e));
        return e.sort((e, t)=>e.createdNs.div(1e6).sub(t.createdNs.div(1e6)).toNumber()), (0, _proto.keystore).GetConversationsResponse.fromPartial({
            conversations: e
        });
    }
    async getPublicKeyBundle() {
        return this.v1Keys.getPublicKeyBundle();
    }
    async getPrivateKeyBundle() {
        return this.v1Keys;
    }
    async getAccountAddress() {
        return this.accountAddress || (this.accountAddress = await this.v2Keys.getPublicKeyBundle().walletSignatureAddress()), this.accountAddress;
    }
    async getRefreshJob({ jobType: e }) {
        if (e === (0, _proto.keystore).JobType.JOB_TYPE_UNSPECIFIED) throw new Ee(ss.ERROR_CODE_INVALID_INPUT, "invalid job type");
        const t = await this.getLastRunTime(e);
        return (0, _proto.keystore).GetRefreshJobResponse.fromPartial({
            lastRunNs: t || (0, _longDefault.default).fromNumber(0)
        });
    }
    async setRefreshJob({ jobType: e, lastRunNs: t }) {
        const s = await this.buildJobStorageKey(e);
        return await this.jobStatePersistence.setItem(s, Uint8Array.from(t.toBytes())), {};
    }
    topicDataToV1ConversationReference(e) {
        return {
            peerAddress: e.peerAddress,
            createdNs: e.createdNs,
            topic: Se(e.peerAddress, this.walletAddress),
            context: void 0,
            consentProofPayload: void 0
        };
    }
    buildJobStorageKey(e) {
        return `refreshJob/${e.toString()}`;
    }
    async getLastRunTime(e) {
        const t = await this.jobStatePersistence.getItem(this.buildJobStorageKey(e));
        if (t && t.length) return (0, _longDefault.default).fromBytes([
            ...t
        ]);
    }
    lookupTopic(e) {
        return this.v2Store.lookup(e);
    }
    async getV2ConversationHmacKeys(e) {
        const t = Math.floor(Date.now() / 1e3 / 60 / 60 / 24 / 30), s = {};
        let r = this.v2Store.topics;
        return e?.topics && (r = r.filter((t)=>void 0 !== t.invitation && e.topics.includes(t.invitation.topic))), await Promise.all(r.map(async (e)=>{
            if (e.invitation?.topic) {
                const r = Wt(e.invitation), n = await Promise.all([
                    t - 1,
                    t,
                    t + 1
                ].map(async (e)=>{
                    const t = `${e}-${await this.getAccountAddress()}`, s = await L(r, (new TextEncoder).encode(t));
                    return {
                        thirtyDayPeriodsSinceEpoch: e,
                        hmacKey: await F(s)
                    };
                }));
                s[e.invitation.topic] = {
                    values: n
                };
            }
        })), {
            hmacKeys: s
        };
    }
    async getPrivatePreferencesTopic() {
        if (!wt(this, ts, "f")) {
            const { identifier: e } = await this.getPrivatePreferencesTopicIdentifier();
            ft(this, ts, ((e)=>Pe(`userpreferences-${e}`))(e), "f");
        }
        return wt(this, ts, "f");
    }
    async createPrivatePreference(e) {
        const { responses: t } = await this.selfEncrypt({
            requests: [
                {
                    payload: (0, _proto.privatePreferences).PrivatePreferencesAction.encode(e).finish()
                }
            ]
        }), s = t.reduce((e, t)=>t.result?.encrypted ? e.concat(t.result?.encrypted) : e, []), r = await this.getPrivatePreferencesTopic(), n = new Date;
        return s.map((e)=>({
                contentTopic: r,
                message: e,
                timestamp: n
            }));
    }
    getPrivatePreferences() {
        return this.privatePreferencesStore.actions;
    }
    savePrivatePreferences(e) {
        return this.privatePreferencesStore.add(e);
    }
}
ts = new WeakMap;
class is {
    constructor(e){
        this.apiClient = e;
    }
    async getItem(e) {
        for await (const t of this.apiClient.queryIterator({
            contentTopic: this.buildTopic(e)
        }, {
            pageSize: 1,
            direction: (0, _proto.messageApi).SortDirection.SORT_DIRECTION_DESCENDING
        }))if (t.message) try {
            return Uint8Array.from(t.message);
        } catch (e) {
            console.log(e);
        }
        return null;
    }
    async setItem(e, t) {
        const s = Uint8Array.from(t);
        await this.apiClient.publish([
            {
                contentTopic: this.buildTopic(e),
                message: s
            }
        ]);
    }
    setAuthenticator(e) {
        this.apiClient.setAuthenticator(e);
    }
    buildTopic(e) {
        return Be(e);
    }
}
class as {
    constructor({ eciesBytes: t, signature: s }){
        if (!t || !t.length) throw new Error("eciesBytes is empty");
        if (!s) throw new Error("signature is undefined");
        this.eciesBytes = t, this.signature = new te(s), this.ciphertext = (0, _proto.ciphertext).SignedEciesCiphertext_Ecies.decode(t);
    }
    toBytes() {
        return (0, _proto.ciphertext).SignedEciesCiphertext.encode(this).finish();
    }
    async verify(e) {
        return e.verify(this.signature, await _(this.eciesBytes));
    }
    static fromBytes(t) {
        const s = (0, _proto.ciphertext).SignedEciesCiphertext.decode(t);
        return new as(s);
    }
    static async create(t, s) {
        ((e)=>{
            if (16 !== e.iv.length) throw new Error("Invalid iv length");
            if (65 !== e.ephemeralPublicKey.length) throw new Error("Invalid ephemPublicKey length");
            if (e.ciphertext.length < 1 || e.ciphertext.length % 16 != 0) throw new Error("Invalid ciphertext length");
            if (32 !== e.mac.length) throw new Error("Invalid mac length");
        })(t);
        const r = (0, _proto.ciphertext).SignedEciesCiphertext_Ecies.encode(t).finish(), n = await s.sign(await _(r));
        return new as({
            eciesBytes: r,
            signature: n
        });
    }
}
class os {
    constructor(e, t){
        this.persistence = e, this.privateKey = t, this.privateKeyBytes = Buffer.from(t.secp256k1.bytes), this.publicKey = Bt(this.privateKeyBytes);
    }
    async getItem(e) {
        const t = await this.persistence.getItem(e);
        return t ? this.decrypt(t) : null;
    }
    async setItem(e, t) {
        const s = await this.encrypt(t);
        await this.persistence.setItem(e, s);
    }
    async encrypt(e) {
        const t = await async function(e, t, s) {
            s = s || {};
            const r = s?.iv || Pt(16);
            let n = s?.ephemPrivateKey || Pt(32);
            for(; !kt(n);){
                if (s?.ephemPrivateKey) throw new Error("ephemPrivateKey is not valid");
                n = Pt(32);
            }
            const i = Bt(n), a = await St(await Rt(n, e)), o = a.slice(0, 32), c = a.slice(32), d = await Tt(r, o, t), h = Buffer.concat([
                r,
                i,
                d
            ]);
            return {
                iv: r,
                ephemeralPublicKey: i,
                ciphertext: d,
                mac: await It(c, h)
            };
        }(this.publicKey, Buffer.from(e));
        return this.serializeEcies(t);
    }
    async decrypt(e) {
        const t = await this.deserializeEcies(e), s = await Nt(this.privateKeyBytes, t);
        return Uint8Array.from(s);
    }
    async serializeEcies(e) {
        return (await as.create(e, this.privateKey)).toBytes();
    }
    async deserializeEcies(e) {
        const t = as.fromBytes(e);
        if (!await t.verify(this.privateKey.publicKey)) throw new Error("signature validation failed");
        const s = t.ciphertext;
        return {
            ciphertext: Buffer.from(s.ciphertext),
            mac: Buffer.from(s.mac),
            iv: Buffer.from(s.iv),
            ephemeralPublicKey: Buffer.from(s.ephemeralPublicKey)
        };
    }
}
class cs {
    constructor(e, t){
        this.prefix = e, this.persistence = t;
    }
    getItem(e) {
        return this.persistence.getItem(this.buildKey(e));
    }
    setItem(e, t) {
        return this.persistence.setItem(this.buildKey(e), t);
    }
    buildKey(e) {
        return this.prefix + e;
    }
}
const ds = async (e, t)=>{
    if (!e.persistConversations) return lt.create();
    const s = await t.identityKey.publicKey.walletSignatureAddress(), r = `xmtp/${e.env}/${s}/`;
    const n = e.basePersistence, i = !e.disablePersistenceEncryption;
    return new cs(r, i ? new os(n, t.identityKey) : n);
}, hs = "key_bundle";
class ys {
    constructor(e, t, s){
        this.signer = e, this.persistence = t, this.preEnableIdentityCallback = s;
    }
    async getStorageAddress(e) {
        let t = await this.signer.getAddress();
        return t = (0, _viem.getAddress)(t), `${t}/${e}`;
    }
    async loadPrivateKeyBundle() {
        const e = await this.persistence.getItem(await this.getStorageAddress(hs));
        if (!e) return null;
        const [t, s] = await this.fromEncryptedBytes(this.signer, Uint8Array.from(e));
        return s && await this.storePrivateKeyBundle(t), t;
    }
    async storePrivateKeyBundle(e) {
        const t = await this.getStorageAddress(hs), s = await this.toEncryptedBytes(e, this.signer);
        "function" == typeof this.persistence.setAuthenticator && this.persistence.setAuthenticator(new mt(e.identityKey)), await this.persistence.setItem(t, s);
    }
    async toEncryptedBytes(e, s) {
        const r = e.encode(), n = D.getRandomValues(new Uint8Array(32)), i = ls(n), a = await s.getAddress();
        this.preEnableIdentityCallback && await this.preEnableIdentityCallback();
        const o = await s.signMessage(i);
        if (!(0, _viem.verifyMessage)({
            address: a,
            message: i,
            signature: o
        })) throw new Error("invalid signature");
        const c = (0, _viem.hexToBytes)(o), d = await V(r, c);
        return (0, _proto.privateKey).EncryptedPrivateKeyBundle.encode({
            v1: {
                walletPreKey: n,
                ciphertext: d
            }
        }).finish();
    }
    async fromEncryptedBytes(e, s) {
        const [r, n] = function(e) {
            try {
                const s = (0, _proto.privateKey).EncryptedPrivateKeyBundle.decode(e);
                if (s.v1) return [
                    s.v1,
                    !1
                ];
            } catch (s) {
                return [
                    (0, _proto.privateKey).EncryptedPrivateKeyBundleV1.decode(e),
                    !0
                ];
            }
            throw new Error("unrecognized encrypted private key bundle version");
        }(s);
        if (!r.walletPreKey) throw new Error("missing wallet pre-key");
        if (!r.ciphertext?.aes256GcmHkdfSha256) throw new Error("missing bundle ciphertext");
        this.preEnableIdentityCallback && await this.preEnableIdentityCallback();
        const i = (0, _viem.hexToBytes)(await e.signMessage(ls(r.walletPreKey)));
        try {
            const e = new N(r.ciphertext), t = await U(e, i), [s, a] = us(t);
            return [
                s,
                n || a
            ];
        } catch (e) {
            if (65 !== i.length) throw new Error("Expected 65 bytes before trying a different recovery byte");
            const t = i[i.length - 1];
            let s = i.slice(0, i.length - 1);
            s = t < 27 ? new Uint8Array([
                ...s,
                t + 27
            ]) : new Uint8Array([
                ...s,
                t - 27
            ]);
            const a = new N(r.ciphertext), o = await U(a, s), [c, d] = us(o);
            return [
                c,
                n || d
            ];
        }
    }
}
function us(e) {
    try {
        const t = Fe(e);
        if (t instanceof Ge) throw new Error("V2 bundles not supported yet");
        return [
            t,
            !1
        ];
    } catch (s) {
        const r = (0, _proto.privateKey).PrivateKeyBundleV1.decode(e);
        return [
            new He(r),
            !0
        ];
    }
}
function ls(e) {
    return `XMTP : Enable Identity\n${j(e)}\n\nFor more info: https://xmtp.org/signatures/`;
}
class ps {
    async newKeystore(e, t, s) {
        if (!s) throw new pt("Wallet required to generate new keys");
        e.preCreateIdentityCallback && await e.preCreateIdentityCallback();
        const r = await He.generate(s), n = new ys(s, new is(t), e.preEnableIdentityCallback);
        return await n.storePrivateKeyBundle(r), ns.create(r, await ds(e, r));
    }
}
class ws {
    async newKeystore(e, t, s) {
        if (!s) throw new pt("No wallet provided");
        const r = new ys(s, new is(t), e.preEnableIdentityCallback), n = await r.loadPrivateKeyBundle();
        if (!n) throw new pt("No keys found");
        return ns.create(n, await ds(e, n));
    }
}
function fs() {
    return window.ethereum;
}
function ms(e) {
    const [t, s, ...r] = e.split(".");
    return {
        major: Number(t),
        minor: Number(s),
        patch: r.join(".")
    };
}
function gs(e, t) {
    if (!e || !t) return !1;
    const s = ms(e), r = ms(t);
    return s.major !== r.major ? s.major > r.major : s.minor !== r.minor ? s.minor > r.minor : !(!s.patch || !r.patch) && function(e, t) {
        const [s, r] = e.split("-"), [n, i] = t.split("-");
        if (Number(s) !== Number(n)) return Number(s) > Number(n);
        if (!r || !i) return !1;
        const [a, o] = r.split("."), [c, d] = i.split(".");
        if (a !== c) return !0;
        return Number(o) > Number(d);
    }(s.patch, r.patch);
}
const { GetKeystoreStatusResponse_KeystoreStatus: vs, InitKeystoreRequest: bs, InitKeystoreResponse: Es, GetKeystoreStatusRequest: Ks, GetKeystoreStatusResponse: ks } = (0, _proto.keystore);
async function Ps(e, t, s, r, n) {
    let i = null;
    if (t.req) {
        const e = (0, t.req.encode)(s).finish();
        i = le(e, 0, e.length);
    }
    const a = await async function(e, t, s, r) {
        const n = {
            meta: s
        };
        "string" == typeof t && (n.req = t);
        const i = await fs()?.request({
            method: "wallet_invokeSnap",
            params: {
                snapId: r,
                request: {
                    method: e,
                    params: n
                }
            }
        });
        if (!i || "object" != typeof i) throw new Error("No response value");
        return i.res;
    }(e, i, r, n);
    if (Array.isArray(a)) throw new Error("Unexpected array response");
    return t.res.decode(ue(a));
}
async function Ss() {
    const e = fs();
    if (e?.isMetaMask) try {
        return await e.request({
            method: "wallet_getSnaps"
        }), !0;
    } catch  {}
    if (void 0 !== e?.detected && Array.isArray(e.detected)) for (const t of e.detected)try {
        return await t.request({
            method: "wallet_getSnaps"
        }), e?.setProvider?.(t), !0;
    } catch  {}
    if (void 0 !== e?.providers && Array.isArray(e.providers)) for (const t of e.providers)try {
        return await t.request({
            method: "wallet_getSnaps"
        }), window.ethereum = t, !0;
    } catch  {}
    return !1;
}
async function As(e, t) {
    try {
        const s = await async function() {
            return await fs()?.request({
                method: "wallet_getSnaps"
            });
        }();
        return s ? Object.values(s).find((s)=>{
            var r, n;
            return s && s.id === e && (!t || (r = s.version, n = t, !r || !n || ms(r).major === ms(n).major));
        }) : void 0;
    } catch (e) {
        return void console.warn("Failed to obtain installed snap", e);
    }
}
const Ts = {
    req: Ks,
    res: ks
};
const Cs = {
    req: bs,
    res: Es
};
const Is = {
    decryptV1: {
        req: (0, _proto.keystore).DecryptV1Request,
        res: (0, _proto.keystore).DecryptResponse
    },
    decryptV2: {
        req: (0, _proto.keystore).DecryptV2Request,
        res: (0, _proto.keystore).DecryptResponse
    },
    encryptV1: {
        req: (0, _proto.keystore).EncryptV1Request,
        res: (0, _proto.keystore).EncryptResponse
    },
    encryptV2: {
        req: (0, _proto.keystore).EncryptV2Request,
        res: (0, _proto.keystore).EncryptResponse
    },
    saveInvites: {
        req: (0, _proto.keystore).SaveInvitesRequest,
        res: (0, _proto.keystore).SaveInvitesResponse
    },
    createInvite: {
        req: (0, _proto.keystore).CreateInviteRequest,
        res: (0, _proto.keystore).CreateInviteResponse
    },
    createAuthToken: {
        req: (0, _proto.keystore).CreateAuthTokenRequest,
        res: (0, _proto.authn).Token
    },
    signDigest: {
        req: (0, _proto.keystore).SignDigestRequest,
        res: (0, _proto.signature).Signature
    },
    getPublicKeyBundle: {
        req: null,
        res: (0, _proto.publicKey).PublicKeyBundle
    },
    getPrivateKeyBundle: {
        req: null,
        res: (0, _proto.privateKey).PrivateKeyBundleV1
    },
    saveV1Conversations: {
        req: (0, _proto.keystore).SaveV1ConversationsRequest,
        res: (0, _proto.keystore).SaveV1ConversationsResponse
    },
    getV1Conversations: {
        req: null,
        res: (0, _proto.keystore).GetConversationsResponse
    },
    getV2Conversations: {
        req: null,
        res: (0, _proto.keystore).GetConversationsResponse
    },
    getRefreshJob: {
        req: (0, _proto.keystore).GetRefreshJobRequest,
        res: (0, _proto.keystore).GetRefreshJobResponse
    },
    setRefreshJob: {
        req: (0, _proto.keystore).SetRefeshJobRequest,
        res: (0, _proto.keystore).SetRefreshJobResponse
    },
    selfEncrypt: {
        req: (0, _proto.keystore).SelfEncryptRequest,
        res: (0, _proto.keystore).SelfEncryptResponse
    },
    selfDecrypt: {
        req: (0, _proto.keystore).SelfDecryptRequest,
        res: (0, _proto.keystore).DecryptResponse
    },
    getPrivatePreferencesTopicIdentifier: {
        req: null,
        res: (0, _proto.keystore).GetPrivatePreferencesTopicIdentifierResponse
    },
    getV2ConversationHmacKeys: {
        req: (0, _proto.keystore).GetConversationHmacKeysRequest,
        res: (0, _proto.keystore).GetConversationHmacKeysResponse
    }
}, Bs = {
    getKeystoreStatus: {
        req: (0, _proto.keystore).GetKeystoreStatusRequest,
        res: (0, _proto.keystore).GetKeystoreStatusResponse
    },
    initKeystore: {
        req: (0, _proto.keystore).InitKeystoreRequest,
        res: (0, _proto.keystore).InitKeystoreResponse
    }
};
const { GetKeystoreStatusResponse_KeystoreStatus: Rs } = (0, _proto.keystore);
class Ns {
    constructor(e = "local:http://localhost:8080", t){
        this.snapId = e, this.snapVersion = t;
    }
    async newKeystore(e, t, s) {
        if (!s) throw new pt("No wallet provided");
        if (!await Ss()) throw new pt("MetaMask with Snaps not detected");
        const r = await s.getAddress(), n = e.env, i = await As(this.snapId, this.snapVersion);
        if (i && !gs(this.snapVersion, i.version) || await async function(e, t = {}) {
            await fs()?.request({
                method: "wallet_requestSnaps",
                params: {
                    [e]: t
                }
            });
        }(this.snapId, this.snapVersion ? {
            version: this.snapVersion
        } : {}), !await async function(e, t, s) {
            const r = await async function(e, t) {
                const s = await Ps("getKeystoreStatus", Ts, {
                    walletAddress: e.walletAddress
                }, e, t);
                if ([
                    vs.KEYSTORE_STATUS_UNSPECIFIED,
                    vs.UNRECOGNIZED
                ].includes(s.status)) throw new Error("No status specified in response");
                return s.status;
            }({
                walletAddress: e,
                env: t
            }, s);
            if (r === Rs.KEYSTORE_STATUS_INITIALIZED) return !0;
            return !1;
        }(r, n, this.snapId)) {
            const r = await async function(e, t, s) {
                if (e.privateKeyOverride) {
                    const t = Fe(e.privateKeyOverride);
                    if (!(t instanceof He)) throw new Error("Unsupported private key bundle version");
                    return t;
                }
                if (!s) throw new Error("No privateKeyOverride or wallet");
                return async function(e, t, s) {
                    const r = new ws;
                    try {
                        const n = await r.newKeystore(e, t, s);
                        return new He(await n.getPrivateKeyBundle());
                    } catch (r) {
                        if (r instanceof pt) return async function(e, t, s) {
                            const r = new ps, n = await r.newKeystore(e, t, s);
                            return new He(await n.getPrivateKeyBundle());
                        }(e, t, s);
                        throw r;
                    }
                }(e, t, s);
            }(e, t, s);
            await async function(e, t, s) {
                const r = e.identityKey.publicKey.walletSignatureAddress(), n = await Ps("initKeystore", Cs, {
                    v1: e
                }, {
                    walletAddress: r,
                    env: t
                }, s);
                if (n.error) throw new Ee(n.error.code, n.error.message);
            }(r, n, this.snapId);
        }
        return function(e, t, s) {
            const r = {}, n = {
                walletAddress: e,
                env: t
            };
            for (const [e, t] of Object.entries(Bs))r[e] = async (r)=>t.req ? Ps(e, t, r, n, s) : Ps(e, t, void 0, n, s);
            return {
                ...r,
                getAccountAddress: async ()=>e
            };
        }(r, n, this.snapId);
    }
}
class Ds {
    async newKeystore(e) {
        const { privateKeyOverride: t } = e;
        if (!t) throw new pt("No private key override provided");
        const s = Fe(t);
        if (s instanceof Ge) throw new Error("V2 private key bundle found. Only V1 supported");
        return ns.create(s, await ds(e, s));
    }
}
function Ms(e) {
    if (!e) return null;
    if (function(e) {
        return "type" in e && ("walletClient" === e.type || "base" === e.type);
    }(e)) return function(e) {
        const { account: t } = e;
        if (!t || !t.address) throw new Error("WalletClient is not configured");
        return {
            getAddress: async ()=>t.address,
            signMessage: async (s)=>e.signMessage({
                    message: "string" == typeof s ? s : {
                        raw: s
                    },
                    account: t
                })
        };
    }(e);
    if ("function" != typeof e.getAddress) throw new Error("Unknown wallet type");
    return e;
}
function xs(e) {
    if (e === (0, _proto.content).Compression.COMPRESSION_GZIP) return "gzip";
    if (e === (0, _proto.content).Compression.COMPRESSION_DEFLATE) return "deflate";
    throw new Error("unrecognized compression algorithm");
}
function _s(e, t = 1024) {
    let s = 0;
    return new ReadableStream({
        pull (r) {
            if (s >= e.length) return r.close();
            let n = s + t;
            n = n <= e.length ? n : e.length, r.enqueue(e.subarray(s, n)), s = n;
        }
    });
}
function Vs(e, t) {
    let s = 0;
    return new WritableStream({
        write (r) {
            const n = s + r.length;
            if (n > t) throw new Error("maximum output size exceeded");
            for(; e.bytes.length < n;)e.bytes = Us(e.bytes, t);
            e.bytes.set(r, s), s = n;
        },
        close () {
            s < e.bytes.length && (e.bytes = e.bytes.subarray(0, s));
        }
    });
}
function Us(e, t) {
    let s = 2 * e.length;
    s > t && (s = t);
    const r = new Uint8Array(s);
    return r.set(e), r;
}
function Os(e) {
    let t;
    try {
        t = (0, _proto.contact).ContactBundle.decode(e);
    } catch (s) {
        const n = (0, _proto.publicKey).PublicKeyBundle.decode(e);
        t = {
            v1: {
                keyBundle: new de(n)
            },
            v2: void 0
        };
    }
    if (t.v1?.keyBundle) return new de(t.v1.keyBundle);
    if (t.v2?.keyBundle) return new ce(t.v2.keyBundle);
    throw new Error("unknown or invalid contact bundle");
}
function qs(e) {
    return e instanceof de ? (0, _proto.contact).ContactBundle.encode({
        v1: {
            keyBundle: e
        },
        v2: void 0
    }).finish() : (0, _proto.contact).ContactBundle.encode({
        v1: void 0,
        v2: {
            keyBundle: e
        }
    }).finish();
}
var Ls, Gs, Hs, Fs, $s;
class js {
    constructor(e, t, s){
        this.value = e, this.entryType = t, this.permissionType = s;
    }
    get key() {
        return `${this.entryType}-${this.value}`;
    }
    static fromAddress(e, t = "unknown") {
        return new js(e, "address", t);
    }
    static fromGroupId(e, t = "unknown") {
        return new js(e, "groupId", t);
    }
    static fromInboxId(e, t = "unknown") {
        return new js(e, "inboxId", t);
    }
}
class Xs {
    constructor(e){
        this.entries = new Map, this.client = e;
    }
    allow(e) {
        const t = js.fromAddress(e, "allowed");
        return this.entries.set(t.key, "allowed"), t;
    }
    deny(e) {
        const t = js.fromAddress(e, "denied");
        return this.entries.set(t.key, "denied"), t;
    }
    allowGroup(e) {
        const t = js.fromGroupId(e, "allowed");
        return this.entries.set(t.key, "allowed"), t;
    }
    denyGroup(e) {
        const t = js.fromGroupId(e, "denied");
        return this.entries.set(t.key, "denied"), t;
    }
    allowInboxId(e) {
        const t = js.fromInboxId(e, "allowed");
        return this.entries.set(t.key, "allowed"), t;
    }
    denyInboxId(e) {
        const t = js.fromInboxId(e, "denied");
        return this.entries.set(t.key, "denied"), t;
    }
    state(e) {
        const t = js.fromAddress(e);
        return this.entries.get(t.key) ?? "unknown";
    }
    groupState(e) {
        const t = js.fromGroupId(e);
        return this.entries.get(t.key) ?? "unknown";
    }
    inboxIdState(e) {
        const t = js.fromInboxId(e);
        return this.entries.get(t.key) ?? "unknown";
    }
    async decodeMessages(e) {
        const t = Array.from(e.values()), { responses: s } = await this.client.keystore.selfDecrypt({
            requests: t.map((e)=>({
                    payload: e
                }))
        }), r = Array.from(e.keys()).map((e, t)=>[
                e,
                s[t]
            ]).reduce((e, [t, s])=>{
            if (s.result?.decrypted) {
                const r = (0, _proto.privatePreferences).PrivatePreferencesAction.decode(s.result.decrypted);
                e.set(t, r);
            }
            return e;
        }, new Map);
        return await this.client.keystore.savePrivatePreferences(r), r;
    }
    processActions(e) {
        Array.from(e.values()).forEach((e)=>{
            e.allowAddress?.walletAddresses.forEach((e)=>{
                this.allow(e);
            }), e.denyAddress?.walletAddresses.forEach((e)=>{
                this.deny(e);
            }), e.allowGroup?.groupIds.forEach((e)=>{
                this.allowGroup(e);
            }), e.denyGroup?.groupIds.forEach((e)=>{
                this.denyGroup(e);
            }), e.allowInboxId?.inboxIds.forEach((e)=>{
                this.allowInboxId(e);
            }), e.denyInboxId?.inboxIds.forEach((e)=>{
                this.denyInboxId(e);
            });
        });
    }
    async stream(e) {
        const t = await this.client.keystore.getPrivatePreferencesTopic();
        return ye.create(this.client, [
            t
        ], async (e)=>{
            if (!e.message || !e.timestampNs) return;
            const t = await this.decodeMessages(new Map([
                [
                    e.timestampNs,
                    e.message
                ]
            ]));
            return this.processActions(t), t.get(e.timestampNs);
        }, void 0, e);
    }
    reset() {
        this.entries.clear();
    }
    async load(e) {
        const t = await this.client.keystore.getPrivatePreferencesTopic(), s = (await this.client.listEnvelopes(t, async ({ message: e, timestampNs: t })=>[
                t,
                e
            ], {
            pageSize: 500,
            direction: (0, _proto.messageApi).SortDirection.SORT_DIRECTION_ASCENDING,
            startTime: e
        })).filter(([e])=>Boolean(e));
        await this.decodeMessages(new Map(s));
        const r = this.client.keystore.getPrivatePreferences();
        return this.reset(), this.processActions(r), this.entries;
    }
    async publish(e) {
        const t = e.reduce((e, t)=>{
            let s, r, n;
            if ("unknown" === t.permissionType) return e;
            switch(t.entryType){
                case "address":
                    s = "allowed" === t.permissionType ? "allowAddress" : "denyAddress", r = "walletAddresses", n = e[s]?.[r] ?? [];
                    break;
                case "groupId":
                    s = "allowed" === t.permissionType ? "allowGroup" : "denyGroup", r = "groupIds", n = e[s]?.[r] ?? [];
                    break;
                case "inboxId":
                    s = "allowed" === t.permissionType ? "allowInboxId" : "denyInboxId", r = "inboxIds", n = e[s]?.[r] ?? [];
                    break;
                default:
                    return e;
            }
            return {
                ...e,
                [s]: {
                    [r]: [
                        ...n,
                        t.value
                    ]
                }
            };
        }, {}), s = await this.client.keystore.createPrivatePreference(t);
        await this.client.publishEnvelopes(s), this.client.keystore.savePrivatePreferences(new Map([
            [
                s[0].timestamp.getTime().toString(),
                t
            ]
        ])), e.forEach((e)=>{
            this.entries.set(e.key, e.permissionType);
        });
    }
}
class Js {
    constructor(e){
        Ls.add(this), Gs.set(this, void 0), Hs.set(this, void 0), this.addresses = new Set, this.client = e, ft(this, Gs, new Xs(e), "f"), ft(this, Hs, new ct("user-preferences", e.keystore), "f");
    }
    async loadConsentList(e) {
        return wt(this, Hs, "f").run(async (t)=>{
            const s = await wt(this, Gs, "f").load(e ?? t);
            try {
                const e = (await this.client.conversations.list()).reduce((e, t)=>t.consentProof && "unknown" === this.consentState(t.peerAddress) && wt(this, Ls, "m", Fs).call(this, t.consentProof, t.peerAddress) ? e.concat(t.peerAddress) : e, []);
                e.length && await this.client.contacts.allow(e);
            } catch (e) {
                console.log(e);
            }
            return s;
        });
    }
    async refreshConsentList() {
        return wt(this, Gs, "f").reset(), await wt(this, Hs, "f").resetLastRunTime(), this.loadConsentList();
    }
    async streamConsentList(e) {
        return wt(this, Gs, "f").stream(e);
    }
    setConsentListEntries(e) {
        e.length && (wt(this, Gs, "f").reset(), e.forEach((e)=>{
            "allowed" === e.permissionType && wt(this, Gs, "f").allow(e.value), "denied" === e.permissionType && wt(this, Gs, "f").deny(e.value);
        }));
    }
    isAllowed(e) {
        return "allowed" === wt(this, Gs, "f").state(e);
    }
    isDenied(e) {
        return "denied" === wt(this, Gs, "f").state(e);
    }
    isGroupAllowed(e) {
        return "allowed" === wt(this, Gs, "f").groupState(e);
    }
    isGroupDenied(e) {
        return "denied" === wt(this, Gs, "f").groupState(e);
    }
    isInboxAllowed(e) {
        return "allowed" === wt(this, Gs, "f").inboxIdState(e);
    }
    isInboxDenied(e) {
        return "denied" === wt(this, Gs, "f").inboxIdState(e);
    }
    consentState(e) {
        return wt(this, Gs, "f").state(e);
    }
    groupConsentState(e) {
        return wt(this, Gs, "f").groupState(e);
    }
    inboxConsentState(e) {
        return wt(this, Gs, "f").inboxIdState(e);
    }
    async allow(e) {
        await wt(this, Gs, "f").publish(e.map((e)=>js.fromAddress(e, "allowed")));
    }
    async deny(e) {
        await wt(this, Gs, "f").publish(e.map((e)=>js.fromAddress(e, "denied")));
    }
    async allowGroups(e) {
        await wt(this, Gs, "f").publish(e.map((e)=>js.fromGroupId(e, "allowed")));
    }
    async denyGroups(e) {
        await wt(this, Gs, "f").publish(e.map((e)=>js.fromGroupId(e, "denied")));
    }
    async allowInboxes(e) {
        await wt(this, Gs, "f").publish(e.map((e)=>js.fromInboxId(e, "allowed")));
    }
    async denyInboxes(e) {
        await wt(this, Gs, "f").publish(e.map((e)=>js.fromInboxId(e, "denied")));
    }
}
Gs = new WeakMap, Hs = new WeakMap, Ls = new WeakSet, Fs = function({ signature: e, timestamp: t }, s) {
    const r = Number(t);
    if (!e || !r) return !1;
    if (r > Date.now()) return !1;
    if (r < Date.now() - 2592e6) return !1;
    const n = J(e), i = (0, _consentProofSignature.createConsentMessage)(s, r), a = ee((0, _viem.hexToBytes)((0, _viem.hashMessage)(i)), n);
    return a?.getEthereumAddress() === this.client.address;
}, function(e) {
    e[e.none = 0] = "none", e[e.xmtpTopicStore = 1] = "xmtpTopicStore";
}($s || ($s = {}));
const zs = $s.none;
class Ws {
    static createConfiguration() {
        return {
            type: zs,
            version: 0
        };
    }
    constructor(e){
        this.configuration = e;
    }
    get backupType() {
        return zs;
    }
}
const Ys = $s.xmtpTopicStore;
class Qs {
    static createConfiguration(e) {
        return {
            type: Ys,
            version: 0,
            topic: "history-v0:" + e
        };
    }
    constructor(e){
        this.configuration = e;
    }
    get backupType() {
        return Ys;
    }
}
async function Zs(e, t) {
    const s = await async function(e, t) {
        let s;
        switch((await t()).type){
            case $s.none:
                s = Ws.createConfiguration();
                break;
            case $s.xmtpTopicStore:
                s = Qs.createConfiguration(e);
        }
        return s;
    }(e, t);
    switch(s.type){
        case $s.none:
            return new Ws(s);
        case $s.xmtpTopicStore:
            return new Qs(s);
    }
}
const { Compression: er } = (0, _proto.content), tr = 104857600;
class sr {
    constructor(e, t, s, r){
        this.knownPublicKeyBundles = new Map, this.keystore = r, this.publicKeyBundle = e, this.address = e.walletSignatureAddress(), this._conversations = new ht(this), this._codecs = new Map, this._maxContentSize = tr, this.apiClient = t, this._backupClient = s, this.contacts = new Js(this);
    }
    get conversations() {
        return this._conversations;
    }
    get backupType() {
        return this._backupClient.backupType;
    }
    get signedPublicKeyBundle() {
        return ce.fromLegacyBundle(this.publicKeyBundle);
    }
    static async create(e, t) {
        const s = Ms(e), r = function(e) {
            const t = {
                privateKeyOverride: void 0,
                env: "dev",
                apiUrl: void 0,
                codecs: [
                    new (0, _contentTypeText.TextCodec)
                ],
                maxContentSize: tr,
                persistConversations: !0,
                skipContactPublishing: !1,
                useSnaps: !1,
                basePersistence: "undefined" != typeof window && void 0 !== window.document ? yt.create() : lt.create(),
                disablePersistenceEncryption: !1,
                keystoreProviders: ar(),
                apiClientFactory: rr
            };
            return e?.codecs && (e.codecs = t.codecs.concat(e.codecs)), e?.useSnaps && (e.keystoreProviders = [
                new Ns("npm:@xmtp/snap", "1.3.6"),
                ...t.keystoreProviders
            ]), {
                ...t,
                ...e
            };
        }(t), n = r.apiClientFactory(r), i = await async function(e, t, s) {
            for (const r of e.keystoreProviders)try {
                return await r.newKeystore(e, t, s ?? void 0);
            } catch (e) {
                if (e instanceof pt) continue;
                throw e;
            }
            throw new Error("No keystore providers available");
        }(r, n, s), a = new de(await i.getPublicKeyBundle()), o = a.walletSignatureAddress();
        n.setAuthenticator(new Xe(i));
        const c = await sr.setupBackupClient(o, r.env), d = new sr(a, n, c, i);
        return await d.init(r), d;
    }
    static async getKeys(e, t) {
        const s = await sr.create(Ms(e), t), r = await s.keystore.getPrivateKeyBundle();
        return new He(r).encode();
    }
    static isSnapsReady() {
        return Ss();
    }
    static async setupBackupClient(e, t) {
        return Zs(e, async ()=>Promise.resolve({
                type: "local" === t ? $s.xmtpTopicStore : $s.none
            }));
    }
    async init(e) {
        e.codecs.forEach((e)=>{
            this.registerCodec(e);
        }), this._maxContentSize = e.maxContentSize, e.skipContactPublishing || await this.ensureUserContactPublished(e.publishLegacyContact);
    }
    async close() {}
    async ensureUserContactPublished(e = !1) {
        const t = await nr(this.apiClient, this.address);
        t && t instanceof ce && this.signedPublicKeyBundle.equals(t) || (await this.publishUserContact(!0), e || await this.publishUserContact(e));
    }
    async publishUserContact(e = !1) {
        const t = e ? this.publicKeyBundle : this.signedPublicKeyBundle;
        await this.publishEnvelopes([
            {
                contentTopic: Te(this.address),
                message: qs(t)
            }
        ]);
    }
    async getUserContact(e) {
        e = (0, _viem.getAddress)(e);
        const t = this.knownPublicKeyBundles.get(e);
        if (t) return t;
        const s = await nr(this.apiClient, e);
        return s && this.knownPublicKeyBundles.set(e, s), s;
    }
    async getUserContacts(e) {
        const t = e.map((e)=>(0, _viem.getAddress)(e)), s = new Map, r = [];
        for (const e of t){
            const t = this.knownPublicKeyBundles.get(e);
            t ? s.set(e, t) : (s.set(e, void 0), r.push(e));
        }
        const n = await ir(this.apiClient, r);
        for(let e = 0; e < n.length; e++){
            const t = r[e], i = n[e];
            s.set(t, i), i && this.knownPublicKeyBundles.set(t, i);
        }
        return t.map((e)=>s.get(e));
    }
    forgetContact(e) {
        e = (0, _viem.getAddress)(e), this.knownPublicKeyBundles.delete(e);
    }
    async canMessage(e) {
        try {
            if (Array.isArray(e)) return (await this.getUserContacts(e)).map((e)=>!!e);
            return void 0 !== await this.getUserContact(e);
        } catch (e) {
            return !1;
        }
    }
    static async canMessage(e, t) {
        const s = new ot(t?.apiUrl || tt[t?.env || "dev"], {
            appVersion: t?.appVersion
        });
        if (Array.isArray(e)) {
            const t = e.map((e)=>(0, _viem.getAddress)(e));
            return (await ir(s, t)).map((e)=>!!e);
        }
        try {
            e = (0, _viem.getAddress)(e);
        } catch (e) {
            return !1;
        }
        return void 0 !== await nr(s, e);
    }
    validateEnvelope(e) {
        const t = e.message;
        if (!e.contentTopic) throw new Error("Missing content topic");
        if (!t || !t.length) throw new Error("Cannot publish empty message");
    }
    async publishEnvelopes(e) {
        for (const t of e)this.validateEnvelope(t);
        await this.apiClient.publish(e);
    }
    registerCodec(e) {
        const t = e.contentType, s = `${t.authorityId}/${t.typeId}`;
        return this._codecs.set(s, e), this;
    }
    codecFor(e) {
        const t = `${e.authorityId}/${e.typeId}`, s = this._codecs.get(t);
        if (s && !(e.versionMajor > s.contentType.versionMajor)) return s;
    }
    async encodeContent(e, t) {
        const s = t?.contentType || (0, _contentTypeText.ContentTypeText), r = this.codecFor(s);
        if (!r) throw new Error("unknown content type " + s);
        const n = r.encode(e, this), i = r.fallback(e);
        return i && (n.fallback = i), "number" == typeof t?.compression && n.content.length >= 10 && (n.compression = t.compression), await async function(e) {
            if (void 0 === e.compression) return;
            const t = {
                bytes: new Uint8Array(e.content.length / 10)
            };
            await _s(e.content).pipeThrough(new CompressionStream(xs(e.compression))).pipeTo(Vs(t, e.content.length + 1e3)), e.content = t.bytes;
        }(n), {
            payload: (0, _proto.content).EncodedContent.encode(n).finish(),
            shouldPush: r.shouldPush(e)
        };
    }
    async decodeContent(e) {
        const t = (0, _proto.content).EncodedContent.decode(e);
        if (!t.type) throw new Error("missing content type");
        let s;
        const r = new (0, _contentTypePrimitives.ContentTypeId)(t.type);
        let n;
        await async function(e, t) {
            if (void 0 === e.compression) return;
            const s = {
                bytes: new Uint8Array(e.content.length)
            };
            await _s(e.content).pipeThrough(new DecompressionStream(xs(e.compression))).pipeTo(Vs(s, t)), e.content = s.bytes;
        }(t, 1e3);
        const i = this.codecFor(r);
        return i ? s = i.decode(t, this) : n = new Error("unknown content type " + r), {
            content: s,
            contentType: r,
            error: n,
            contentFallback: t.fallback
        };
    }
    listInvitations(e) {
        return this.listEnvelopes(Ie(this.address), async (e)=>e, e);
    }
    async listEnvelopes(e, t, s) {
        s || (s = {});
        const { startTime: r, endTime: n, limit: i, pageSize: a } = s, o = await this.apiClient.query({
            contentTopic: e,
            startTime: r,
            endTime: n
        }, {
            direction: s.direction || (0, _proto.messageApi).SortDirection.SORT_DIRECTION_ASCENDING,
            limit: i,
            pageSize: a
        }), c = [];
        for (const e of o)if (e.message) try {
            const s = await t(e);
            c.push(s);
        } catch (e) {
            console.warn("Error in listEnvelopes mapper", e);
        }
        return c;
    }
    listEnvelopesPaginated(e, t, s) {
        return Ye(this.apiClient.queryIteratePages({
            contentTopic: e,
            startTime: s?.startTime,
            endTime: s?.endTime
        }, {
            direction: s?.direction,
            pageSize: s?.pageSize || 100
        }), t);
    }
}
function rr(e) {
    const t = e.apiUrl || tt[e.env];
    return new ot(t, {
        appVersion: e.appVersion
    });
}
async function nr(e, t) {
    const s = e.queryIterator({
        contentTopic: Te(t)
    }, {
        pageSize: 5,
        direction: et.SORT_DIRECTION_DESCENDING
    });
    for await (const e of s){
        if (!e.message) continue;
        const s = Os(e.message);
        let r;
        try {
            r = await s?.walletSignatureAddress();
        } catch (e) {
            r = void 0;
        }
        if (r?.toLowerCase() === t.toLowerCase()) return s;
    }
}
async function ir(e, t) {
    const s = t.map(Te), r = await e.batchQuery(s.map((e)=>({
            contentTopic: e,
            pageSize: 5,
            direction: et.SORT_DIRECTION_DESCENDING
        })));
    return Promise.all(t.map(async (e, t)=>{
        const s = r[t];
        if (s) {
            for (const t of s)if (t.message) try {
                const s = Os(t.message), r = await s?.walletSignatureAddress();
                if (e.toLowerCase() === r.toLowerCase()) return s;
                console.info("Received contact bundle with incorrect address");
            } catch (e) {
                console.info("Invalid contact bundle", e);
            }
        }
    }));
}
function ar() {
    return [
        new Ds,
        new ws,
        new ps
    ];
}

},{"eaf94225b1296aaa":"fCgem","@xmtp/proto":"5oYtL","long":"3JDQT","@noble/secp256k1":"78Gvp","viem":"7gLEX","@xmtp/content-type-text":"cdh1H","@xmtp/content-type-primitives":"1o3Qd","async-mutex":"VxgNq","elliptic":"1NKsH","@xmtp/user-preferences-bindings-wasm/web":"k4HxT","@xmtp/consent-proof-signature":"8W9mI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
const base64 = require("9c62938f1dccc73c");
const ieee754 = require("aceacb6a4531a9d2");
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"9c62938f1dccc73c":"eIiSV","aceacb6a4531a9d2":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"5oYtL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "messageApi", ()=>_messageApiPb);
parcelHelpers.export(exports, "fetcher", ()=>_fetchPb);
parcelHelpers.export(exports, "authn", ()=>_authnPb);
parcelHelpers.export(exports, "message", ()=>_messagePb);
parcelHelpers.export(exports, "content", ()=>_contentPb);
parcelHelpers.export(exports, "frames", ()=>_framesPb);
parcelHelpers.export(exports, "conversationReference", ()=>_conversationReferencePb);
parcelHelpers.export(exports, "composite", ()=>_compositePb);
parcelHelpers.export(exports, "privateKey", ()=>_privateKeyPb);
parcelHelpers.export(exports, "publicKey", ()=>_publicKeyPb);
parcelHelpers.export(exports, "signature", ()=>_signaturePb);
parcelHelpers.export(exports, "ciphertext", ()=>_ciphertextPb);
parcelHelpers.export(exports, "contact", ()=>_contactPb);
parcelHelpers.export(exports, "invitation", ()=>_invitationPb);
parcelHelpers.export(exports, "keystore", ()=>_keystorePb);
parcelHelpers.export(exports, "privatePreferences", ()=>_privatePreferencesPb);
parcelHelpers.export(exports, "signedPayload", ()=>_signedPayloadPb);
parcelHelpers.export(exports, "ecies", ()=>_eciesPb);
parcelHelpers.export(exports, "mlsApi", ()=>_mlsPb);
parcelHelpers.export(exports, "mlsDatabaseIntent", ()=>_intentsPb);
parcelHelpers.export(exports, "mlsContent", ()=>_contentPb1);
parcelHelpers.export(exports, "mlsGroupMembership", ()=>_groupMembershipPb);
parcelHelpers.export(exports, "mlsGroupMetadata", ()=>_groupMetadataPb);
parcelHelpers.export(exports, "mlsGroupMutableMetadata", ()=>_groupMutableMetadataPb);
parcelHelpers.export(exports, "mlsTranscriptMessages", ()=>_transcriptMessagesPb);
parcelHelpers.export(exports, "mlsValidationService", ()=>_servicePb);
var _messageApiPb = require("./message_api/v1/message_api.pb");
var _fetchPb = require("./fetch.pb");
var _authnPb = require("./message_api/v1/authn.pb");
var _messagePb = require("./message_contents/message.pb");
var _contentPb = require("./message_contents/content.pb");
var _framesPb = require("./message_contents/frames.pb");
var _conversationReferencePb = require("./message_contents/conversation_reference.pb");
var _compositePb = require("./message_contents/composite.pb");
var _privateKeyPb = require("./message_contents/private_key.pb");
var _publicKeyPb = require("./message_contents/public_key.pb");
var _signaturePb = require("./message_contents/signature.pb");
var _ciphertextPb = require("./message_contents/ciphertext.pb");
var _contactPb = require("./message_contents/contact.pb");
var _invitationPb = require("./message_contents/invitation.pb");
var _keystorePb = require("./keystore_api/v1/keystore.pb");
var _privatePreferencesPb = require("./message_contents/private_preferences.pb");
var _signedPayloadPb = require("./message_contents/signed_payload.pb");
var _eciesPb = require("./message_contents/ecies.pb");
var _mlsPb = require("./mls/api/v1/mls.pb");
var _intentsPb = require("./mls/database/intents.pb");
var _contentPb1 = require("./mls/message_contents/content.pb");
var _groupMembershipPb = require("./mls/message_contents/group_membership.pb");
var _groupMetadataPb = require("./mls/message_contents/group_metadata.pb");
var _groupMutableMetadataPb = require("./mls/message_contents/group_mutable_metadata.pb");
var _transcriptMessagesPb = require("./mls/message_contents/transcript_messages.pb");
var _servicePb = require("./mls_validation/v1/service.pb");

},{"./message_api/v1/message_api.pb":"cptat","./fetch.pb":"l84L6","./message_api/v1/authn.pb":"dTH2S","./message_contents/message.pb":"9J2LG","./message_contents/content.pb":"2nRTw","./message_contents/frames.pb":"fn5vw","./message_contents/conversation_reference.pb":"jsKKm","./message_contents/composite.pb":"fhpbS","./message_contents/private_key.pb":"11lga","./message_contents/public_key.pb":"6Dba7","./message_contents/signature.pb":"hvHvx","./message_contents/ciphertext.pb":"dkFEI","./message_contents/contact.pb":"8eJQP","./message_contents/invitation.pb":"1UrlP","./keystore_api/v1/keystore.pb":"hVmoL","./message_contents/private_preferences.pb":"8F1sC","./message_contents/signed_payload.pb":"h3MRZ","./message_contents/ecies.pb":"iX6C0","./mls/api/v1/mls.pb":"loJmb","./mls/database/intents.pb":"9QQ5s","./mls/message_contents/content.pb":"d2gKr","./mls/message_contents/group_membership.pb":"2plVM","./mls/message_contents/group_metadata.pb":"wFUqg","./mls/message_contents/group_mutable_metadata.pb":"8NVDI","./mls/message_contents/transcript_messages.pb":"dGyFg","./mls_validation/v1/service.pb":"2YLwu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cptat":[function(require,module,exports) {
/* eslint-disable */ // @ts-nocheck
/*
* This file is a generated Typescript file for GRPC Gateway, DO NOT MODIFY
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SortDirection", ()=>SortDirection);
parcelHelpers.export(exports, "MessageApi", ()=>MessageApi);
var _fetchPb = require("../../fetch.pb");
var SortDirection;
(function(SortDirection) {
    SortDirection["SORT_DIRECTION_UNSPECIFIED"] = "SORT_DIRECTION_UNSPECIFIED";
    SortDirection["SORT_DIRECTION_ASCENDING"] = "SORT_DIRECTION_ASCENDING";
    SortDirection["SORT_DIRECTION_DESCENDING"] = "SORT_DIRECTION_DESCENDING";
})(SortDirection || (SortDirection = {}));
class MessageApi {
    static Publish(req, initReq) {
        return _fetchPb.fetchReq(`/message/v1/publish`, Object.assign(Object.assign({}, initReq), {
            method: "POST",
            body: JSON.stringify(req, _fetchPb.replacer)
        }));
    }
    static Subscribe(req, entityNotifier, initReq) {
        return _fetchPb.fetchStreamingRequest(`/message/v1/subscribe`, entityNotifier, Object.assign(Object.assign({}, initReq), {
            method: "POST",
            body: JSON.stringify(req, _fetchPb.replacer)
        }));
    }
    static SubscribeAll(req, entityNotifier, initReq) {
        return _fetchPb.fetchStreamingRequest(`/message/v1/subscribe-all`, entityNotifier, Object.assign(Object.assign({}, initReq), {
            method: "POST",
            body: JSON.stringify(req, _fetchPb.replacer)
        }));
    }
    static Query(req, initReq) {
        return _fetchPb.fetchReq(`/message/v1/query`, Object.assign(Object.assign({}, initReq), {
            method: "POST",
            body: JSON.stringify(req, _fetchPb.replacer)
        }));
    }
    static BatchQuery(req, initReq) {
        return _fetchPb.fetchReq(`/message/v1/batch-query`, Object.assign(Object.assign({}, initReq), {
            method: "POST",
            body: JSON.stringify(req, _fetchPb.replacer)
        }));
    }
}

},{"../../fetch.pb":"l84L6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l84L6":[function(require,module,exports) {
/* eslint-disable */ // @ts-nocheck
/*
* This file is a generated Typescript file for GRPC Gateway, DO NOT MODIFY
*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "b64Encode", ()=>b64Encode);
parcelHelpers.export(exports, "b64Decode", ()=>b64Decode);
parcelHelpers.export(exports, "replacer", ()=>replacer);
parcelHelpers.export(exports, "fetchReq", ()=>fetchReq);
/**
 * fetchStreamingRequest is able to handle grpc-gateway server side streaming call
 * it takes NotifyStreamEntityArrival that lets users respond to entity arrival during the call
 * all entities will be returned as an array after the call finishes.
 **/ parcelHelpers.export(exports, "fetchStreamingRequest", ()=>fetchStreamingRequest);
/**
 * Renders a deeply nested request payload into a string of URL search
 * parameters by first flattening the request payload and then removing keys
 * which are already present in the URL path.
 * @param  {RequestPayload} requestPayload
 * @param  {string[]} urlPathParams
 * @return {string}
 */ parcelHelpers.export(exports, "renderURLSearchParams", ()=>renderURLSearchParams);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = undefined && undefined.__rest || function(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
};
/**
 * base64 encoder and decoder
 * Copied and adapted from https://github.com/protobufjs/protobuf.js/blob/master/lib/base64/index.js
 */ // Base64 encoding table
const b64 = new Array(64);
// Base64 decoding table
const s64 = new Array(123);
// 65..90, 97..122, 48..57, 43, 47
for(let i = 0; i < 64;)s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
function b64Encode(buffer, start, end) {
    let parts = null;
    const chunk = [];
    let i = 0, j = 0, t; // temporary
    while(start < end){
        const b = buffer[start++];
        switch(j){
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1) chunk[i++] = 61;
    }
    if (parts) {
        if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
}
const invalidEncoding = "invalid encoding";
function b64Decode(s) {
    const buffer = [];
    let offset = 0;
    let j = 0, t; // temporary
    for(let i = 0; i < s.length;){
        let c = s.charCodeAt(i++);
        if (c === 61 && j > 1) break;
        if ((c = s64[c]) === undefined) throw Error(invalidEncoding);
        switch(j){
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1) throw Error(invalidEncoding);
    return new Uint8Array(buffer);
}
function b64Test(s) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s);
}
function replacer(key, value) {
    if (value && value.constructor === Uint8Array) return b64Encode(value, 0, value.length);
    return value;
}
function fetchReq(path, init) {
    const _a = init || {}, { pathPrefix } = _a, req = __rest(_a, [
        "pathPrefix"
    ]);
    const url = pathPrefix ? `${pathPrefix}${path}` : path;
    return fetch(url, req).then((r)=>r.json().then((body)=>{
            if (!r.ok) throw body;
            return body;
        }));
}
function fetchStreamingRequest(path, callback, init) {
    return __awaiter(this, void 0, void 0, function*() {
        const _a = init || {}, { pathPrefix } = _a, req = __rest(_a, [
            "pathPrefix"
        ]);
        const url = pathPrefix ? `${pathPrefix}${path}` : path;
        const result = yield fetch(url, req);
        // needs to use the .ok to check the status of HTTP status code
        // http other than 200 will not throw an error, instead the .ok will become false.
        // see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#
        if (!result.ok) {
            const resp = yield result.json();
            const errMsg = resp.error && resp.error.message ? resp.error.message : "";
            throw new Error(errMsg);
        }
        if (!result.body) throw new Error("response doesnt have a body");
        yield result.body.pipeThrough(new TextDecoderStream()).pipeThrough(getNewLineDelimitedJSONDecodingStream()).pipeTo(getNotifyEntityArrivalSink((e)=>{
            if (callback) callback(e);
        }));
        // wait for the streaming to finish and return the success respond
        return;
    });
}
/**
 * getNewLineDelimitedJSONDecodingStream returns a TransformStream that's able to handle new line delimited json stream content into parsed entities
 */ function getNewLineDelimitedJSONDecodingStream() {
    return new TransformStream({
        start (controller) {
            controller.buf = "";
            controller.pos = 0;
        },
        transform (chunk, controller) {
            if (controller.buf === undefined) controller.buf = "";
            if (controller.pos === undefined) controller.pos = 0;
            controller.buf += chunk;
            while(controller.pos < controller.buf.length)if (controller.buf[controller.pos] === "\n") {
                const line = controller.buf.substring(0, controller.pos);
                const response = JSON.parse(line);
                controller.enqueue(response.result);
                controller.buf = controller.buf.substring(controller.pos + 1);
                controller.pos = 0;
            } else ++controller.pos;
        }
    });
}
/**
 * getNotifyEntityArrivalSink takes the NotifyStreamEntityArrival callback and return
 * a sink that will call the callback on entity arrival
 * @param notifyCallback
 */ function getNotifyEntityArrivalSink(notifyCallback) {
    return new WritableStream({
        write (entity) {
            notifyCallback(entity);
        }
    });
}
/**
 * Checks if given value is a plain object
 * Logic copied and adapted from below source:
 * https://github.com/char0n/ramda-adjunct/blob/master/src/isPlainObj.js
 * @param  {unknown} value
 * @return {boolean}
 */ function isPlainObject(value) {
    const isObject = Object.prototype.toString.call(value).slice(8, -1) === "Object";
    const isObjLike = value !== null && isObject;
    if (!isObjLike || !isObject) return false;
    const proto = Object.getPrototypeOf(value);
    const hasObjectConstructor = typeof proto === "object" && proto.constructor === Object.prototype.constructor;
    return hasObjectConstructor;
}
/**
 * Checks if given value is of a primitive type
 * @param  {unknown} value
 * @return {boolean}
 */ function isPrimitive(value) {
    return [
        "string",
        "number",
        "boolean"
    ].some((t)=>typeof value === t);
}
/**
 * Checks if given primitive is zero-value
 * @param  {Primitive} value
 * @return {boolean}
 */ function isZeroValuePrimitive(value) {
    return value === false || value === 0 || value === "";
}
/**
 * Flattens a deeply nested request payload and returns an object
 * with only primitive values and non-empty array of primitive values
 * as per https://github.com/googleapis/googleapis/blob/master/google/api/http.proto
 * @param  {RequestPayload} requestPayload
 * @param  {String} path
 * @return {FlattenedRequestPayload>}
 */ function flattenRequestPayload(requestPayload, path = "") {
    return Object.keys(requestPayload).reduce((acc, key)=>{
        const value = requestPayload[key];
        const newPath = path ? [
            path,
            key
        ].join(".") : key;
        const isNonEmptyPrimitiveArray = Array.isArray(value) && value.every((v)=>isPrimitive(v)) && value.length > 0;
        const isNonZeroValuePrimitive = isPrimitive(value) && !isZeroValuePrimitive(value);
        let objectToMerge = {};
        if (isPlainObject(value)) objectToMerge = flattenRequestPayload(value, newPath);
        else if (isNonZeroValuePrimitive || isNonEmptyPrimitiveArray) objectToMerge = {
            [newPath]: value
        };
        return Object.assign(Object.assign({}, acc), objectToMerge);
    }, {});
}
function renderURLSearchParams(requestPayload, urlPathParams = []) {
    const flattenedRequestPayload = flattenRequestPayload(requestPayload);
    const urlSearchParams = Object.keys(flattenedRequestPayload).reduce((acc, key)=>{
        // key should not be present in the url path as a parameter
        const value = flattenedRequestPayload[key];
        if (urlPathParams.find((f)=>f === key)) return acc;
        return Array.isArray(value) ? [
            ...acc,
            ...value.map((m)=>[
                    key,
                    m.toString()
                ])
        ] : acc = [
            ...acc,
            [
                key,
                value.toString()
            ]
        ];
    }, []);
    return new URLSearchParams(urlSearchParams).toString();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"dTH2S":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "Token", ()=>Token);
parcelHelpers.export(exports, "AuthData", ()=>AuthData);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _publicKeyPb = require("../../message_contents/public_key.pb");
var _signaturePb = require("../../message_contents/signature.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.message_api.v1";
function createBaseToken() {
    return {
        identityKey: undefined,
        authDataBytes: new Uint8Array(),
        authDataSignature: undefined
    };
}
const Token = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.identityKey !== undefined) (0, _publicKeyPb.PublicKey).encode(message.identityKey, writer.uint32(10).fork()).ldelim();
        if (message.authDataBytes.length !== 0) writer.uint32(18).bytes(message.authDataBytes);
        if (message.authDataSignature !== undefined) (0, _signaturePb.Signature).encode(message.authDataSignature, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseToken();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.identityKey = (0, _publicKeyPb.PublicKey).decode(reader, reader.uint32());
                    break;
                case 2:
                    message.authDataBytes = reader.bytes();
                    break;
                case 3:
                    message.authDataSignature = (0, _signaturePb.Signature).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            identityKey: isSet(object.identityKey) ? (0, _publicKeyPb.PublicKey).fromJSON(object.identityKey) : undefined,
            authDataBytes: isSet(object.authDataBytes) ? bytesFromBase64(object.authDataBytes) : new Uint8Array(),
            authDataSignature: isSet(object.authDataSignature) ? (0, _signaturePb.Signature).fromJSON(object.authDataSignature) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.identityKey !== undefined && (obj.identityKey = message.identityKey ? (0, _publicKeyPb.PublicKey).toJSON(message.identityKey) : undefined);
        message.authDataBytes !== undefined && (obj.authDataBytes = base64FromBytes(message.authDataBytes !== undefined ? message.authDataBytes : new Uint8Array()));
        message.authDataSignature !== undefined && (obj.authDataSignature = message.authDataSignature ? (0, _signaturePb.Signature).toJSON(message.authDataSignature) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseToken();
        message.identityKey = object.identityKey !== undefined && object.identityKey !== null ? (0, _publicKeyPb.PublicKey).fromPartial(object.identityKey) : undefined;
        message.authDataBytes = (_a = object.authDataBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.authDataSignature = object.authDataSignature !== undefined && object.authDataSignature !== null ? (0, _signaturePb.Signature).fromPartial(object.authDataSignature) : undefined;
        return message;
    }
};
function createBaseAuthData() {
    return {
        walletAddr: "",
        createdNs: (0, _longDefault.default).UZERO
    };
}
const AuthData = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.walletAddr !== "") writer.uint32(10).string(message.walletAddr);
        if (!message.createdNs.isZero()) writer.uint32(16).uint64(message.createdNs);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuthData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.walletAddr = reader.string();
                    break;
                case 2:
                    message.createdNs = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            walletAddr: isSet(object.walletAddr) ? String(object.walletAddr) : "",
            createdNs: isSet(object.createdNs) ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO
        };
    },
    toJSON (message) {
        const obj = {};
        message.walletAddr !== undefined && (obj.walletAddr = message.walletAddr);
        message.createdNs !== undefined && (obj.createdNs = (message.createdNs || (0, _longDefault.default).UZERO).toString());
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseAuthData();
        message.walletAddr = (_a = object.walletAddr) !== null && _a !== void 0 ? _a : "";
        message.createdNs = object.createdNs !== undefined && object.createdNs !== null ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO;
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","../../message_contents/public_key.pb":"6Dba7","../../message_contents/signature.pb":"hvHvx","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3JDQT":[function(require,module,exports) {
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */ // WebAssembly optimizations to do native i64 multiplication and divide
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var wasm = null;
try {
    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        // \0asm
        0,
        97,
        115,
        109,
        // version 1
        1,
        0,
        0,
        0,
        // section "type"
        1,
        13,
        2,
        // 0, () => i32
        96,
        0,
        1,
        127,
        // 1, (i32, i32, i32, i32) => i32
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        // section "function"
        3,
        7,
        6,
        // 0, type 0
        0,
        // 1, type 1
        1,
        // 2, type 1
        1,
        // 3, type 1
        1,
        // 4, type 1
        1,
        // 5, type 1
        1,
        // section "global"
        6,
        6,
        1,
        // 0, "high", mutable i32
        127,
        1,
        65,
        0,
        11,
        // section "export"
        7,
        50,
        6,
        // 0, "mul"
        3,
        109,
        117,
        108,
        0,
        1,
        // 1, "div_s"
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        // 2, "div_u"
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        // 3, "rem_s"
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        // 4, "rem_u"
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        // 5, "get_high"
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        // section "code"
        10,
        191,
        1,
        6,
        // 0, "get_high"
        4,
        0,
        35,
        0,
        11,
        // 1, "mul"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 2, "div_s"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 3, "div_u"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 4, "rem_s"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 5, "rem_u"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
    ])), {}).exports;
} catch  {
// no wasm support :(
}
/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */ function Long(low, high, unsigned) {
    /**
   * The low 32 bits as a signed value.
   * @type {number}
   */ this.low = low | 0;
    /**
   * The high 32 bits as a signed value.
   * @type {number}
   */ this.high = high | 0;
    /**
   * Whether unsigned or not.
   * @type {boolean}
   */ this.unsigned = !!unsigned;
}
// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.
/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */ Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", {
    value: true
});
/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */ function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}
/**
 * @function
 * @param {*} value number
 * @returns {number}
 * @inner
 */ function ctz32(value) {
    var c = Math.clz32(value & -value);
    return value ? 31 - c : c;
}
/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */ Long.isLong = isLong;
/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */ var INT_CACHE = {};
/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */ var UINT_CACHE = {};
/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */ function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj) return cachedObj;
        }
        obj = fromBits(value, 0, true);
        if (cache) UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj) return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache) INT_CACHE[value] = obj;
        return obj;
    }
}
/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */ Long.fromInt = fromInt;
/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */ function fromNumber(value, unsigned) {
    if (isNaN(value)) return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0) return UZERO;
        if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
    }
    if (value < 0) return fromNumber(-value, unsigned).neg();
    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
}
/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */ Long.fromNumber = fromNumber;
/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */ function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}
/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */ Long.fromBits = fromBits;
/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */ var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)
/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */ function fromString(str, unsigned, radix) {
    if (str.length === 0) throw Error("empty string");
    if (typeof unsigned === "number") {
        // For goog.math.long compatibility
        radix = unsigned;
        unsigned = false;
    } else unsigned = !!unsigned;
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
    radix = radix || 10;
    if (radix < 2 || 36 < radix) throw RangeError("radix");
    var p;
    if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
    else if (p === 0) return fromString(str.substring(1), unsigned, radix).neg();
    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));
    var result = ZERO;
    for(var i = 0; i < str.length; i += 8){
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}
/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */ Long.fromString = fromString;
/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */ function fromValue(val, unsigned) {
    if (typeof val === "number") return fromNumber(val, unsigned);
    if (typeof val === "string") return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
}
/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|bigint|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */ Long.fromValue = fromValue;
// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.
/**
 * @type {number}
 * @const
 * @inner
 */ var TWO_PWR_16_DBL = 65536;
/**
 * @type {number}
 * @const
 * @inner
 */ var TWO_PWR_24_DBL = 16777216;
/**
 * @type {number}
 * @const
 * @inner
 */ var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
/**
 * @type {number}
 * @const
 * @inner
 */ var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
/**
 * @type {number}
 * @const
 * @inner
 */ var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
/**
 * @type {!Long}
 * @const
 * @inner
 */ var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
/**
 * @type {!Long}
 * @inner
 */ var ZERO = fromInt(0);
/**
 * Signed zero.
 * @type {!Long}
 */ Long.ZERO = ZERO;
/**
 * @type {!Long}
 * @inner
 */ var UZERO = fromInt(0, true);
/**
 * Unsigned zero.
 * @type {!Long}
 */ Long.UZERO = UZERO;
/**
 * @type {!Long}
 * @inner
 */ var ONE = fromInt(1);
/**
 * Signed one.
 * @type {!Long}
 */ Long.ONE = ONE;
/**
 * @type {!Long}
 * @inner
 */ var UONE = fromInt(1, true);
/**
 * Unsigned one.
 * @type {!Long}
 */ Long.UONE = UONE;
/**
 * @type {!Long}
 * @inner
 */ var NEG_ONE = fromInt(-1);
/**
 * Signed negative one.
 * @type {!Long}
 */ Long.NEG_ONE = NEG_ONE;
/**
 * @type {!Long}
 * @inner
 */ var MAX_VALUE = fromBits(-1, 2147483647, false);
/**
 * Maximum signed value.
 * @type {!Long}
 */ Long.MAX_VALUE = MAX_VALUE;
/**
 * @type {!Long}
 * @inner
 */ var MAX_UNSIGNED_VALUE = fromBits(-1, -1, true);
/**
 * Maximum unsigned value.
 * @type {!Long}
 */ Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
/**
 * @type {!Long}
 * @inner
 */ var MIN_VALUE = fromBits(0, -2147483648, false);
/**
 * Minimum signed value.
 * @type {!Long}
 */ Long.MIN_VALUE = MIN_VALUE;
/**
 * @alias Long.prototype
 * @inner
 */ var LongPrototype = Long.prototype;
/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @this {!Long}
 * @returns {number}
 */ LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};
/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @this {!Long}
 * @returns {number}
 */ LongPrototype.toNumber = function toNumber() {
    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
/**
 * Converts the Long to a string written in the specified radix.
 * @this {!Long}
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */ LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix) throw RangeError("radix");
    if (this.isZero()) return "0";
    if (this.isNegative()) {
        // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else return "-" + this.neg().toString(radix);
    }
    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
    var result = "";
    while(true){
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) return digits + result;
        else {
            while(digits.length < 6)digits = "0" + digits;
            result = "" + digits + result;
        }
    }
};
/**
 * Gets the high 32 bits as a signed integer.
 * @this {!Long}
 * @returns {number} Signed high bits
 */ LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};
/**
 * Gets the high 32 bits as an unsigned integer.
 * @this {!Long}
 * @returns {number} Unsigned high bits
 */ LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};
/**
 * Gets the low 32 bits as a signed integer.
 * @this {!Long}
 * @returns {number} Signed low bits
 */ LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};
/**
 * Gets the low 32 bits as an unsigned integer.
 * @this {!Long}
 * @returns {number} Unsigned low bits
 */ LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};
/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @this {!Long}
 * @returns {number}
 */ LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for(var bit = 31; bit > 0; bit--)if ((val & 1 << bit) != 0) break;
    return this.high != 0 ? bit + 33 : bit + 1;
};
/**
 * Tests if this Long can be safely represented as a JavaScript number.
 * @this {!Long}
 * @returns {boolean}
 */ LongPrototype.isSafeInteger = function isSafeInteger() {
    // 2^53-1 is the maximum safe value
    var top11Bits = this.high >> 21;
    // [0, 2^53-1]
    if (!top11Bits) return true;
    // > 2^53-1
    if (this.unsigned) return false;
    // [-2^53, -1] except -2^53
    return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
};
/**
 * Tests if this Long's value equals zero.
 * @this {!Long}
 * @returns {boolean}
 */ LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};
/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */ LongPrototype.eqz = LongPrototype.isZero;
/**
 * Tests if this Long's value is negative.
 * @this {!Long}
 * @returns {boolean}
 */ LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};
/**
 * Tests if this Long's value is positive or zero.
 * @this {!Long}
 * @returns {boolean}
 */ LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};
/**
 * Tests if this Long's value is odd.
 * @this {!Long}
 * @returns {boolean}
 */ LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};
/**
 * Tests if this Long's value is even.
 * @this {!Long}
 * @returns {boolean}
 */ LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};
/**
 * Tests if this Long's value equals the specified's.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.equals = function equals(other) {
    if (!isLong(other)) other = fromValue(other);
    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
    return this.high === other.high && this.low === other.low;
};
/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.eq = LongPrototype.equals;
/**
 * Tests if this Long's value differs from the specified's.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};
/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.neq = LongPrototype.notEquals;
/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.ne = LongPrototype.notEquals;
/**
 * Tests if this Long's value is less than the specified's.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};
/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.lt = LongPrototype.lessThan;
/**
 * Tests if this Long's value is less than or equal the specified's.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};
/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.lte = LongPrototype.lessThanOrEqual;
/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.le = LongPrototype.lessThanOrEqual;
/**
 * Tests if this Long's value is greater than the specified's.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};
/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.gt = LongPrototype.greaterThan;
/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};
/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.gte = LongPrototype.greaterThanOrEqual;
/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {boolean}
 */ LongPrototype.ge = LongPrototype.greaterThanOrEqual;
/**
 * Compares this Long's value with the specified's.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */ LongPrototype.compare = function compare(other) {
    if (!isLong(other)) other = fromValue(other);
    if (this.eq(other)) return 0;
    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
    if (thisNeg && !otherNeg) return -1;
    if (!thisNeg && otherNeg) return 1;
    // At this point the sign bits are the same
    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|bigint|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */ LongPrototype.comp = LongPrototype.compare;
/**
 * Negates this Long's value.
 * @this {!Long}
 * @returns {!Long} Negated Long
 */ LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
    return this.not().add(ONE);
};
/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */ LongPrototype.neg = LongPrototype.negate;
/**
 * Returns the sum of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|bigint|string} addend Addend
 * @returns {!Long} Sum
 */ LongPrototype.add = function add(addend) {
    if (!isLong(addend)) addend = fromValue(addend);
    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
    var a48 = this.high >>> 16;
    var a32 = this.high & 0xffff;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xffff;
    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xffff;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xffff;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xffff;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xffff;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xffff;
    c48 += a48 + b48;
    c48 &= 0xffff;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
/**
 * Returns the difference of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|bigint|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */ LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};
/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|bigint|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */ LongPrototype.sub = LongPrototype.subtract;
/**
 * Returns the product of this and the specified Long.
 * @this {!Long}
 * @param {!Long|number|bigint|string} multiplier Multiplier
 * @returns {!Long} Product
 */ LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero()) return this;
    if (!isLong(multiplier)) multiplier = fromValue(multiplier);
    // use wasm support if present
    if (wasm) {
        var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
        return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
    if (this.isNegative()) {
        if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
        else return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.
    var a48 = this.high >>> 16;
    var a32 = this.high & 0xffff;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xffff;
    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xffff;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xffff;
    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xffff;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xffff;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xffff;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xffff;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xffff;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xffff;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xffff;
    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|bigint|string} multiplier Multiplier
 * @returns {!Long} Product
 */ LongPrototype.mul = LongPrototype.multiply;
/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @this {!Long}
 * @param {!Long|number|bigint|string} divisor Divisor
 * @returns {!Long} Quotient
 */ LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor)) divisor = fromValue(divisor);
    if (divisor.isZero()) throw Error("division by zero");
    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) // be consistent with non-wasm code path
        return this;
        var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    if (this.isZero()) return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE)) return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) return divisor.isNegative() ? ONE : NEG_ONE;
                else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative()) return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned) divisor = divisor.toUnsigned();
        if (divisor.gt(this)) return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
        return UONE;
        res = UZERO;
    }
    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while(rem.gte(divisor)){
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
        approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while(approxRem.isNegative() || approxRem.gt(rem)){
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }
        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero()) approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};
/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|bigint|string} divisor Divisor
 * @returns {!Long} Quotient
 */ LongPrototype.div = LongPrototype.divide;
/**
 * Returns this Long modulo the specified.
 * @this {!Long}
 * @param {!Long|number|bigint|string} divisor Divisor
 * @returns {!Long} Remainder
 */ LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor)) divisor = fromValue(divisor);
    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm["get_high"](), this.unsigned);
    }
    return this.sub(this.div(divisor).mul(divisor));
};
/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|bigint|string} divisor Divisor
 * @returns {!Long} Remainder
 */ LongPrototype.mod = LongPrototype.modulo;
/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|bigint|string} divisor Divisor
 * @returns {!Long} Remainder
 */ LongPrototype.rem = LongPrototype.modulo;
/**
 * Returns the bitwise NOT of this Long.
 * @this {!Long}
 * @returns {!Long}
 */ LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};
/**
 * Returns count leading zeros of this Long.
 * @this {!Long}
 * @returns {!number}
 */ LongPrototype.countLeadingZeros = function countLeadingZeros() {
    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
/**
 * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
 * @function
 * @param {!Long}
 * @returns {!number}
 */ LongPrototype.clz = LongPrototype.countLeadingZeros;
/**
 * Returns count trailing zeros of this Long.
 * @this {!Long}
 * @returns {!number}
 */ LongPrototype.countTrailingZeros = function countTrailingZeros() {
    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};
/**
 * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
 * @function
 * @param {!Long}
 * @returns {!number}
 */ LongPrototype.ctz = LongPrototype.countTrailingZeros;
/**
 * Returns the bitwise AND of this Long and the specified.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other Long
 * @returns {!Long}
 */ LongPrototype.and = function and(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
/**
 * Returns the bitwise OR of this Long and the specified.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other Long
 * @returns {!Long}
 */ LongPrototype.or = function or(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
/**
 * Returns the bitwise XOR of this Long and the given one.
 * @this {!Long}
 * @param {!Long|number|bigint|string} other Other Long
 * @returns {!Long}
 */ LongPrototype.xor = function xor(other) {
    if (!isLong(other)) other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */ LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
    else return fromBits(0, this.low << numBits - 32, this.unsigned);
};
/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */ LongPrototype.shl = LongPrototype.shiftLeft;
/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */ LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
    else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */ LongPrototype.shr = LongPrototype.shiftRight;
/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */ LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
};
/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */ LongPrototype.shru = LongPrototype.shiftRightUnsigned;
/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */ LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
/**
 * Returns this Long with bits rotated to the left by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */ LongPrototype.rotateLeft = function rotateLeft(numBits) {
    var b;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
    }
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
};
/**
 * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */ LongPrototype.rotl = LongPrototype.rotateLeft;
/**
 * Returns this Long with bits rotated to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */ LongPrototype.rotateRight = function rotateRight(numBits) {
    var b;
    if (isLong(numBits)) numBits = numBits.toInt();
    if ((numBits &= 63) === 0) return this;
    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
    if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
    }
    numBits -= 32;
    b = 32 - numBits;
    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
};
/**
 * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */ LongPrototype.rotr = LongPrototype.rotateRight;
/**
 * Converts this Long to signed.
 * @this {!Long}
 * @returns {!Long} Signed long
 */ LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned) return this;
    return fromBits(this.low, this.high, false);
};
/**
 * Converts this Long to unsigned.
 * @this {!Long}
 * @returns {!Long} Unsigned long
 */ LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned) return this;
    return fromBits(this.low, this.high, true);
};
/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @this {!Long}
 * @returns {!Array.<number>} Byte representation
 */ LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};
/**
 * Converts this Long to its little endian byte representation.
 * @this {!Long}
 * @returns {!Array.<number>} Little endian byte representation
 */ LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high, lo = this.low;
    return [
        lo & 0xff,
        lo >>> 8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24,
        hi & 0xff,
        hi >>> 8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};
/**
 * Converts this Long to its big endian byte representation.
 * @this {!Long}
 * @returns {!Array.<number>} Big endian byte representation
 */ LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high, lo = this.low;
    return [
        hi >>> 24,
        hi >>> 16 & 0xff,
        hi >>> 8 & 0xff,
        hi & 0xff,
        lo >>> 24,
        lo >>> 16 & 0xff,
        lo >>> 8 & 0xff,
        lo & 0xff
    ];
};
/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */ Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};
/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */ Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
};
/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */ Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
};
// Support conversion to/from BigInt where available
if (typeof BigInt === "function") {
    /**
   * Returns a Long representing the given big integer.
   * @function
   * @param {number} value The big integer value
   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
   * @returns {!Long} The corresponding Long value
   */ Long.fromBigInt = function fromBigInt1(value, unsigned) {
        var lowBits = Number(BigInt.asIntN(32, value));
        var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
        return fromBits(lowBits, highBits, unsigned);
    };
    // Override
    Long.fromValue = function fromValueWithBigInt(value, unsigned) {
        if (typeof value === "bigint") return fromBigInt(value, unsigned);
        return fromValue(value, unsigned);
    };
    /**
   * Converts the Long to its big integer representation.
   * @this {!Long}
   * @returns {bigint}
   */ LongPrototype.toBigInt = function toBigInt() {
        var lowBigInt = BigInt(this.low >>> 0);
        var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
        return highBigInt << BigInt(32) | lowBigInt;
    };
}
exports.default = Long;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Dba7":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "UnsignedPublicKey", ()=>UnsignedPublicKey);
parcelHelpers.export(exports, "UnsignedPublicKey_Secp256k1Uncompressed", ()=>UnsignedPublicKey_Secp256k1Uncompressed);
parcelHelpers.export(exports, "SignedPublicKey", ()=>SignedPublicKey);
parcelHelpers.export(exports, "SignedPublicKeyBundle", ()=>SignedPublicKeyBundle);
parcelHelpers.export(exports, "PublicKey", ()=>PublicKey);
parcelHelpers.export(exports, "PublicKey_Secp256k1Uncompressed", ()=>PublicKey_Secp256k1Uncompressed);
parcelHelpers.export(exports, "PublicKeyBundle", ()=>PublicKeyBundle);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _signaturePb = require("./signature.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.message_contents";
function createBaseUnsignedPublicKey() {
    return {
        createdNs: (0, _longDefault.default).UZERO,
        secp256k1Uncompressed: undefined
    };
}
const UnsignedPublicKey = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (!message.createdNs.isZero()) writer.uint32(8).uint64(message.createdNs);
        if (message.secp256k1Uncompressed !== undefined) UnsignedPublicKey_Secp256k1Uncompressed.encode(message.secp256k1Uncompressed, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnsignedPublicKey();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.createdNs = reader.uint64();
                    break;
                case 3:
                    message.secp256k1Uncompressed = UnsignedPublicKey_Secp256k1Uncompressed.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            createdNs: isSet(object.createdNs) ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO,
            secp256k1Uncompressed: isSet(object.secp256k1Uncompressed) ? UnsignedPublicKey_Secp256k1Uncompressed.fromJSON(object.secp256k1Uncompressed) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.createdNs !== undefined && (obj.createdNs = (message.createdNs || (0, _longDefault.default).UZERO).toString());
        message.secp256k1Uncompressed !== undefined && (obj.secp256k1Uncompressed = message.secp256k1Uncompressed ? UnsignedPublicKey_Secp256k1Uncompressed.toJSON(message.secp256k1Uncompressed) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseUnsignedPublicKey();
        message.createdNs = object.createdNs !== undefined && object.createdNs !== null ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO;
        message.secp256k1Uncompressed = object.secp256k1Uncompressed !== undefined && object.secp256k1Uncompressed !== null ? UnsignedPublicKey_Secp256k1Uncompressed.fromPartial(object.secp256k1Uncompressed) : undefined;
        return message;
    }
};
function createBaseUnsignedPublicKey_Secp256k1Uncompressed() {
    return {
        bytes: new Uint8Array()
    };
}
const UnsignedPublicKey_Secp256k1Uncompressed = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.bytes.length !== 0) writer.uint32(10).bytes(message.bytes);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnsignedPublicKey_Secp256k1Uncompressed();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.bytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.bytes !== undefined && (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseUnsignedPublicKey_Secp256k1Uncompressed();
        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseSignedPublicKey() {
    return {
        keyBytes: new Uint8Array(),
        signature: undefined
    };
}
const SignedPublicKey = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.keyBytes.length !== 0) writer.uint32(10).bytes(message.keyBytes);
        if (message.signature !== undefined) (0, _signaturePb.Signature).encode(message.signature, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignedPublicKey();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyBytes = reader.bytes();
                    break;
                case 2:
                    message.signature = (0, _signaturePb.Signature).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            keyBytes: isSet(object.keyBytes) ? bytesFromBase64(object.keyBytes) : new Uint8Array(),
            signature: isSet(object.signature) ? (0, _signaturePb.Signature).fromJSON(object.signature) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.keyBytes !== undefined && (obj.keyBytes = base64FromBytes(message.keyBytes !== undefined ? message.keyBytes : new Uint8Array()));
        message.signature !== undefined && (obj.signature = message.signature ? (0, _signaturePb.Signature).toJSON(message.signature) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSignedPublicKey();
        message.keyBytes = (_a = object.keyBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.signature = object.signature !== undefined && object.signature !== null ? (0, _signaturePb.Signature).fromPartial(object.signature) : undefined;
        return message;
    }
};
function createBaseSignedPublicKeyBundle() {
    return {
        identityKey: undefined,
        preKey: undefined
    };
}
const SignedPublicKeyBundle = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.identityKey !== undefined) SignedPublicKey.encode(message.identityKey, writer.uint32(10).fork()).ldelim();
        if (message.preKey !== undefined) SignedPublicKey.encode(message.preKey, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignedPublicKeyBundle();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.identityKey = SignedPublicKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.preKey = SignedPublicKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            identityKey: isSet(object.identityKey) ? SignedPublicKey.fromJSON(object.identityKey) : undefined,
            preKey: isSet(object.preKey) ? SignedPublicKey.fromJSON(object.preKey) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.identityKey !== undefined && (obj.identityKey = message.identityKey ? SignedPublicKey.toJSON(message.identityKey) : undefined);
        message.preKey !== undefined && (obj.preKey = message.preKey ? SignedPublicKey.toJSON(message.preKey) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSignedPublicKeyBundle();
        message.identityKey = object.identityKey !== undefined && object.identityKey !== null ? SignedPublicKey.fromPartial(object.identityKey) : undefined;
        message.preKey = object.preKey !== undefined && object.preKey !== null ? SignedPublicKey.fromPartial(object.preKey) : undefined;
        return message;
    }
};
function createBasePublicKey() {
    return {
        timestamp: (0, _longDefault.default).UZERO,
        signature: undefined,
        secp256k1Uncompressed: undefined
    };
}
const PublicKey = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (!message.timestamp.isZero()) writer.uint32(8).uint64(message.timestamp);
        if (message.signature !== undefined) (0, _signaturePb.Signature).encode(message.signature, writer.uint32(18).fork()).ldelim();
        if (message.secp256k1Uncompressed !== undefined) PublicKey_Secp256k1Uncompressed.encode(message.secp256k1Uncompressed, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePublicKey();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.timestamp = reader.uint64();
                    break;
                case 2:
                    message.signature = (0, _signaturePb.Signature).decode(reader, reader.uint32());
                    break;
                case 3:
                    message.secp256k1Uncompressed = PublicKey_Secp256k1Uncompressed.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            timestamp: isSet(object.timestamp) ? (0, _longDefault.default).fromValue(object.timestamp) : (0, _longDefault.default).UZERO,
            signature: isSet(object.signature) ? (0, _signaturePb.Signature).fromJSON(object.signature) : undefined,
            secp256k1Uncompressed: isSet(object.secp256k1Uncompressed) ? PublicKey_Secp256k1Uncompressed.fromJSON(object.secp256k1Uncompressed) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.timestamp !== undefined && (obj.timestamp = (message.timestamp || (0, _longDefault.default).UZERO).toString());
        message.signature !== undefined && (obj.signature = message.signature ? (0, _signaturePb.Signature).toJSON(message.signature) : undefined);
        message.secp256k1Uncompressed !== undefined && (obj.secp256k1Uncompressed = message.secp256k1Uncompressed ? PublicKey_Secp256k1Uncompressed.toJSON(message.secp256k1Uncompressed) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePublicKey();
        message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? (0, _longDefault.default).fromValue(object.timestamp) : (0, _longDefault.default).UZERO;
        message.signature = object.signature !== undefined && object.signature !== null ? (0, _signaturePb.Signature).fromPartial(object.signature) : undefined;
        message.secp256k1Uncompressed = object.secp256k1Uncompressed !== undefined && object.secp256k1Uncompressed !== null ? PublicKey_Secp256k1Uncompressed.fromPartial(object.secp256k1Uncompressed) : undefined;
        return message;
    }
};
function createBasePublicKey_Secp256k1Uncompressed() {
    return {
        bytes: new Uint8Array()
    };
}
const PublicKey_Secp256k1Uncompressed = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.bytes.length !== 0) writer.uint32(10).bytes(message.bytes);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePublicKey_Secp256k1Uncompressed();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.bytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.bytes !== undefined && (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBasePublicKey_Secp256k1Uncompressed();
        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBasePublicKeyBundle() {
    return {
        identityKey: undefined,
        preKey: undefined
    };
}
const PublicKeyBundle = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.identityKey !== undefined) PublicKey.encode(message.identityKey, writer.uint32(10).fork()).ldelim();
        if (message.preKey !== undefined) PublicKey.encode(message.preKey, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePublicKeyBundle();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.identityKey = PublicKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.preKey = PublicKey.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            identityKey: isSet(object.identityKey) ? PublicKey.fromJSON(object.identityKey) : undefined,
            preKey: isSet(object.preKey) ? PublicKey.fromJSON(object.preKey) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.identityKey !== undefined && (obj.identityKey = message.identityKey ? PublicKey.toJSON(message.identityKey) : undefined);
        message.preKey !== undefined && (obj.preKey = message.preKey ? PublicKey.toJSON(message.preKey) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePublicKeyBundle();
        message.identityKey = object.identityKey !== undefined && object.identityKey !== null ? PublicKey.fromPartial(object.identityKey) : undefined;
        message.preKey = object.preKey !== undefined && object.preKey !== null ? PublicKey.fromPartial(object.preKey) : undefined;
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","./signature.pb":"hvHvx","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hvHvx":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "Signature", ()=>Signature);
parcelHelpers.export(exports, "Signature_ECDSACompact", ()=>Signature_ECDSACompact);
parcelHelpers.export(exports, "Signature_WalletECDSACompact", ()=>Signature_WalletECDSACompact);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.message_contents";
function createBaseSignature() {
    return {
        ecdsaCompact: undefined,
        walletEcdsaCompact: undefined
    };
}
const Signature = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.ecdsaCompact !== undefined) Signature_ECDSACompact.encode(message.ecdsaCompact, writer.uint32(10).fork()).ldelim();
        if (message.walletEcdsaCompact !== undefined) Signature_WalletECDSACompact.encode(message.walletEcdsaCompact, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignature();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.ecdsaCompact = Signature_ECDSACompact.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.walletEcdsaCompact = Signature_WalletECDSACompact.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            ecdsaCompact: isSet(object.ecdsaCompact) ? Signature_ECDSACompact.fromJSON(object.ecdsaCompact) : undefined,
            walletEcdsaCompact: isSet(object.walletEcdsaCompact) ? Signature_WalletECDSACompact.fromJSON(object.walletEcdsaCompact) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.ecdsaCompact !== undefined && (obj.ecdsaCompact = message.ecdsaCompact ? Signature_ECDSACompact.toJSON(message.ecdsaCompact) : undefined);
        message.walletEcdsaCompact !== undefined && (obj.walletEcdsaCompact = message.walletEcdsaCompact ? Signature_WalletECDSACompact.toJSON(message.walletEcdsaCompact) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSignature();
        message.ecdsaCompact = object.ecdsaCompact !== undefined && object.ecdsaCompact !== null ? Signature_ECDSACompact.fromPartial(object.ecdsaCompact) : undefined;
        message.walletEcdsaCompact = object.walletEcdsaCompact !== undefined && object.walletEcdsaCompact !== null ? Signature_WalletECDSACompact.fromPartial(object.walletEcdsaCompact) : undefined;
        return message;
    }
};
function createBaseSignature_ECDSACompact() {
    return {
        bytes: new Uint8Array(),
        recovery: 0
    };
}
const Signature_ECDSACompact = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.bytes.length !== 0) writer.uint32(10).bytes(message.bytes);
        if (message.recovery !== 0) writer.uint32(16).uint32(message.recovery);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignature_ECDSACompact();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.bytes = reader.bytes();
                    break;
                case 2:
                    message.recovery = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : new Uint8Array(),
            recovery: isSet(object.recovery) ? Number(object.recovery) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        message.bytes !== undefined && (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));
        message.recovery !== undefined && (obj.recovery = Math.round(message.recovery));
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseSignature_ECDSACompact();
        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.recovery = (_b = object.recovery) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseSignature_WalletECDSACompact() {
    return {
        bytes: new Uint8Array(),
        recovery: 0
    };
}
const Signature_WalletECDSACompact = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.bytes.length !== 0) writer.uint32(10).bytes(message.bytes);
        if (message.recovery !== 0) writer.uint32(16).uint32(message.recovery);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignature_WalletECDSACompact();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.bytes = reader.bytes();
                    break;
                case 2:
                    message.recovery = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : new Uint8Array(),
            recovery: isSet(object.recovery) ? Number(object.recovery) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        message.bytes !== undefined && (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));
        message.recovery !== undefined && (obj.recovery = Math.round(message.recovery));
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseSignature_WalletECDSACompact();
        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.recovery = (_b = object.recovery) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kgguT":[function(require,module,exports) {
// minimal library entry point.
"use strict";
module.exports = require("53502ce49364a9a0");

},{"53502ce49364a9a0":"kFkOY"}],"kFkOY":[function(require,module,exports) {
"use strict";
var protobuf = exports;
/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */ protobuf.build = "minimal";
// Serialization
protobuf.Writer = require("123b8c1671ce76b7");
protobuf.BufferWriter = require("5e89240d6b4d6c84");
protobuf.Reader = require("7e7524d57b18d0d0");
protobuf.BufferReader = require("443298fa9a162adc");
// Utility
protobuf.util = require("682ea4beebbab45d");
protobuf.rpc = require("862afecd43193828");
protobuf.roots = require("14faeab02aebb66b");
protobuf.configure = configure;
/* istanbul ignore next */ /**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */ function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}
// Set up buffer utility according to the environment
configure();

},{"123b8c1671ce76b7":"boWmp","5e89240d6b4d6c84":"gIB4S","7e7524d57b18d0d0":"bN2lE","443298fa9a162adc":"1b0Ms","682ea4beebbab45d":"4HDe1","862afecd43193828":"eRwa1","14faeab02aebb66b":"bJQDp"}],"boWmp":[function(require,module,exports) {
"use strict";
module.exports = Writer;
var util = require("5c785c60b384e6c3");
var BufferWriter; // cyclic
var LongBits = util.LongBits, base64 = util.base64, utf8 = util.utf8;
/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */ function Op(fn, len, val) {
    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */ this.fn = fn;
    /**
     * Value byte length.
     * @type {number}
     */ this.len = len;
    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */ this.next = undefined;
    /**
     * Value to write.
     * @type {*}
     */ this.val = val; // type varies
}
/* istanbul ignore next */ function noop() {} // eslint-disable-line no-empty-function
/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */ function State(writer) {
    /**
     * Current head.
     * @type {Writer.Op}
     */ this.head = writer.head;
    /**
     * Current tail.
     * @type {Writer.Op}
     */ this.tail = writer.tail;
    /**
     * Current buffer length.
     * @type {number}
     */ this.len = writer.len;
    /**
     * Next state.
     * @type {State|null}
     */ this.next = writer.states;
}
/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */ function Writer() {
    /**
     * Current length.
     * @type {number}
     */ this.len = 0;
    /**
     * Operations head.
     * @type {Object}
     */ this.head = new Op(noop, 0, 0);
    /**
     * Operations tail
     * @type {Object}
     */ this.tail = this.head;
    /**
     * Linked forked states.
     * @type {Object|null}
     */ this.states = null;
// When a value is written, the writer calculates its byte length and puts it into a linked
// list of operations to perform when finish() is called. This both allows us to allocate
// buffers of the exact required size and reduces the amount of work we have to do compared
// to first calculating over objects and then encoding over objects. In our case, the encoding
// part is just a linked list walk calling operations with already prepared values.
}
var create = function create() {
    return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    } : function create_array() {
        return new Writer();
    };
};
/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */ Writer.create = create();
/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */ Writer.alloc = function alloc(size) {
    return new util.Array(size);
};
// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */ if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */ Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};
function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}
function writeVarint32(val, buf, pos) {
    while(val > 127){
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}
/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */ function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
};
/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
     : this.uint32(value);
};
/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};
function writeVarint64(val, buf, pos) {
    while(val.hi){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while(val.lo > 127){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}
/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};
/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.int64 = Writer.prototype.uint64;
/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};
/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};
function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
}
/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};
/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.sfixed32 = Writer.prototype.fixed32;
/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};
/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.sfixed64 = Writer.prototype.fixed64;
/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};
/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};
var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos); // also works for plain array values
} : function writeBytes_for(val, buf, pos) {
    for(var i = 0; i < val.length; ++i)buf[pos + i] = val[i];
};
/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */ Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len) return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};
/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
};
/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */ Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};
/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */ Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
    }
    return this;
};
/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */ Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};
/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */ Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while(head){
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};
Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};

},{"5c785c60b384e6c3":"4HDe1"}],"4HDe1":[function(require,module,exports) {
var global = arguments[3];
"use strict";
var util = exports;
// used to return a Promise where callback is omitted
util.asPromise = require("217e30ba36d0c075");
// converts to / from base64 encoded strings
util.base64 = require("140216d783bbc015");
// base class of rpc.Service
util.EventEmitter = require("78776c045df9e77b");
// float handling accross browsers
util.float = require("392006759dba32fb");
// requires modules optionally and hides the call from bundlers
util.inquire = require("ac14d008f0aa6436");
// converts to / from utf8 encoded strings
util.utf8 = require("298ebb5f36c5d25a");
// provides a node-like buffer pool in the browser
util.pool = require("dc7a35661f9f9275");
// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("94b513d9f4cac968");
/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */ util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */ util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || this; // eslint-disable-line no-invalid-this
/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */ util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes
/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */ util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes
/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */ util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};
/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */ util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};
/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */ util.isObject = function isObject(value) {
    return value && typeof value === "object";
};
/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */ util.isset = /**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */ util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};
/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */ /**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */ util.Buffer = function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */ return null;
    }
}();
// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;
// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;
/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */ util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */ return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
};
/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */ util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */  : Array;
/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */ /**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */ util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long || /* istanbul ignore next */ util.global.Long || util.inquire("long");
/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */ util.key2Re = /^true|false|0|1$/;
/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */ util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */ util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */ util.longToHash = function longToHash(value) {
    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
};
/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */ util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};
/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */ function merge(dst, src, ifNotSet) {
    for(var keys = Object.keys(src), i = 0; i < keys.length; ++i)if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];
    return dst;
}
util.merge = merge;
/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */ util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};
/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */ function newError(name) {
    function CustomError(message, properties) {
        if (!(this instanceof CustomError)) return new CustomError(message, properties);
        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function
        Object.defineProperty(this, "message", {
            get: function() {
                return message;
            }
        });
        /* istanbul ignore next */ if (Error.captureStackTrace) Error.captureStackTrace(this, CustomError);
        else Object.defineProperty(this, "stack", {
            value: new Error().stack || ""
        });
        if (properties) merge(this, properties);
    }
    CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true
        },
        name: {
            get: function get() {
                return name;
            },
            set: undefined,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true
        },
        toString: {
            value: function value() {
                return this.name + ": " + this.message;
            },
            writable: true,
            enumerable: false,
            configurable: true
        }
    });
    return CustomError;
}
util.newError = newError;
/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */ util.ProtocolError = newError("ProtocolError");
/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */ /**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */ /**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */ util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for(var i = 0; i < fieldNames.length; ++i)fieldMap[fieldNames[i]] = 1;
    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */ return function() {
        for(var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];
    };
};
/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */ /**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */ util.oneOfSetter = function setOneOf(fieldNames) {
    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */ return function(name) {
        for(var i = 0; i < fieldNames.length; ++i)if (fieldNames[i] !== name) delete this[fieldNames[i]];
    };
};
/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */ util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};
// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */ if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */ function Buffer_from(value, encoding) {
        return new Buffer(value, encoding);
    };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */ function Buffer_allocUnsafe(size) {
        return new Buffer(size);
    };
};

},{"217e30ba36d0c075":"gv7US","140216d783bbc015":"aOjmr","78776c045df9e77b":"lWFnX","392006759dba32fb":"gifXM","ac14d008f0aa6436":"fon4w","298ebb5f36c5d25a":"8DJTf","dc7a35661f9f9275":"fadtm","94b513d9f4cac968":"c4DvK"}],"gv7US":[function(require,module,exports) {
"use strict";
module.exports = asPromise;
/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */ /**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */ function asPromise(fn, ctx /*, varargs */ ) {
    var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
    while(index < arguments.length)params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err /*, varargs */ ) {
            if (pending) {
                pending = false;
                if (err) reject(err);
                else {
                    var params = new Array(arguments.length - 1), offset = 0;
                    while(offset < params.length)params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],"aOjmr":[function(require,module,exports) {
"use strict";
/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */ var base64 = exports;
/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */ base64.length = function length(string) {
    var p = string.length;
    if (!p) return 0;
    var n = 0;
    while(--p % 4 > 1 && string.charAt(p) === "=")++n;
    return Math.ceil(string.length * 3) / 4 - n;
};
// Base64 encoding table
var b64 = new Array(64);
// Base64 decoding table
var s64 = new Array(123);
// 65..90, 97..122, 48..57, 43, 47
for(var i = 0; i < 64;)s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */ base64.encode = function encode(buffer, start, end) {
    var parts = null, chunk = [];
    var i = 0, j = 0, t; // temporary
    while(start < end){
        var b = buffer[start++];
        switch(j){
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1) chunk[i++] = 61;
    }
    if (parts) {
        if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};
var invalidEncoding = "invalid encoding";
/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */ base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, t; // temporary
    for(var i = 0; i < string.length;){
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1) break;
        if ((c = s64[c]) === undefined) throw Error(invalidEncoding);
        switch(j){
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1) throw Error(invalidEncoding);
    return offset - start;
};
/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */ base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],"lWFnX":[function(require,module,exports) {
"use strict";
module.exports = EventEmitter;
/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */ function EventEmitter() {
    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */ this._listeners = {};
}
/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn: fn,
        ctx: ctx || this
    });
    return this;
};
/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined) this._listeners = {};
    else if (fn === undefined) this._listeners[evt] = [];
    else {
        var listeners = this._listeners[evt];
        for(var i = 0; i < listeners.length;)if (listeners[i].fn === fn) listeners.splice(i, 1);
        else ++i;
    }
    return this;
};
/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [], i = 1;
        for(; i < arguments.length;)args.push(arguments[i++]);
        for(i = 0; i < listeners.length;)listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],"gifXM":[function(require,module,exports) {
"use strict";
module.exports = factory(factory);
/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */ /**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ // Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {
    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([
            -0
        ]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }
        /* istanbul ignore next */ exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */ exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }
        /* istanbul ignore next */ exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */ exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
    // float: ieee754
    })();
    else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign) val = -val;
            if (val === 0) writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val)) writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }
        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
             ? sign * 1.401298464324817e-45 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([
            -0
        ]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }
        /* istanbul ignore next */ exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */ exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }
        /* istanbul ignore next */ exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */ exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
    // double: ieee754
    })();
    else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign) val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) {
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) {
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024) exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }
        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
             ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
    return exports;
}
// uint helpers
function writeUintLE(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
}
function writeUintBE(val, buf, pos) {
    buf[pos] = val >>> 24;
    buf[pos + 1] = val >>> 16 & 255;
    buf[pos + 2] = val >>> 8 & 255;
    buf[pos + 3] = val & 255;
}
function readUintLE(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
}
function readUintBE(buf, pos) {
    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
}

},{}],"fon4w":[function(require,module,exports) {
"use strict";
module.exports = inquire;
/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */ function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length)) return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],"8DJTf":[function(require,module,exports) {
"use strict";
/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */ var utf8 = exports;
/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */ utf8.length = function utf8_length(string) {
    var len = 0, c = 0;
    for(var i = 0; i < string.length; ++i){
        c = string.charCodeAt(i);
        if (c < 128) len += 1;
        else if (c < 2048) len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else len += 3;
    }
    return len;
};
/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */ utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1) return "";
    var parts = null, chunk = [], i = 0, t; // temporary
    while(start < end){
        t = buffer[start++];
        if (t < 128) chunk[i++] = t;
        else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};
/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */ utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset, c1, c2; // character 2
    for(var i = 0; i < string.length; ++i){
        c1 = string.charCodeAt(i);
        if (c1 < 128) buffer[offset++] = c1;
        else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6 | 192;
            buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18 | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12 | 224;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        }
    }
    return offset - start;
};

},{}],"fadtm":[function(require,module,exports) {
"use strict";
module.exports = pool;
/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */ /**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */ /**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */ function pool(alloc, slice, size) {
    var SIZE = size || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX) return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],"c4DvK":[function(require,module,exports) {
"use strict";
module.exports = LongBits;
var util = require("670bae0bb8fddc8f");
/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */ function LongBits(lo, hi) {
    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.
    /**
     * Low bits.
     * @type {number}
     */ this.lo = lo >>> 0;
    /**
     * High bits.
     * @type {number}
     */ this.hi = hi >>> 0;
}
/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */ var zero = LongBits.zero = new LongBits(0, 0);
zero.toNumber = function() {
    return 0;
};
zero.zzEncode = zero.zzDecode = function() {
    return this;
};
zero.length = function() {
    return 1;
};
/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */ var zeroHash = LongBits.zeroHash = "\x00\x00\x00\x00\x00\x00\x00\x00";
/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */ LongBits.fromNumber = function fromNumber(value) {
    if (value === 0) return zero;
    var sign = value < 0;
    if (sign) value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295) hi = 0;
        }
    }
    return new LongBits(lo, hi);
};
/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */ LongBits.from = function from(value) {
    if (typeof value === "number") return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */ if (util.Long) value = util.Long.fromString(value);
        else return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};
/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */ LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo) hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};
/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */ LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {
        low: this.lo | 0,
        high: this.hi | 0,
        unsigned: Boolean(unsigned)
    };
};
var charCodeAt = String.prototype.charCodeAt;
/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */ LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash) return zero;
    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
};
/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */ LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
};
/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */ LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
};
/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */ LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
};
/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */ LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
};

},{"670bae0bb8fddc8f":"4HDe1"}],"gIB4S":[function(require,module,exports) {
"use strict";
module.exports = BufferWriter;
// extends Writer
var Writer = require("e9b2a43e398901ec");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util = require("8ed11af2c26d797d");
/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */ function BufferWriter() {
    Writer.call(this);
}
BufferWriter._configure = function() {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */ BufferWriter.alloc = util._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
    // also works for plain array values
    } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) val.copy(buf, pos, 0, val.length);
        else for(var i = 0; i < val.length;)buf[pos++] = val[i++];
    };
};
/**
 * @override
 */ BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value)) value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len) this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};
function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) util.utf8.write(val, buf, pos);
    else if (buf.utf8Write) buf.utf8Write(val, pos);
    else buf.write(val, pos);
}
/**
 * @override
 */ BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len) this._push(writeStringBuffer, len, value);
    return this;
};
/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */ BufferWriter._configure();

},{"e9b2a43e398901ec":"boWmp","8ed11af2c26d797d":"4HDe1"}],"bN2lE":[function(require,module,exports) {
"use strict";
module.exports = Reader;
var util = require("9f80034b34dad30b");
var BufferReader; // cyclic
var LongBits = util.LongBits, utf8 = util.utf8;
/* istanbul ignore next */ function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}
/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */ function Reader(buffer) {
    /**
     * Read buffer.
     * @type {Uint8Array}
     */ this.buf = buffer;
    /**
     * Read buffer position.
     * @type {number}
     */ this.pos = 0;
    /**
     * Read buffer length.
     * @type {number}
     */ this.len = buffer.length;
}
var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
    if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);
    throw Error("illegal buffer");
} : function create_array(buffer) {
    if (Array.isArray(buffer)) return new Reader(buffer);
    throw Error("illegal buffer");
};
var create = function create() {
    return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer) : create_array(buffer);
        })(buffer);
    } : create_array;
};
/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */ Reader.create = create();
Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;
/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.uint32 = function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        /* istanbul ignore if */ if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
}();
/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */ Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};
/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */ Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};
/* eslint-disable no-invalid-this */ function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
        for(; i < 4; ++i){
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128) return bits;
        i = 0;
    } else {
        for(; i < 3; ++i){
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) for(; i < 5; ++i){
        // 6th..10th
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128) return bits;
    }
    else for(; i < 5; ++i){
        /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
        // 6th..10th
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128) return bits;
    }
    /* istanbul ignore next */ throw Error("invalid varint encoding");
}
/* eslint-enable no-invalid-this */ /**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */ Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};
function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
}
/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */ Reader.prototype.fixed32 = function read_fixed32() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
};
/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */ Reader.prototype.sfixed32 = function read_sfixed32() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
};
/* eslint-disable no-invalid-this */ function readFixed64() {
    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
/* eslint-enable no-invalid-this */ /**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.float = function read_float() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};
/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.double = function read_double() {
    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);
    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};
/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */ Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    /* istanbul ignore if */ if (end > this.len) throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf)) return this.buf.slice(start, end);
    if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, start, end);
};
/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */ Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};
/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */ Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */ if (this.pos + length > this.len) throw indexOutOfRange(this, length);
        this.pos += length;
    } else do {
        /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
    }while (this.buf[this.pos++] & 128);
    return this;
};
/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */ Reader.prototype.skipType = function(wireType) {
    switch(wireType){
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while((wireType = this.uint32() & 7) !== 4)this.skipType(wireType);
            break;
        case 5:
            this.skip(4);
            break;
        /* istanbul ignore next */ default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};
Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();
    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {
        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }
    });
};

},{"9f80034b34dad30b":"4HDe1"}],"1b0Ms":[function(require,module,exports) {
"use strict";
module.exports = BufferReader;
// extends Reader
var Reader = require("808dd763e7b39931");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util = require("fcb9b16130e5c787");
/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */ function BufferReader(buffer) {
    Reader.call(this, buffer);
/**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */ }
BufferReader._configure = function() {
    /* istanbul ignore else */ if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;
};
/**
 * @override
 */ BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};
/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */ BufferReader._configure();

},{"808dd763e7b39931":"bN2lE","fcb9b16130e5c787":"4HDe1"}],"eRwa1":[function(require,module,exports) {
"use strict";
/**
 * Streaming RPC helpers.
 * @namespace
 */ var rpc = exports;
/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */ /**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */ rpc.Service = require("8d618176461c1566");

},{"8d618176461c1566":"lVKlz"}],"lVKlz":[function(require,module,exports) {
"use strict";
module.exports = Service;
var util = require("873e42e92ef9570e");
// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */ /**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */ /**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */ function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function") throw TypeError("rpcImpl must be a function");
    util.EventEmitter.call(this);
    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */ this.rpcImpl = rpcImpl;
    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */ this.requestDelimited = Boolean(requestDelimited);
    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */ this.responseDelimited = Boolean(responseDelimited);
}
/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */ Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
    if (!request) throw TypeError("request must be specified");
    var self = this;
    if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);
    if (!self.rpcImpl) {
        setTimeout(function() {
            callback(Error("already ended"));
        }, 0);
        return undefined;
    }
    try {
        return self.rpcImpl(method, requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
            if (err) {
                self.emit("error", err, method);
                return callback(err);
            }
            if (response === null) {
                self.end(/* endedByRPC */ true);
                return undefined;
            }
            if (!(response instanceof responseCtor)) try {
                response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
            } catch (err) {
                self.emit("error", err, method);
                return callback(err);
            }
            self.emit("data", response, method);
            return callback(null, response);
        });
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() {
            callback(err);
        }, 0);
        return undefined;
    }
};
/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */ Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"873e42e92ef9570e":"4HDe1"}],"bJQDp":[function(require,module,exports) {
"use strict";
module.exports = {}; /**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available across modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */ 

},{}],"9J2LG":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "MessageHeaderV1", ()=>MessageHeaderV1);
parcelHelpers.export(exports, "MessageV1", ()=>MessageV1);
parcelHelpers.export(exports, "MessageHeaderV2", ()=>MessageHeaderV2);
parcelHelpers.export(exports, "MessageV2", ()=>MessageV2);
parcelHelpers.export(exports, "Message", ()=>Message);
parcelHelpers.export(exports, "DecodedMessage", ()=>DecodedMessage);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _publicKeyPb = require("./public_key.pb");
var _ciphertextPb = require("./ciphertext.pb");
var _conversationReferencePb = require("./conversation_reference.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.message_contents";
function createBaseMessageHeaderV1() {
    return {
        sender: undefined,
        recipient: undefined,
        timestamp: (0, _longDefault.default).UZERO
    };
}
const MessageHeaderV1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.sender !== undefined) (0, _publicKeyPb.PublicKeyBundle).encode(message.sender, writer.uint32(10).fork()).ldelim();
        if (message.recipient !== undefined) (0, _publicKeyPb.PublicKeyBundle).encode(message.recipient, writer.uint32(18).fork()).ldelim();
        if (!message.timestamp.isZero()) writer.uint32(24).uint64(message.timestamp);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageHeaderV1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.sender = (0, _publicKeyPb.PublicKeyBundle).decode(reader, reader.uint32());
                    break;
                case 2:
                    message.recipient = (0, _publicKeyPb.PublicKeyBundle).decode(reader, reader.uint32());
                    break;
                case 3:
                    message.timestamp = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            sender: isSet(object.sender) ? (0, _publicKeyPb.PublicKeyBundle).fromJSON(object.sender) : undefined,
            recipient: isSet(object.recipient) ? (0, _publicKeyPb.PublicKeyBundle).fromJSON(object.recipient) : undefined,
            timestamp: isSet(object.timestamp) ? (0, _longDefault.default).fromValue(object.timestamp) : (0, _longDefault.default).UZERO
        };
    },
    toJSON (message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender ? (0, _publicKeyPb.PublicKeyBundle).toJSON(message.sender) : undefined);
        message.recipient !== undefined && (obj.recipient = message.recipient ? (0, _publicKeyPb.PublicKeyBundle).toJSON(message.recipient) : undefined);
        message.timestamp !== undefined && (obj.timestamp = (message.timestamp || (0, _longDefault.default).UZERO).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMessageHeaderV1();
        message.sender = object.sender !== undefined && object.sender !== null ? (0, _publicKeyPb.PublicKeyBundle).fromPartial(object.sender) : undefined;
        message.recipient = object.recipient !== undefined && object.recipient !== null ? (0, _publicKeyPb.PublicKeyBundle).fromPartial(object.recipient) : undefined;
        message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? (0, _longDefault.default).fromValue(object.timestamp) : (0, _longDefault.default).UZERO;
        return message;
    }
};
function createBaseMessageV1() {
    return {
        headerBytes: new Uint8Array(),
        ciphertext: undefined
    };
}
const MessageV1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.headerBytes.length !== 0) writer.uint32(10).bytes(message.headerBytes);
        if (message.ciphertext !== undefined) (0, _ciphertextPb.Ciphertext).encode(message.ciphertext, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageV1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.headerBytes = reader.bytes();
                    break;
                case 2:
                    message.ciphertext = (0, _ciphertextPb.Ciphertext).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            headerBytes: isSet(object.headerBytes) ? bytesFromBase64(object.headerBytes) : new Uint8Array(),
            ciphertext: isSet(object.ciphertext) ? (0, _ciphertextPb.Ciphertext).fromJSON(object.ciphertext) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.headerBytes !== undefined && (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined ? message.headerBytes : new Uint8Array()));
        message.ciphertext !== undefined && (obj.ciphertext = message.ciphertext ? (0, _ciphertextPb.Ciphertext).toJSON(message.ciphertext) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMessageV1();
        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.ciphertext = object.ciphertext !== undefined && object.ciphertext !== null ? (0, _ciphertextPb.Ciphertext).fromPartial(object.ciphertext) : undefined;
        return message;
    }
};
function createBaseMessageHeaderV2() {
    return {
        createdNs: (0, _longDefault.default).UZERO,
        topic: ""
    };
}
const MessageHeaderV2 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (!message.createdNs.isZero()) writer.uint32(8).uint64(message.createdNs);
        if (message.topic !== "") writer.uint32(18).string(message.topic);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageHeaderV2();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.createdNs = reader.uint64();
                    break;
                case 2:
                    message.topic = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            createdNs: isSet(object.createdNs) ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO,
            topic: isSet(object.topic) ? String(object.topic) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.createdNs !== undefined && (obj.createdNs = (message.createdNs || (0, _longDefault.default).UZERO).toString());
        message.topic !== undefined && (obj.topic = message.topic);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMessageHeaderV2();
        message.createdNs = object.createdNs !== undefined && object.createdNs !== null ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO;
        message.topic = (_a = object.topic) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
function createBaseMessageV2() {
    return {
        headerBytes: new Uint8Array(),
        ciphertext: undefined,
        senderHmac: undefined,
        shouldPush: undefined
    };
}
const MessageV2 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.headerBytes.length !== 0) writer.uint32(10).bytes(message.headerBytes);
        if (message.ciphertext !== undefined) (0, _ciphertextPb.Ciphertext).encode(message.ciphertext, writer.uint32(18).fork()).ldelim();
        if (message.senderHmac !== undefined) writer.uint32(26).bytes(message.senderHmac);
        if (message.shouldPush !== undefined) writer.uint32(32).bool(message.shouldPush);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageV2();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.headerBytes = reader.bytes();
                    break;
                case 2:
                    message.ciphertext = (0, _ciphertextPb.Ciphertext).decode(reader, reader.uint32());
                    break;
                case 3:
                    message.senderHmac = reader.bytes();
                    break;
                case 4:
                    message.shouldPush = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            headerBytes: isSet(object.headerBytes) ? bytesFromBase64(object.headerBytes) : new Uint8Array(),
            ciphertext: isSet(object.ciphertext) ? (0, _ciphertextPb.Ciphertext).fromJSON(object.ciphertext) : undefined,
            senderHmac: isSet(object.senderHmac) ? bytesFromBase64(object.senderHmac) : undefined,
            shouldPush: isSet(object.shouldPush) ? Boolean(object.shouldPush) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.headerBytes !== undefined && (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined ? message.headerBytes : new Uint8Array()));
        message.ciphertext !== undefined && (obj.ciphertext = message.ciphertext ? (0, _ciphertextPb.Ciphertext).toJSON(message.ciphertext) : undefined);
        message.senderHmac !== undefined && (obj.senderHmac = message.senderHmac !== undefined ? base64FromBytes(message.senderHmac) : undefined);
        message.shouldPush !== undefined && (obj.shouldPush = message.shouldPush);
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseMessageV2();
        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.ciphertext = object.ciphertext !== undefined && object.ciphertext !== null ? (0, _ciphertextPb.Ciphertext).fromPartial(object.ciphertext) : undefined;
        message.senderHmac = (_b = object.senderHmac) !== null && _b !== void 0 ? _b : undefined;
        message.shouldPush = (_c = object.shouldPush) !== null && _c !== void 0 ? _c : undefined;
        return message;
    }
};
function createBaseMessage() {
    return {
        v1: undefined,
        v2: undefined
    };
}
const Message = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) MessageV1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        if (message.v2 !== undefined) MessageV2.encode(message.v2, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessage();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = MessageV1.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.v2 = MessageV2.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? MessageV1.fromJSON(object.v1) : undefined,
            v2: isSet(object.v2) ? MessageV2.fromJSON(object.v2) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? MessageV1.toJSON(message.v1) : undefined);
        message.v2 !== undefined && (obj.v2 = message.v2 ? MessageV2.toJSON(message.v2) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMessage();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? MessageV1.fromPartial(object.v1) : undefined;
        message.v2 = object.v2 !== undefined && object.v2 !== null ? MessageV2.fromPartial(object.v2) : undefined;
        return message;
    }
};
function createBaseDecodedMessage() {
    return {
        id: "",
        messageVersion: "",
        senderAddress: "",
        recipientAddress: undefined,
        sentNs: (0, _longDefault.default).UZERO,
        contentTopic: "",
        conversation: undefined,
        contentBytes: new Uint8Array()
    };
}
const DecodedMessage = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.id !== "") writer.uint32(10).string(message.id);
        if (message.messageVersion !== "") writer.uint32(18).string(message.messageVersion);
        if (message.senderAddress !== "") writer.uint32(26).string(message.senderAddress);
        if (message.recipientAddress !== undefined) writer.uint32(34).string(message.recipientAddress);
        if (!message.sentNs.isZero()) writer.uint32(40).uint64(message.sentNs);
        if (message.contentTopic !== "") writer.uint32(50).string(message.contentTopic);
        if (message.conversation !== undefined) (0, _conversationReferencePb.ConversationReference).encode(message.conversation, writer.uint32(58).fork()).ldelim();
        if (message.contentBytes.length !== 0) writer.uint32(66).bytes(message.contentBytes);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecodedMessage();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.messageVersion = reader.string();
                    break;
                case 3:
                    message.senderAddress = reader.string();
                    break;
                case 4:
                    message.recipientAddress = reader.string();
                    break;
                case 5:
                    message.sentNs = reader.uint64();
                    break;
                case 6:
                    message.contentTopic = reader.string();
                    break;
                case 7:
                    message.conversation = (0, _conversationReferencePb.ConversationReference).decode(reader, reader.uint32());
                    break;
                case 8:
                    message.contentBytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            id: isSet(object.id) ? String(object.id) : "",
            messageVersion: isSet(object.messageVersion) ? String(object.messageVersion) : "",
            senderAddress: isSet(object.senderAddress) ? String(object.senderAddress) : "",
            recipientAddress: isSet(object.recipientAddress) ? String(object.recipientAddress) : undefined,
            sentNs: isSet(object.sentNs) ? (0, _longDefault.default).fromValue(object.sentNs) : (0, _longDefault.default).UZERO,
            contentTopic: isSet(object.contentTopic) ? String(object.contentTopic) : "",
            conversation: isSet(object.conversation) ? (0, _conversationReferencePb.ConversationReference).fromJSON(object.conversation) : undefined,
            contentBytes: isSet(object.contentBytes) ? bytesFromBase64(object.contentBytes) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.id !== undefined && (obj.id = message.id);
        message.messageVersion !== undefined && (obj.messageVersion = message.messageVersion);
        message.senderAddress !== undefined && (obj.senderAddress = message.senderAddress);
        message.recipientAddress !== undefined && (obj.recipientAddress = message.recipientAddress);
        message.sentNs !== undefined && (obj.sentNs = (message.sentNs || (0, _longDefault.default).UZERO).toString());
        message.contentTopic !== undefined && (obj.contentTopic = message.contentTopic);
        message.conversation !== undefined && (obj.conversation = message.conversation ? (0, _conversationReferencePb.ConversationReference).toJSON(message.conversation) : undefined);
        message.contentBytes !== undefined && (obj.contentBytes = base64FromBytes(message.contentBytes !== undefined ? message.contentBytes : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseDecodedMessage();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.messageVersion = (_b = object.messageVersion) !== null && _b !== void 0 ? _b : "";
        message.senderAddress = (_c = object.senderAddress) !== null && _c !== void 0 ? _c : "";
        message.recipientAddress = (_d = object.recipientAddress) !== null && _d !== void 0 ? _d : undefined;
        message.sentNs = object.sentNs !== undefined && object.sentNs !== null ? (0, _longDefault.default).fromValue(object.sentNs) : (0, _longDefault.default).UZERO;
        message.contentTopic = (_e = object.contentTopic) !== null && _e !== void 0 ? _e : "";
        message.conversation = object.conversation !== undefined && object.conversation !== null ? (0, _conversationReferencePb.ConversationReference).fromPartial(object.conversation) : undefined;
        message.contentBytes = (_f = object.contentBytes) !== null && _f !== void 0 ? _f : new Uint8Array();
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","./public_key.pb":"6Dba7","./ciphertext.pb":"dkFEI","./conversation_reference.pb":"jsKKm","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dkFEI":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "Ciphertext", ()=>Ciphertext);
parcelHelpers.export(exports, "Ciphertext_Aes256gcmHkdfsha256", ()=>Ciphertext_Aes256gcmHkdfsha256);
parcelHelpers.export(exports, "SignedEciesCiphertext", ()=>SignedEciesCiphertext);
parcelHelpers.export(exports, "SignedEciesCiphertext_Ecies", ()=>SignedEciesCiphertext_Ecies);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _signaturePb = require("./signature.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.message_contents";
function createBaseCiphertext() {
    return {
        aes256GcmHkdfSha256: undefined
    };
}
const Ciphertext = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.aes256GcmHkdfSha256 !== undefined) Ciphertext_Aes256gcmHkdfsha256.encode(message.aes256GcmHkdfSha256, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCiphertext();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.aes256GcmHkdfSha256 = Ciphertext_Aes256gcmHkdfsha256.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            aes256GcmHkdfSha256: isSet(object.aes256GcmHkdfSha256) ? Ciphertext_Aes256gcmHkdfsha256.fromJSON(object.aes256GcmHkdfSha256) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.aes256GcmHkdfSha256 !== undefined && (obj.aes256GcmHkdfSha256 = message.aes256GcmHkdfSha256 ? Ciphertext_Aes256gcmHkdfsha256.toJSON(message.aes256GcmHkdfSha256) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCiphertext();
        message.aes256GcmHkdfSha256 = object.aes256GcmHkdfSha256 !== undefined && object.aes256GcmHkdfSha256 !== null ? Ciphertext_Aes256gcmHkdfsha256.fromPartial(object.aes256GcmHkdfSha256) : undefined;
        return message;
    }
};
function createBaseCiphertext_Aes256gcmHkdfsha256() {
    return {
        hkdfSalt: new Uint8Array(),
        gcmNonce: new Uint8Array(),
        payload: new Uint8Array()
    };
}
const Ciphertext_Aes256gcmHkdfsha256 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.hkdfSalt.length !== 0) writer.uint32(10).bytes(message.hkdfSalt);
        if (message.gcmNonce.length !== 0) writer.uint32(18).bytes(message.gcmNonce);
        if (message.payload.length !== 0) writer.uint32(26).bytes(message.payload);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCiphertext_Aes256gcmHkdfsha256();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.hkdfSalt = reader.bytes();
                    break;
                case 2:
                    message.gcmNonce = reader.bytes();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            hkdfSalt: isSet(object.hkdfSalt) ? bytesFromBase64(object.hkdfSalt) : new Uint8Array(),
            gcmNonce: isSet(object.gcmNonce) ? bytesFromBase64(object.gcmNonce) : new Uint8Array(),
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.hkdfSalt !== undefined && (obj.hkdfSalt = base64FromBytes(message.hkdfSalt !== undefined ? message.hkdfSalt : new Uint8Array()));
        message.gcmNonce !== undefined && (obj.gcmNonce = base64FromBytes(message.gcmNonce !== undefined ? message.gcmNonce : new Uint8Array()));
        message.payload !== undefined && (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseCiphertext_Aes256gcmHkdfsha256();
        message.hkdfSalt = (_a = object.hkdfSalt) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.gcmNonce = (_b = object.gcmNonce) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.payload = (_c = object.payload) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
    }
};
function createBaseSignedEciesCiphertext() {
    return {
        eciesBytes: new Uint8Array(),
        signature: undefined
    };
}
const SignedEciesCiphertext = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.eciesBytes.length !== 0) writer.uint32(10).bytes(message.eciesBytes);
        if (message.signature !== undefined) (0, _signaturePb.Signature).encode(message.signature, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignedEciesCiphertext();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.eciesBytes = reader.bytes();
                    break;
                case 2:
                    message.signature = (0, _signaturePb.Signature).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            eciesBytes: isSet(object.eciesBytes) ? bytesFromBase64(object.eciesBytes) : new Uint8Array(),
            signature: isSet(object.signature) ? (0, _signaturePb.Signature).fromJSON(object.signature) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.eciesBytes !== undefined && (obj.eciesBytes = base64FromBytes(message.eciesBytes !== undefined ? message.eciesBytes : new Uint8Array()));
        message.signature !== undefined && (obj.signature = message.signature ? (0, _signaturePb.Signature).toJSON(message.signature) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSignedEciesCiphertext();
        message.eciesBytes = (_a = object.eciesBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.signature = object.signature !== undefined && object.signature !== null ? (0, _signaturePb.Signature).fromPartial(object.signature) : undefined;
        return message;
    }
};
function createBaseSignedEciesCiphertext_Ecies() {
    return {
        ephemeralPublicKey: new Uint8Array(),
        iv: new Uint8Array(),
        mac: new Uint8Array(),
        ciphertext: new Uint8Array()
    };
}
const SignedEciesCiphertext_Ecies = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.ephemeralPublicKey.length !== 0) writer.uint32(10).bytes(message.ephemeralPublicKey);
        if (message.iv.length !== 0) writer.uint32(18).bytes(message.iv);
        if (message.mac.length !== 0) writer.uint32(26).bytes(message.mac);
        if (message.ciphertext.length !== 0) writer.uint32(34).bytes(message.ciphertext);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignedEciesCiphertext_Ecies();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.ephemeralPublicKey = reader.bytes();
                    break;
                case 2:
                    message.iv = reader.bytes();
                    break;
                case 3:
                    message.mac = reader.bytes();
                    break;
                case 4:
                    message.ciphertext = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            ephemeralPublicKey: isSet(object.ephemeralPublicKey) ? bytesFromBase64(object.ephemeralPublicKey) : new Uint8Array(),
            iv: isSet(object.iv) ? bytesFromBase64(object.iv) : new Uint8Array(),
            mac: isSet(object.mac) ? bytesFromBase64(object.mac) : new Uint8Array(),
            ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.ephemeralPublicKey !== undefined && (obj.ephemeralPublicKey = base64FromBytes(message.ephemeralPublicKey !== undefined ? message.ephemeralPublicKey : new Uint8Array()));
        message.iv !== undefined && (obj.iv = base64FromBytes(message.iv !== undefined ? message.iv : new Uint8Array()));
        message.mac !== undefined && (obj.mac = base64FromBytes(message.mac !== undefined ? message.mac : new Uint8Array()));
        message.ciphertext !== undefined && (obj.ciphertext = base64FromBytes(message.ciphertext !== undefined ? message.ciphertext : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseSignedEciesCiphertext_Ecies();
        message.ephemeralPublicKey = (_a = object.ephemeralPublicKey) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.iv = (_b = object.iv) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.mac = (_c = object.mac) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.ciphertext = (_d = object.ciphertext) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","./signature.pb":"hvHvx","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jsKKm":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "ConversationReference", ()=>ConversationReference);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _invitationPb = require("./invitation.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
const protobufPackage = "xmtp.message_contents";
function createBaseConversationReference() {
    return {
        topic: "",
        peerAddress: "",
        createdNs: (0, _longDefault.default).UZERO,
        context: undefined,
        consentProofPayload: undefined
    };
}
const ConversationReference = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.topic !== "") writer.uint32(10).string(message.topic);
        if (message.peerAddress !== "") writer.uint32(18).string(message.peerAddress);
        if (!message.createdNs.isZero()) writer.uint32(24).uint64(message.createdNs);
        if (message.context !== undefined) (0, _invitationPb.InvitationV1_Context).encode(message.context, writer.uint32(34).fork()).ldelim();
        if (message.consentProofPayload !== undefined) (0, _invitationPb.ConsentProofPayload).encode(message.consentProofPayload, writer.uint32(42).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationReference();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.topic = reader.string();
                    break;
                case 2:
                    message.peerAddress = reader.string();
                    break;
                case 3:
                    message.createdNs = reader.uint64();
                    break;
                case 4:
                    message.context = (0, _invitationPb.InvitationV1_Context).decode(reader, reader.uint32());
                    break;
                case 5:
                    message.consentProofPayload = (0, _invitationPb.ConsentProofPayload).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            topic: isSet(object.topic) ? String(object.topic) : "",
            peerAddress: isSet(object.peerAddress) ? String(object.peerAddress) : "",
            createdNs: isSet(object.createdNs) ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO,
            context: isSet(object.context) ? (0, _invitationPb.InvitationV1_Context).fromJSON(object.context) : undefined,
            consentProofPayload: isSet(object.consentProofPayload) ? (0, _invitationPb.ConsentProofPayload).fromJSON(object.consentProofPayload) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.topic !== undefined && (obj.topic = message.topic);
        message.peerAddress !== undefined && (obj.peerAddress = message.peerAddress);
        message.createdNs !== undefined && (obj.createdNs = (message.createdNs || (0, _longDefault.default).UZERO).toString());
        message.context !== undefined && (obj.context = message.context ? (0, _invitationPb.InvitationV1_Context).toJSON(message.context) : undefined);
        message.consentProofPayload !== undefined && (obj.consentProofPayload = message.consentProofPayload ? (0, _invitationPb.ConsentProofPayload).toJSON(message.consentProofPayload) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseConversationReference();
        message.topic = (_a = object.topic) !== null && _a !== void 0 ? _a : "";
        message.peerAddress = (_b = object.peerAddress) !== null && _b !== void 0 ? _b : "";
        message.createdNs = object.createdNs !== undefined && object.createdNs !== null ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO;
        message.context = object.context !== undefined && object.context !== null ? (0, _invitationPb.InvitationV1_Context).fromPartial(object.context) : undefined;
        message.consentProofPayload = object.consentProofPayload !== undefined && object.consentProofPayload !== null ? (0, _invitationPb.ConsentProofPayload).fromPartial(object.consentProofPayload) : undefined;
        return message;
    }
};
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","./invitation.pb":"1UrlP","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1UrlP":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "ConsentProofPayloadVersion", ()=>ConsentProofPayloadVersion);
parcelHelpers.export(exports, "consentProofPayloadVersionFromJSON", ()=>consentProofPayloadVersionFromJSON);
parcelHelpers.export(exports, "consentProofPayloadVersionToJSON", ()=>consentProofPayloadVersionToJSON);
parcelHelpers.export(exports, "InvitationV1", ()=>InvitationV1);
parcelHelpers.export(exports, "InvitationV1_Aes256gcmHkdfsha256", ()=>InvitationV1_Aes256gcmHkdfsha256);
parcelHelpers.export(exports, "InvitationV1_Context", ()=>InvitationV1_Context);
parcelHelpers.export(exports, "InvitationV1_Context_MetadataEntry", ()=>InvitationV1_Context_MetadataEntry);
parcelHelpers.export(exports, "SealedInvitationHeaderV1", ()=>SealedInvitationHeaderV1);
parcelHelpers.export(exports, "SealedInvitationV1", ()=>SealedInvitationV1);
parcelHelpers.export(exports, "SealedInvitation", ()=>SealedInvitation);
parcelHelpers.export(exports, "ConsentProofPayload", ()=>ConsentProofPayload);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _publicKeyPb = require("./public_key.pb");
var _ciphertextPb = require("./ciphertext.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.message_contents";
var ConsentProofPayloadVersion;
(function(ConsentProofPayloadVersion) {
    ConsentProofPayloadVersion[ConsentProofPayloadVersion["CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED"] = 0] = "CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED";
    ConsentProofPayloadVersion[ConsentProofPayloadVersion["CONSENT_PROOF_PAYLOAD_VERSION_1"] = 1] = "CONSENT_PROOF_PAYLOAD_VERSION_1";
    ConsentProofPayloadVersion[ConsentProofPayloadVersion["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConsentProofPayloadVersion || (ConsentProofPayloadVersion = {}));
function consentProofPayloadVersionFromJSON(object) {
    switch(object){
        case 0:
        case "CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED":
            return ConsentProofPayloadVersion.CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED;
        case 1:
        case "CONSENT_PROOF_PAYLOAD_VERSION_1":
            return ConsentProofPayloadVersion.CONSENT_PROOF_PAYLOAD_VERSION_1;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ConsentProofPayloadVersion.UNRECOGNIZED;
    }
}
function consentProofPayloadVersionToJSON(object) {
    switch(object){
        case ConsentProofPayloadVersion.CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED:
            return "CONSENT_PROOF_PAYLOAD_VERSION_UNSPECIFIED";
        case ConsentProofPayloadVersion.CONSENT_PROOF_PAYLOAD_VERSION_1:
            return "CONSENT_PROOF_PAYLOAD_VERSION_1";
        case ConsentProofPayloadVersion.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseInvitationV1() {
    return {
        topic: "",
        context: undefined,
        aes256GcmHkdfSha256: undefined,
        consentProof: undefined
    };
}
const InvitationV1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.topic !== "") writer.uint32(10).string(message.topic);
        if (message.context !== undefined) InvitationV1_Context.encode(message.context, writer.uint32(18).fork()).ldelim();
        if (message.aes256GcmHkdfSha256 !== undefined) InvitationV1_Aes256gcmHkdfsha256.encode(message.aes256GcmHkdfSha256, writer.uint32(26).fork()).ldelim();
        if (message.consentProof !== undefined) ConsentProofPayload.encode(message.consentProof, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInvitationV1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.topic = reader.string();
                    break;
                case 2:
                    message.context = InvitationV1_Context.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.aes256GcmHkdfSha256 = InvitationV1_Aes256gcmHkdfsha256.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.consentProof = ConsentProofPayload.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            topic: isSet(object.topic) ? String(object.topic) : "",
            context: isSet(object.context) ? InvitationV1_Context.fromJSON(object.context) : undefined,
            aes256GcmHkdfSha256: isSet(object.aes256GcmHkdfSha256) ? InvitationV1_Aes256gcmHkdfsha256.fromJSON(object.aes256GcmHkdfSha256) : undefined,
            consentProof: isSet(object.consentProof) ? ConsentProofPayload.fromJSON(object.consentProof) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.topic !== undefined && (obj.topic = message.topic);
        message.context !== undefined && (obj.context = message.context ? InvitationV1_Context.toJSON(message.context) : undefined);
        message.aes256GcmHkdfSha256 !== undefined && (obj.aes256GcmHkdfSha256 = message.aes256GcmHkdfSha256 ? InvitationV1_Aes256gcmHkdfsha256.toJSON(message.aes256GcmHkdfSha256) : undefined);
        message.consentProof !== undefined && (obj.consentProof = message.consentProof ? ConsentProofPayload.toJSON(message.consentProof) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseInvitationV1();
        message.topic = (_a = object.topic) !== null && _a !== void 0 ? _a : "";
        message.context = object.context !== undefined && object.context !== null ? InvitationV1_Context.fromPartial(object.context) : undefined;
        message.aes256GcmHkdfSha256 = object.aes256GcmHkdfSha256 !== undefined && object.aes256GcmHkdfSha256 !== null ? InvitationV1_Aes256gcmHkdfsha256.fromPartial(object.aes256GcmHkdfSha256) : undefined;
        message.consentProof = object.consentProof !== undefined && object.consentProof !== null ? ConsentProofPayload.fromPartial(object.consentProof) : undefined;
        return message;
    }
};
function createBaseInvitationV1_Aes256gcmHkdfsha256() {
    return {
        keyMaterial: new Uint8Array()
    };
}
const InvitationV1_Aes256gcmHkdfsha256 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.keyMaterial.length !== 0) writer.uint32(10).bytes(message.keyMaterial);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInvitationV1_Aes256gcmHkdfsha256();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyMaterial = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            keyMaterial: isSet(object.keyMaterial) ? bytesFromBase64(object.keyMaterial) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.keyMaterial !== undefined && (obj.keyMaterial = base64FromBytes(message.keyMaterial !== undefined ? message.keyMaterial : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseInvitationV1_Aes256gcmHkdfsha256();
        message.keyMaterial = (_a = object.keyMaterial) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseInvitationV1_Context() {
    return {
        conversationId: "",
        metadata: {}
    };
}
const InvitationV1_Context = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.conversationId !== "") writer.uint32(10).string(message.conversationId);
        Object.entries(message.metadata).forEach(([key, value])=>{
            InvitationV1_Context_MetadataEntry.encode({
                key: key,
                value
            }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInvitationV1_Context();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.conversationId = reader.string();
                    break;
                case 2:
                    const entry2 = InvitationV1_Context_MetadataEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) message.metadata[entry2.key] = entry2.value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            conversationId: isSet(object.conversationId) ? String(object.conversationId) : "",
            metadata: isObject(object.metadata) ? Object.entries(object.metadata).reduce((acc, [key, value])=>{
                acc[key] = String(value);
                return acc;
            }, {}) : {}
        };
    },
    toJSON (message) {
        const obj = {};
        message.conversationId !== undefined && (obj.conversationId = message.conversationId);
        obj.metadata = {};
        if (message.metadata) Object.entries(message.metadata).forEach(([k, v])=>{
            obj.metadata[k] = v;
        });
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseInvitationV1_Context();
        message.conversationId = (_a = object.conversationId) !== null && _a !== void 0 ? _a : "";
        message.metadata = Object.entries((_b = object.metadata) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value])=>{
            if (value !== undefined) acc[key] = String(value);
            return acc;
        }, {});
        return message;
    }
};
function createBaseInvitationV1_Context_MetadataEntry() {
    return {
        key: "",
        value: ""
    };
}
const InvitationV1_Context_MetadataEntry = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.key !== "") writer.uint32(10).string(message.key);
        if (message.value !== "") writer.uint32(18).string(message.value);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInvitationV1_Context_MetadataEntry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? String(object.value) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseInvitationV1_Context_MetadataEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseSealedInvitationHeaderV1() {
    return {
        sender: undefined,
        recipient: undefined,
        createdNs: (0, _longDefault.default).UZERO
    };
}
const SealedInvitationHeaderV1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.sender !== undefined) (0, _publicKeyPb.SignedPublicKeyBundle).encode(message.sender, writer.uint32(10).fork()).ldelim();
        if (message.recipient !== undefined) (0, _publicKeyPb.SignedPublicKeyBundle).encode(message.recipient, writer.uint32(18).fork()).ldelim();
        if (!message.createdNs.isZero()) writer.uint32(24).uint64(message.createdNs);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSealedInvitationHeaderV1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.sender = (0, _publicKeyPb.SignedPublicKeyBundle).decode(reader, reader.uint32());
                    break;
                case 2:
                    message.recipient = (0, _publicKeyPb.SignedPublicKeyBundle).decode(reader, reader.uint32());
                    break;
                case 3:
                    message.createdNs = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            sender: isSet(object.sender) ? (0, _publicKeyPb.SignedPublicKeyBundle).fromJSON(object.sender) : undefined,
            recipient: isSet(object.recipient) ? (0, _publicKeyPb.SignedPublicKeyBundle).fromJSON(object.recipient) : undefined,
            createdNs: isSet(object.createdNs) ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO
        };
    },
    toJSON (message) {
        const obj = {};
        message.sender !== undefined && (obj.sender = message.sender ? (0, _publicKeyPb.SignedPublicKeyBundle).toJSON(message.sender) : undefined);
        message.recipient !== undefined && (obj.recipient = message.recipient ? (0, _publicKeyPb.SignedPublicKeyBundle).toJSON(message.recipient) : undefined);
        message.createdNs !== undefined && (obj.createdNs = (message.createdNs || (0, _longDefault.default).UZERO).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSealedInvitationHeaderV1();
        message.sender = object.sender !== undefined && object.sender !== null ? (0, _publicKeyPb.SignedPublicKeyBundle).fromPartial(object.sender) : undefined;
        message.recipient = object.recipient !== undefined && object.recipient !== null ? (0, _publicKeyPb.SignedPublicKeyBundle).fromPartial(object.recipient) : undefined;
        message.createdNs = object.createdNs !== undefined && object.createdNs !== null ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO;
        return message;
    }
};
function createBaseSealedInvitationV1() {
    return {
        headerBytes: new Uint8Array(),
        ciphertext: undefined
    };
}
const SealedInvitationV1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.headerBytes.length !== 0) writer.uint32(10).bytes(message.headerBytes);
        if (message.ciphertext !== undefined) (0, _ciphertextPb.Ciphertext).encode(message.ciphertext, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSealedInvitationV1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.headerBytes = reader.bytes();
                    break;
                case 2:
                    message.ciphertext = (0, _ciphertextPb.Ciphertext).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            headerBytes: isSet(object.headerBytes) ? bytesFromBase64(object.headerBytes) : new Uint8Array(),
            ciphertext: isSet(object.ciphertext) ? (0, _ciphertextPb.Ciphertext).fromJSON(object.ciphertext) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.headerBytes !== undefined && (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined ? message.headerBytes : new Uint8Array()));
        message.ciphertext !== undefined && (obj.ciphertext = message.ciphertext ? (0, _ciphertextPb.Ciphertext).toJSON(message.ciphertext) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSealedInvitationV1();
        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.ciphertext = object.ciphertext !== undefined && object.ciphertext !== null ? (0, _ciphertextPb.Ciphertext).fromPartial(object.ciphertext) : undefined;
        return message;
    }
};
function createBaseSealedInvitation() {
    return {
        v1: undefined
    };
}
const SealedInvitation = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) SealedInvitationV1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSealedInvitation();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = SealedInvitationV1.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? SealedInvitationV1.fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? SealedInvitationV1.toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSealedInvitation();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? SealedInvitationV1.fromPartial(object.v1) : undefined;
        return message;
    }
};
function createBaseConsentProofPayload() {
    return {
        signature: "",
        timestamp: (0, _longDefault.default).UZERO,
        payloadVersion: 0
    };
}
const ConsentProofPayload = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.signature !== "") writer.uint32(10).string(message.signature);
        if (!message.timestamp.isZero()) writer.uint32(16).uint64(message.timestamp);
        if (message.payloadVersion !== 0) writer.uint32(24).int32(message.payloadVersion);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConsentProofPayload();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.signature = reader.string();
                    break;
                case 2:
                    message.timestamp = reader.uint64();
                    break;
                case 3:
                    message.payloadVersion = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            signature: isSet(object.signature) ? String(object.signature) : "",
            timestamp: isSet(object.timestamp) ? (0, _longDefault.default).fromValue(object.timestamp) : (0, _longDefault.default).UZERO,
            payloadVersion: isSet(object.payloadVersion) ? consentProofPayloadVersionFromJSON(object.payloadVersion) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        message.signature !== undefined && (obj.signature = message.signature);
        message.timestamp !== undefined && (obj.timestamp = (message.timestamp || (0, _longDefault.default).UZERO).toString());
        message.payloadVersion !== undefined && (obj.payloadVersion = consentProofPayloadVersionToJSON(message.payloadVersion));
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseConsentProofPayload();
        message.signature = (_a = object.signature) !== null && _a !== void 0 ? _a : "";
        message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? (0, _longDefault.default).fromValue(object.timestamp) : (0, _longDefault.default).UZERO;
        message.payloadVersion = (_b = object.payloadVersion) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","./public_key.pb":"6Dba7","./ciphertext.pb":"dkFEI","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2nRTw":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "Compression", ()=>Compression);
parcelHelpers.export(exports, "compressionFromJSON", ()=>compressionFromJSON);
parcelHelpers.export(exports, "compressionToJSON", ()=>compressionToJSON);
parcelHelpers.export(exports, "ContentTypeId", ()=>ContentTypeId);
parcelHelpers.export(exports, "EncodedContent", ()=>EncodedContent);
parcelHelpers.export(exports, "EncodedContent_ParametersEntry", ()=>EncodedContent_ParametersEntry);
parcelHelpers.export(exports, "SignedContent", ()=>SignedContent);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _publicKeyPb = require("./public_key.pb");
var _signaturePb = require("./signature.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.message_contents";
var Compression;
(function(Compression) {
    Compression[Compression["COMPRESSION_DEFLATE"] = 0] = "COMPRESSION_DEFLATE";
    Compression[Compression["COMPRESSION_GZIP"] = 1] = "COMPRESSION_GZIP";
    Compression[Compression["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Compression || (Compression = {}));
function compressionFromJSON(object) {
    switch(object){
        case 0:
        case "COMPRESSION_DEFLATE":
            return Compression.COMPRESSION_DEFLATE;
        case 1:
        case "COMPRESSION_GZIP":
            return Compression.COMPRESSION_GZIP;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Compression.UNRECOGNIZED;
    }
}
function compressionToJSON(object) {
    switch(object){
        case Compression.COMPRESSION_DEFLATE:
            return "COMPRESSION_DEFLATE";
        case Compression.COMPRESSION_GZIP:
            return "COMPRESSION_GZIP";
        case Compression.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseContentTypeId() {
    return {
        authorityId: "",
        typeId: "",
        versionMajor: 0,
        versionMinor: 0
    };
}
const ContentTypeId = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.authorityId !== "") writer.uint32(10).string(message.authorityId);
        if (message.typeId !== "") writer.uint32(18).string(message.typeId);
        if (message.versionMajor !== 0) writer.uint32(24).uint32(message.versionMajor);
        if (message.versionMinor !== 0) writer.uint32(32).uint32(message.versionMinor);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContentTypeId();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.authorityId = reader.string();
                    break;
                case 2:
                    message.typeId = reader.string();
                    break;
                case 3:
                    message.versionMajor = reader.uint32();
                    break;
                case 4:
                    message.versionMinor = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            authorityId: isSet(object.authorityId) ? String(object.authorityId) : "",
            typeId: isSet(object.typeId) ? String(object.typeId) : "",
            versionMajor: isSet(object.versionMajor) ? Number(object.versionMajor) : 0,
            versionMinor: isSet(object.versionMinor) ? Number(object.versionMinor) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        message.authorityId !== undefined && (obj.authorityId = message.authorityId);
        message.typeId !== undefined && (obj.typeId = message.typeId);
        message.versionMajor !== undefined && (obj.versionMajor = Math.round(message.versionMajor));
        message.versionMinor !== undefined && (obj.versionMinor = Math.round(message.versionMinor));
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseContentTypeId();
        message.authorityId = (_a = object.authorityId) !== null && _a !== void 0 ? _a : "";
        message.typeId = (_b = object.typeId) !== null && _b !== void 0 ? _b : "";
        message.versionMajor = (_c = object.versionMajor) !== null && _c !== void 0 ? _c : 0;
        message.versionMinor = (_d = object.versionMinor) !== null && _d !== void 0 ? _d : 0;
        return message;
    }
};
function createBaseEncodedContent() {
    return {
        type: undefined,
        parameters: {},
        fallback: undefined,
        compression: undefined,
        content: new Uint8Array()
    };
}
const EncodedContent = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.type !== undefined) ContentTypeId.encode(message.type, writer.uint32(10).fork()).ldelim();
        Object.entries(message.parameters).forEach(([key, value])=>{
            EncodedContent_ParametersEntry.encode({
                key: key,
                value
            }, writer.uint32(18).fork()).ldelim();
        });
        if (message.fallback !== undefined) writer.uint32(26).string(message.fallback);
        if (message.compression !== undefined) writer.uint32(40).int32(message.compression);
        if (message.content.length !== 0) writer.uint32(34).bytes(message.content);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncodedContent();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.type = ContentTypeId.decode(reader, reader.uint32());
                    break;
                case 2:
                    const entry2 = EncodedContent_ParametersEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) message.parameters[entry2.key] = entry2.value;
                    break;
                case 3:
                    message.fallback = reader.string();
                    break;
                case 5:
                    message.compression = reader.int32();
                    break;
                case 4:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            type: isSet(object.type) ? ContentTypeId.fromJSON(object.type) : undefined,
            parameters: isObject(object.parameters) ? Object.entries(object.parameters).reduce((acc, [key, value])=>{
                acc[key] = String(value);
                return acc;
            }, {}) : {},
            fallback: isSet(object.fallback) ? String(object.fallback) : undefined,
            compression: isSet(object.compression) ? compressionFromJSON(object.compression) : undefined,
            content: isSet(object.content) ? bytesFromBase64(object.content) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.type !== undefined && (obj.type = message.type ? ContentTypeId.toJSON(message.type) : undefined);
        obj.parameters = {};
        if (message.parameters) Object.entries(message.parameters).forEach(([k, v])=>{
            obj.parameters[k] = v;
        });
        message.fallback !== undefined && (obj.fallback = message.fallback);
        message.compression !== undefined && (obj.compression = message.compression !== undefined ? compressionToJSON(message.compression) : undefined);
        message.content !== undefined && (obj.content = base64FromBytes(message.content !== undefined ? message.content : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseEncodedContent();
        message.type = object.type !== undefined && object.type !== null ? ContentTypeId.fromPartial(object.type) : undefined;
        message.parameters = Object.entries((_a = object.parameters) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value])=>{
            if (value !== undefined) acc[key] = String(value);
            return acc;
        }, {});
        message.fallback = (_b = object.fallback) !== null && _b !== void 0 ? _b : undefined;
        message.compression = (_c = object.compression) !== null && _c !== void 0 ? _c : undefined;
        message.content = (_d = object.content) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
    }
};
function createBaseEncodedContent_ParametersEntry() {
    return {
        key: "",
        value: ""
    };
}
const EncodedContent_ParametersEntry = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.key !== "") writer.uint32(10).string(message.key);
        if (message.value !== "") writer.uint32(18).string(message.value);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncodedContent_ParametersEntry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? String(object.value) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseEncodedContent_ParametersEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseSignedContent() {
    return {
        payload: new Uint8Array(),
        sender: undefined,
        signature: undefined
    };
}
const SignedContent = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.payload.length !== 0) writer.uint32(10).bytes(message.payload);
        if (message.sender !== undefined) (0, _publicKeyPb.SignedPublicKeyBundle).encode(message.sender, writer.uint32(18).fork()).ldelim();
        if (message.signature !== undefined) (0, _signaturePb.Signature).encode(message.signature, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignedContent();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.payload = reader.bytes();
                    break;
                case 2:
                    message.sender = (0, _publicKeyPb.SignedPublicKeyBundle).decode(reader, reader.uint32());
                    break;
                case 3:
                    message.signature = (0, _signaturePb.Signature).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),
            sender: isSet(object.sender) ? (0, _publicKeyPb.SignedPublicKeyBundle).fromJSON(object.sender) : undefined,
            signature: isSet(object.signature) ? (0, _signaturePb.Signature).fromJSON(object.signature) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.payload !== undefined && (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        message.sender !== undefined && (obj.sender = message.sender ? (0, _publicKeyPb.SignedPublicKeyBundle).toJSON(message.sender) : undefined);
        message.signature !== undefined && (obj.signature = message.signature ? (0, _signaturePb.Signature).toJSON(message.signature) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSignedContent();
        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.sender = object.sender !== undefined && object.sender !== null ? (0, _publicKeyPb.SignedPublicKeyBundle).fromPartial(object.sender) : undefined;
        message.signature = object.signature !== undefined && object.signature !== null ? (0, _signaturePb.Signature).fromPartial(object.signature) : undefined;
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","./public_key.pb":"6Dba7","./signature.pb":"hvHvx","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fn5vw":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "FrameActionBody", ()=>FrameActionBody);
parcelHelpers.export(exports, "FrameAction", ()=>FrameAction);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _signaturePb = require("./signature.pb");
var _publicKeyPb = require("./public_key.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.message_contents";
function createBaseFrameActionBody() {
    return {
        frameUrl: "",
        buttonIndex: 0,
        timestamp: (0, _longDefault.default).UZERO,
        opaqueConversationIdentifier: "",
        unixTimestamp: 0,
        inputText: "",
        state: "",
        address: "",
        transactionId: ""
    };
}
const FrameActionBody = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.frameUrl !== "") writer.uint32(10).string(message.frameUrl);
        if (message.buttonIndex !== 0) writer.uint32(16).int32(message.buttonIndex);
        if (!message.timestamp.isZero()) writer.uint32(24).uint64(message.timestamp);
        if (message.opaqueConversationIdentifier !== "") writer.uint32(34).string(message.opaqueConversationIdentifier);
        if (message.unixTimestamp !== 0) writer.uint32(40).uint32(message.unixTimestamp);
        if (message.inputText !== "") writer.uint32(50).string(message.inputText);
        if (message.state !== "") writer.uint32(58).string(message.state);
        if (message.address !== "") writer.uint32(66).string(message.address);
        if (message.transactionId !== "") writer.uint32(74).string(message.transactionId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFrameActionBody();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.frameUrl = reader.string();
                    break;
                case 2:
                    message.buttonIndex = reader.int32();
                    break;
                case 3:
                    message.timestamp = reader.uint64();
                    break;
                case 4:
                    message.opaqueConversationIdentifier = reader.string();
                    break;
                case 5:
                    message.unixTimestamp = reader.uint32();
                    break;
                case 6:
                    message.inputText = reader.string();
                    break;
                case 7:
                    message.state = reader.string();
                    break;
                case 8:
                    message.address = reader.string();
                    break;
                case 9:
                    message.transactionId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            frameUrl: isSet(object.frameUrl) ? String(object.frameUrl) : "",
            buttonIndex: isSet(object.buttonIndex) ? Number(object.buttonIndex) : 0,
            timestamp: isSet(object.timestamp) ? (0, _longDefault.default).fromValue(object.timestamp) : (0, _longDefault.default).UZERO,
            opaqueConversationIdentifier: isSet(object.opaqueConversationIdentifier) ? String(object.opaqueConversationIdentifier) : "",
            unixTimestamp: isSet(object.unixTimestamp) ? Number(object.unixTimestamp) : 0,
            inputText: isSet(object.inputText) ? String(object.inputText) : "",
            state: isSet(object.state) ? String(object.state) : "",
            address: isSet(object.address) ? String(object.address) : "",
            transactionId: isSet(object.transactionId) ? String(object.transactionId) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.frameUrl !== undefined && (obj.frameUrl = message.frameUrl);
        message.buttonIndex !== undefined && (obj.buttonIndex = Math.round(message.buttonIndex));
        message.timestamp !== undefined && (obj.timestamp = (message.timestamp || (0, _longDefault.default).UZERO).toString());
        message.opaqueConversationIdentifier !== undefined && (obj.opaqueConversationIdentifier = message.opaqueConversationIdentifier);
        message.unixTimestamp !== undefined && (obj.unixTimestamp = Math.round(message.unixTimestamp));
        message.inputText !== undefined && (obj.inputText = message.inputText);
        message.state !== undefined && (obj.state = message.state);
        message.address !== undefined && (obj.address = message.address);
        message.transactionId !== undefined && (obj.transactionId = message.transactionId);
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const message = createBaseFrameActionBody();
        message.frameUrl = (_a = object.frameUrl) !== null && _a !== void 0 ? _a : "";
        message.buttonIndex = (_b = object.buttonIndex) !== null && _b !== void 0 ? _b : 0;
        message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? (0, _longDefault.default).fromValue(object.timestamp) : (0, _longDefault.default).UZERO;
        message.opaqueConversationIdentifier = (_c = object.opaqueConversationIdentifier) !== null && _c !== void 0 ? _c : "";
        message.unixTimestamp = (_d = object.unixTimestamp) !== null && _d !== void 0 ? _d : 0;
        message.inputText = (_e = object.inputText) !== null && _e !== void 0 ? _e : "";
        message.state = (_f = object.state) !== null && _f !== void 0 ? _f : "";
        message.address = (_g = object.address) !== null && _g !== void 0 ? _g : "";
        message.transactionId = (_h = object.transactionId) !== null && _h !== void 0 ? _h : "";
        return message;
    }
};
function createBaseFrameAction() {
    return {
        signature: undefined,
        signedPublicKeyBundle: undefined,
        actionBody: new Uint8Array(),
        installationSignature: new Uint8Array(),
        installationId: new Uint8Array(),
        inboxId: ""
    };
}
const FrameAction = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.signature !== undefined) (0, _signaturePb.Signature).encode(message.signature, writer.uint32(10).fork()).ldelim();
        if (message.signedPublicKeyBundle !== undefined) (0, _publicKeyPb.SignedPublicKeyBundle).encode(message.signedPublicKeyBundle, writer.uint32(18).fork()).ldelim();
        if (message.actionBody.length !== 0) writer.uint32(26).bytes(message.actionBody);
        if (message.installationSignature.length !== 0) writer.uint32(34).bytes(message.installationSignature);
        if (message.installationId.length !== 0) writer.uint32(42).bytes(message.installationId);
        if (message.inboxId !== "") writer.uint32(50).string(message.inboxId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFrameAction();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.signature = (0, _signaturePb.Signature).decode(reader, reader.uint32());
                    break;
                case 2:
                    message.signedPublicKeyBundle = (0, _publicKeyPb.SignedPublicKeyBundle).decode(reader, reader.uint32());
                    break;
                case 3:
                    message.actionBody = reader.bytes();
                    break;
                case 4:
                    message.installationSignature = reader.bytes();
                    break;
                case 5:
                    message.installationId = reader.bytes();
                    break;
                case 6:
                    message.inboxId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            signature: isSet(object.signature) ? (0, _signaturePb.Signature).fromJSON(object.signature) : undefined,
            signedPublicKeyBundle: isSet(object.signedPublicKeyBundle) ? (0, _publicKeyPb.SignedPublicKeyBundle).fromJSON(object.signedPublicKeyBundle) : undefined,
            actionBody: isSet(object.actionBody) ? bytesFromBase64(object.actionBody) : new Uint8Array(),
            installationSignature: isSet(object.installationSignature) ? bytesFromBase64(object.installationSignature) : new Uint8Array(),
            installationId: isSet(object.installationId) ? bytesFromBase64(object.installationId) : new Uint8Array(),
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.signature !== undefined && (obj.signature = message.signature ? (0, _signaturePb.Signature).toJSON(message.signature) : undefined);
        message.signedPublicKeyBundle !== undefined && (obj.signedPublicKeyBundle = message.signedPublicKeyBundle ? (0, _publicKeyPb.SignedPublicKeyBundle).toJSON(message.signedPublicKeyBundle) : undefined);
        message.actionBody !== undefined && (obj.actionBody = base64FromBytes(message.actionBody !== undefined ? message.actionBody : new Uint8Array()));
        message.installationSignature !== undefined && (obj.installationSignature = base64FromBytes(message.installationSignature !== undefined ? message.installationSignature : new Uint8Array()));
        message.installationId !== undefined && (obj.installationId = base64FromBytes(message.installationId !== undefined ? message.installationId : new Uint8Array()));
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseFrameAction();
        message.signature = object.signature !== undefined && object.signature !== null ? (0, _signaturePb.Signature).fromPartial(object.signature) : undefined;
        message.signedPublicKeyBundle = object.signedPublicKeyBundle !== undefined && object.signedPublicKeyBundle !== null ? (0, _publicKeyPb.SignedPublicKeyBundle).fromPartial(object.signedPublicKeyBundle) : undefined;
        message.actionBody = (_a = object.actionBody) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.installationSignature = (_b = object.installationSignature) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.installationId = (_c = object.installationId) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.inboxId = (_d = object.inboxId) !== null && _d !== void 0 ? _d : "";
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","./signature.pb":"hvHvx","./public_key.pb":"6Dba7","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fhpbS":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "Composite", ()=>Composite);
parcelHelpers.export(exports, "Composite_Part", ()=>Composite_Part);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _contentPb = require("./content.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
const protobufPackage = "xmtp.message_contents";
function createBaseComposite() {
    return {
        parts: []
    };
}
const Composite = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.parts)Composite_Part.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseComposite();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.parts.push(Composite_Part.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            parts: Array.isArray(object === null || object === void 0 ? void 0 : object.parts) ? object.parts.map((e)=>Composite_Part.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.parts) obj.parts = message.parts.map((e)=>e ? Composite_Part.toJSON(e) : undefined);
        else obj.parts = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseComposite();
        message.parts = ((_a = object.parts) === null || _a === void 0 ? void 0 : _a.map((e)=>Composite_Part.fromPartial(e))) || [];
        return message;
    }
};
function createBaseComposite_Part() {
    return {
        part: undefined,
        composite: undefined
    };
}
const Composite_Part = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.part !== undefined) (0, _contentPb.EncodedContent).encode(message.part, writer.uint32(10).fork()).ldelim();
        if (message.composite !== undefined) Composite.encode(message.composite, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseComposite_Part();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.part = (0, _contentPb.EncodedContent).decode(reader, reader.uint32());
                    break;
                case 2:
                    message.composite = Composite.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            part: isSet(object.part) ? (0, _contentPb.EncodedContent).fromJSON(object.part) : undefined,
            composite: isSet(object.composite) ? Composite.fromJSON(object.composite) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.part !== undefined && (obj.part = message.part ? (0, _contentPb.EncodedContent).toJSON(message.part) : undefined);
        message.composite !== undefined && (obj.composite = message.composite ? Composite.toJSON(message.composite) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseComposite_Part();
        message.part = object.part !== undefined && object.part !== null ? (0, _contentPb.EncodedContent).fromPartial(object.part) : undefined;
        message.composite = object.composite !== undefined && object.composite !== null ? Composite.fromPartial(object.composite) : undefined;
        return message;
    }
};
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","./content.pb":"2nRTw","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"11lga":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "SignedPrivateKey", ()=>SignedPrivateKey);
parcelHelpers.export(exports, "SignedPrivateKey_Secp256k1", ()=>SignedPrivateKey_Secp256k1);
parcelHelpers.export(exports, "PrivateKeyBundleV2", ()=>PrivateKeyBundleV2);
parcelHelpers.export(exports, "PrivateKey", ()=>PrivateKey);
parcelHelpers.export(exports, "PrivateKey_Secp256k1", ()=>PrivateKey_Secp256k1);
parcelHelpers.export(exports, "PrivateKeyBundleV1", ()=>PrivateKeyBundleV1);
parcelHelpers.export(exports, "PrivateKeyBundle", ()=>PrivateKeyBundle);
parcelHelpers.export(exports, "EncryptedPrivateKeyBundleV1", ()=>EncryptedPrivateKeyBundleV1);
parcelHelpers.export(exports, "EncryptedPrivateKeyBundle", ()=>EncryptedPrivateKeyBundle);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _publicKeyPb = require("./public_key.pb");
var _ciphertextPb = require("./ciphertext.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.message_contents";
function createBaseSignedPrivateKey() {
    return {
        createdNs: (0, _longDefault.default).UZERO,
        secp256k1: undefined,
        publicKey: undefined
    };
}
const SignedPrivateKey = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (!message.createdNs.isZero()) writer.uint32(8).uint64(message.createdNs);
        if (message.secp256k1 !== undefined) SignedPrivateKey_Secp256k1.encode(message.secp256k1, writer.uint32(18).fork()).ldelim();
        if (message.publicKey !== undefined) (0, _publicKeyPb.SignedPublicKey).encode(message.publicKey, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignedPrivateKey();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.createdNs = reader.uint64();
                    break;
                case 2:
                    message.secp256k1 = SignedPrivateKey_Secp256k1.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.publicKey = (0, _publicKeyPb.SignedPublicKey).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            createdNs: isSet(object.createdNs) ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO,
            secp256k1: isSet(object.secp256k1) ? SignedPrivateKey_Secp256k1.fromJSON(object.secp256k1) : undefined,
            publicKey: isSet(object.publicKey) ? (0, _publicKeyPb.SignedPublicKey).fromJSON(object.publicKey) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.createdNs !== undefined && (obj.createdNs = (message.createdNs || (0, _longDefault.default).UZERO).toString());
        message.secp256k1 !== undefined && (obj.secp256k1 = message.secp256k1 ? SignedPrivateKey_Secp256k1.toJSON(message.secp256k1) : undefined);
        message.publicKey !== undefined && (obj.publicKey = message.publicKey ? (0, _publicKeyPb.SignedPublicKey).toJSON(message.publicKey) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSignedPrivateKey();
        message.createdNs = object.createdNs !== undefined && object.createdNs !== null ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO;
        message.secp256k1 = object.secp256k1 !== undefined && object.secp256k1 !== null ? SignedPrivateKey_Secp256k1.fromPartial(object.secp256k1) : undefined;
        message.publicKey = object.publicKey !== undefined && object.publicKey !== null ? (0, _publicKeyPb.SignedPublicKey).fromPartial(object.publicKey) : undefined;
        return message;
    }
};
function createBaseSignedPrivateKey_Secp256k1() {
    return {
        bytes: new Uint8Array()
    };
}
const SignedPrivateKey_Secp256k1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.bytes.length !== 0) writer.uint32(10).bytes(message.bytes);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignedPrivateKey_Secp256k1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.bytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.bytes !== undefined && (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSignedPrivateKey_Secp256k1();
        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBasePrivateKeyBundleV2() {
    return {
        identityKey: undefined,
        preKeys: []
    };
}
const PrivateKeyBundleV2 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.identityKey !== undefined) SignedPrivateKey.encode(message.identityKey, writer.uint32(10).fork()).ldelim();
        for (const v of message.preKeys)SignedPrivateKey.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivateKeyBundleV2();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.identityKey = SignedPrivateKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.preKeys.push(SignedPrivateKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            identityKey: isSet(object.identityKey) ? SignedPrivateKey.fromJSON(object.identityKey) : undefined,
            preKeys: Array.isArray(object === null || object === void 0 ? void 0 : object.preKeys) ? object.preKeys.map((e)=>SignedPrivateKey.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        message.identityKey !== undefined && (obj.identityKey = message.identityKey ? SignedPrivateKey.toJSON(message.identityKey) : undefined);
        if (message.preKeys) obj.preKeys = message.preKeys.map((e)=>e ? SignedPrivateKey.toJSON(e) : undefined);
        else obj.preKeys = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBasePrivateKeyBundleV2();
        message.identityKey = object.identityKey !== undefined && object.identityKey !== null ? SignedPrivateKey.fromPartial(object.identityKey) : undefined;
        message.preKeys = ((_a = object.preKeys) === null || _a === void 0 ? void 0 : _a.map((e)=>SignedPrivateKey.fromPartial(e))) || [];
        return message;
    }
};
function createBasePrivateKey() {
    return {
        timestamp: (0, _longDefault.default).UZERO,
        secp256k1: undefined,
        publicKey: undefined
    };
}
const PrivateKey = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (!message.timestamp.isZero()) writer.uint32(8).uint64(message.timestamp);
        if (message.secp256k1 !== undefined) PrivateKey_Secp256k1.encode(message.secp256k1, writer.uint32(18).fork()).ldelim();
        if (message.publicKey !== undefined) (0, _publicKeyPb.PublicKey).encode(message.publicKey, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivateKey();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.timestamp = reader.uint64();
                    break;
                case 2:
                    message.secp256k1 = PrivateKey_Secp256k1.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.publicKey = (0, _publicKeyPb.PublicKey).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            timestamp: isSet(object.timestamp) ? (0, _longDefault.default).fromValue(object.timestamp) : (0, _longDefault.default).UZERO,
            secp256k1: isSet(object.secp256k1) ? PrivateKey_Secp256k1.fromJSON(object.secp256k1) : undefined,
            publicKey: isSet(object.publicKey) ? (0, _publicKeyPb.PublicKey).fromJSON(object.publicKey) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.timestamp !== undefined && (obj.timestamp = (message.timestamp || (0, _longDefault.default).UZERO).toString());
        message.secp256k1 !== undefined && (obj.secp256k1 = message.secp256k1 ? PrivateKey_Secp256k1.toJSON(message.secp256k1) : undefined);
        message.publicKey !== undefined && (obj.publicKey = message.publicKey ? (0, _publicKeyPb.PublicKey).toJSON(message.publicKey) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePrivateKey();
        message.timestamp = object.timestamp !== undefined && object.timestamp !== null ? (0, _longDefault.default).fromValue(object.timestamp) : (0, _longDefault.default).UZERO;
        message.secp256k1 = object.secp256k1 !== undefined && object.secp256k1 !== null ? PrivateKey_Secp256k1.fromPartial(object.secp256k1) : undefined;
        message.publicKey = object.publicKey !== undefined && object.publicKey !== null ? (0, _publicKeyPb.PublicKey).fromPartial(object.publicKey) : undefined;
        return message;
    }
};
function createBasePrivateKey_Secp256k1() {
    return {
        bytes: new Uint8Array()
    };
}
const PrivateKey_Secp256k1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.bytes.length !== 0) writer.uint32(10).bytes(message.bytes);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivateKey_Secp256k1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.bytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.bytes !== undefined && (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBasePrivateKey_Secp256k1();
        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBasePrivateKeyBundleV1() {
    return {
        identityKey: undefined,
        preKeys: []
    };
}
const PrivateKeyBundleV1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.identityKey !== undefined) PrivateKey.encode(message.identityKey, writer.uint32(10).fork()).ldelim();
        for (const v of message.preKeys)PrivateKey.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivateKeyBundleV1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.identityKey = PrivateKey.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.preKeys.push(PrivateKey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            identityKey: isSet(object.identityKey) ? PrivateKey.fromJSON(object.identityKey) : undefined,
            preKeys: Array.isArray(object === null || object === void 0 ? void 0 : object.preKeys) ? object.preKeys.map((e)=>PrivateKey.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        message.identityKey !== undefined && (obj.identityKey = message.identityKey ? PrivateKey.toJSON(message.identityKey) : undefined);
        if (message.preKeys) obj.preKeys = message.preKeys.map((e)=>e ? PrivateKey.toJSON(e) : undefined);
        else obj.preKeys = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBasePrivateKeyBundleV1();
        message.identityKey = object.identityKey !== undefined && object.identityKey !== null ? PrivateKey.fromPartial(object.identityKey) : undefined;
        message.preKeys = ((_a = object.preKeys) === null || _a === void 0 ? void 0 : _a.map((e)=>PrivateKey.fromPartial(e))) || [];
        return message;
    }
};
function createBasePrivateKeyBundle() {
    return {
        v1: undefined,
        v2: undefined
    };
}
const PrivateKeyBundle = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) PrivateKeyBundleV1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        if (message.v2 !== undefined) PrivateKeyBundleV2.encode(message.v2, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivateKeyBundle();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = PrivateKeyBundleV1.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.v2 = PrivateKeyBundleV2.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? PrivateKeyBundleV1.fromJSON(object.v1) : undefined,
            v2: isSet(object.v2) ? PrivateKeyBundleV2.fromJSON(object.v2) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? PrivateKeyBundleV1.toJSON(message.v1) : undefined);
        message.v2 !== undefined && (obj.v2 = message.v2 ? PrivateKeyBundleV2.toJSON(message.v2) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePrivateKeyBundle();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? PrivateKeyBundleV1.fromPartial(object.v1) : undefined;
        message.v2 = object.v2 !== undefined && object.v2 !== null ? PrivateKeyBundleV2.fromPartial(object.v2) : undefined;
        return message;
    }
};
function createBaseEncryptedPrivateKeyBundleV1() {
    return {
        walletPreKey: new Uint8Array(),
        ciphertext: undefined
    };
}
const EncryptedPrivateKeyBundleV1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.walletPreKey.length !== 0) writer.uint32(10).bytes(message.walletPreKey);
        if (message.ciphertext !== undefined) (0, _ciphertextPb.Ciphertext).encode(message.ciphertext, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncryptedPrivateKeyBundleV1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.walletPreKey = reader.bytes();
                    break;
                case 2:
                    message.ciphertext = (0, _ciphertextPb.Ciphertext).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            walletPreKey: isSet(object.walletPreKey) ? bytesFromBase64(object.walletPreKey) : new Uint8Array(),
            ciphertext: isSet(object.ciphertext) ? (0, _ciphertextPb.Ciphertext).fromJSON(object.ciphertext) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.walletPreKey !== undefined && (obj.walletPreKey = base64FromBytes(message.walletPreKey !== undefined ? message.walletPreKey : new Uint8Array()));
        message.ciphertext !== undefined && (obj.ciphertext = message.ciphertext ? (0, _ciphertextPb.Ciphertext).toJSON(message.ciphertext) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseEncryptedPrivateKeyBundleV1();
        message.walletPreKey = (_a = object.walletPreKey) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.ciphertext = object.ciphertext !== undefined && object.ciphertext !== null ? (0, _ciphertextPb.Ciphertext).fromPartial(object.ciphertext) : undefined;
        return message;
    }
};
function createBaseEncryptedPrivateKeyBundle() {
    return {
        v1: undefined
    };
}
const EncryptedPrivateKeyBundle = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) EncryptedPrivateKeyBundleV1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncryptedPrivateKeyBundle();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = EncryptedPrivateKeyBundleV1.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? EncryptedPrivateKeyBundleV1.fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? EncryptedPrivateKeyBundleV1.toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseEncryptedPrivateKeyBundle();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? EncryptedPrivateKeyBundleV1.fromPartial(object.v1) : undefined;
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","./public_key.pb":"6Dba7","./ciphertext.pb":"dkFEI","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8eJQP":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "ContactBundleV1", ()=>ContactBundleV1);
parcelHelpers.export(exports, "ContactBundleV2", ()=>ContactBundleV2);
parcelHelpers.export(exports, "ContactBundle", ()=>ContactBundle);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _publicKeyPb = require("./public_key.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
const protobufPackage = "xmtp.message_contents";
function createBaseContactBundleV1() {
    return {
        keyBundle: undefined
    };
}
const ContactBundleV1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.keyBundle !== undefined) (0, _publicKeyPb.PublicKeyBundle).encode(message.keyBundle, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContactBundleV1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyBundle = (0, _publicKeyPb.PublicKeyBundle).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            keyBundle: isSet(object.keyBundle) ? (0, _publicKeyPb.PublicKeyBundle).fromJSON(object.keyBundle) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.keyBundle !== undefined && (obj.keyBundle = message.keyBundle ? (0, _publicKeyPb.PublicKeyBundle).toJSON(message.keyBundle) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseContactBundleV1();
        message.keyBundle = object.keyBundle !== undefined && object.keyBundle !== null ? (0, _publicKeyPb.PublicKeyBundle).fromPartial(object.keyBundle) : undefined;
        return message;
    }
};
function createBaseContactBundleV2() {
    return {
        keyBundle: undefined
    };
}
const ContactBundleV2 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.keyBundle !== undefined) (0, _publicKeyPb.SignedPublicKeyBundle).encode(message.keyBundle, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContactBundleV2();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyBundle = (0, _publicKeyPb.SignedPublicKeyBundle).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            keyBundle: isSet(object.keyBundle) ? (0, _publicKeyPb.SignedPublicKeyBundle).fromJSON(object.keyBundle) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.keyBundle !== undefined && (obj.keyBundle = message.keyBundle ? (0, _publicKeyPb.SignedPublicKeyBundle).toJSON(message.keyBundle) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseContactBundleV2();
        message.keyBundle = object.keyBundle !== undefined && object.keyBundle !== null ? (0, _publicKeyPb.SignedPublicKeyBundle).fromPartial(object.keyBundle) : undefined;
        return message;
    }
};
function createBaseContactBundle() {
    return {
        v1: undefined,
        v2: undefined
    };
}
const ContactBundle = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) ContactBundleV1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        if (message.v2 !== undefined) ContactBundleV2.encode(message.v2, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContactBundle();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = ContactBundleV1.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.v2 = ContactBundleV2.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? ContactBundleV1.fromJSON(object.v1) : undefined,
            v2: isSet(object.v2) ? ContactBundleV2.fromJSON(object.v2) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? ContactBundleV1.toJSON(message.v1) : undefined);
        message.v2 !== undefined && (obj.v2 = message.v2 ? ContactBundleV2.toJSON(message.v2) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseContactBundle();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? ContactBundleV1.fromPartial(object.v1) : undefined;
        message.v2 = object.v2 !== undefined && object.v2 !== null ? ContactBundleV2.fromPartial(object.v2) : undefined;
        return message;
    }
};
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","./public_key.pb":"6Dba7","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hVmoL":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "ErrorCode", ()=>ErrorCode);
parcelHelpers.export(exports, "errorCodeFromJSON", ()=>errorCodeFromJSON);
parcelHelpers.export(exports, "errorCodeToJSON", ()=>errorCodeToJSON);
parcelHelpers.export(exports, "JobType", ()=>JobType);
parcelHelpers.export(exports, "jobTypeFromJSON", ()=>jobTypeFromJSON);
parcelHelpers.export(exports, "jobTypeToJSON", ()=>jobTypeToJSON);
parcelHelpers.export(exports, "GetKeystoreStatusResponse_KeystoreStatus", ()=>GetKeystoreStatusResponse_KeystoreStatus);
parcelHelpers.export(exports, "getKeystoreStatusResponse_KeystoreStatusFromJSON", ()=>getKeystoreStatusResponse_KeystoreStatusFromJSON);
parcelHelpers.export(exports, "getKeystoreStatusResponse_KeystoreStatusToJSON", ()=>getKeystoreStatusResponse_KeystoreStatusToJSON);
parcelHelpers.export(exports, "KeystoreError", ()=>KeystoreError);
parcelHelpers.export(exports, "DecryptV1Request", ()=>DecryptV1Request);
parcelHelpers.export(exports, "DecryptV1Request_Request", ()=>DecryptV1Request_Request);
parcelHelpers.export(exports, "DecryptResponse", ()=>DecryptResponse);
parcelHelpers.export(exports, "DecryptResponse_Response", ()=>DecryptResponse_Response);
parcelHelpers.export(exports, "DecryptResponse_Response_Success", ()=>DecryptResponse_Response_Success);
parcelHelpers.export(exports, "DecryptV2Request", ()=>DecryptV2Request);
parcelHelpers.export(exports, "DecryptV2Request_Request", ()=>DecryptV2Request_Request);
parcelHelpers.export(exports, "EncryptV1Request", ()=>EncryptV1Request);
parcelHelpers.export(exports, "EncryptV1Request_Request", ()=>EncryptV1Request_Request);
parcelHelpers.export(exports, "EncryptResponse", ()=>EncryptResponse);
parcelHelpers.export(exports, "EncryptResponse_Response", ()=>EncryptResponse_Response);
parcelHelpers.export(exports, "EncryptResponse_Response_Success", ()=>EncryptResponse_Response_Success);
parcelHelpers.export(exports, "EncryptV2Request", ()=>EncryptV2Request);
parcelHelpers.export(exports, "EncryptV2Request_Request", ()=>EncryptV2Request_Request);
parcelHelpers.export(exports, "SelfEncryptRequest", ()=>SelfEncryptRequest);
parcelHelpers.export(exports, "SelfEncryptRequest_Request", ()=>SelfEncryptRequest_Request);
parcelHelpers.export(exports, "SelfEncryptResponse", ()=>SelfEncryptResponse);
parcelHelpers.export(exports, "SelfEncryptResponse_Response", ()=>SelfEncryptResponse_Response);
parcelHelpers.export(exports, "SelfEncryptResponse_Response_Success", ()=>SelfEncryptResponse_Response_Success);
parcelHelpers.export(exports, "SelfDecryptRequest", ()=>SelfDecryptRequest);
parcelHelpers.export(exports, "SelfDecryptRequest_Request", ()=>SelfDecryptRequest_Request);
parcelHelpers.export(exports, "GetPrivatePreferencesTopicIdentifierResponse", ()=>GetPrivatePreferencesTopicIdentifierResponse);
parcelHelpers.export(exports, "CreateInviteRequest", ()=>CreateInviteRequest);
parcelHelpers.export(exports, "CreateInviteResponse", ()=>CreateInviteResponse);
parcelHelpers.export(exports, "SaveInvitesRequest", ()=>SaveInvitesRequest);
parcelHelpers.export(exports, "SaveInvitesRequest_Request", ()=>SaveInvitesRequest_Request);
parcelHelpers.export(exports, "SaveInvitesResponse", ()=>SaveInvitesResponse);
parcelHelpers.export(exports, "SaveInvitesResponse_Response", ()=>SaveInvitesResponse_Response);
parcelHelpers.export(exports, "SaveInvitesResponse_Response_Success", ()=>SaveInvitesResponse_Response_Success);
parcelHelpers.export(exports, "CreateAuthTokenRequest", ()=>CreateAuthTokenRequest);
parcelHelpers.export(exports, "SaveV1ConversationsRequest", ()=>SaveV1ConversationsRequest);
parcelHelpers.export(exports, "SaveV1ConversationsResponse", ()=>SaveV1ConversationsResponse);
parcelHelpers.export(exports, "GetConversationsResponse", ()=>GetConversationsResponse);
parcelHelpers.export(exports, "GetKeystoreStatusRequest", ()=>GetKeystoreStatusRequest);
parcelHelpers.export(exports, "GetKeystoreStatusResponse", ()=>GetKeystoreStatusResponse);
parcelHelpers.export(exports, "InitKeystoreRequest", ()=>InitKeystoreRequest);
parcelHelpers.export(exports, "InitKeystoreResponse", ()=>InitKeystoreResponse);
parcelHelpers.export(exports, "SignDigestRequest", ()=>SignDigestRequest);
parcelHelpers.export(exports, "GetRefreshJobRequest", ()=>GetRefreshJobRequest);
parcelHelpers.export(exports, "GetRefreshJobResponse", ()=>GetRefreshJobResponse);
parcelHelpers.export(exports, "SetRefeshJobRequest", ()=>SetRefeshJobRequest);
parcelHelpers.export(exports, "SetRefreshJobResponse", ()=>SetRefreshJobResponse);
parcelHelpers.export(exports, "TopicMap", ()=>TopicMap);
parcelHelpers.export(exports, "TopicMap_TopicData", ()=>TopicMap_TopicData);
parcelHelpers.export(exports, "TopicMap_TopicsEntry", ()=>TopicMap_TopicsEntry);
parcelHelpers.export(exports, "GetConversationHmacKeysRequest", ()=>GetConversationHmacKeysRequest);
parcelHelpers.export(exports, "GetConversationHmacKeysResponse", ()=>GetConversationHmacKeysResponse);
parcelHelpers.export(exports, "GetConversationHmacKeysResponse_HmacKeyData", ()=>GetConversationHmacKeysResponse_HmacKeyData);
parcelHelpers.export(exports, "GetConversationHmacKeysResponse_HmacKeys", ()=>GetConversationHmacKeysResponse_HmacKeys);
parcelHelpers.export(exports, "GetConversationHmacKeysResponse_HmacKeysEntry", ()=>GetConversationHmacKeysResponse_HmacKeysEntry);
parcelHelpers.export(exports, "PrivatePreferencesActionMap", ()=>PrivatePreferencesActionMap);
parcelHelpers.export(exports, "PrivatePreferencesActionMap_ActionsEntry", ()=>PrivatePreferencesActionMap_ActionsEntry);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _ciphertextPb = require("../../message_contents/ciphertext.pb");
var _publicKeyPb = require("../../message_contents/public_key.pb");
var _invitationPb = require("../../message_contents/invitation.pb");
var _conversationReferencePb = require("../../message_contents/conversation_reference.pb");
var _privateKeyPb = require("../../message_contents/private_key.pb");
var _privatePreferencesPb = require("../../message_contents/private_preferences.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.keystore_api.v1";
var ErrorCode;
(function(ErrorCode) {
    ErrorCode[ErrorCode["ERROR_CODE_UNSPECIFIED"] = 0] = "ERROR_CODE_UNSPECIFIED";
    ErrorCode[ErrorCode["ERROR_CODE_INVALID_INPUT"] = 1] = "ERROR_CODE_INVALID_INPUT";
    ErrorCode[ErrorCode["ERROR_CODE_NO_MATCHING_PREKEY"] = 2] = "ERROR_CODE_NO_MATCHING_PREKEY";
    ErrorCode[ErrorCode["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ErrorCode || (ErrorCode = {}));
function errorCodeFromJSON(object) {
    switch(object){
        case 0:
        case "ERROR_CODE_UNSPECIFIED":
            return ErrorCode.ERROR_CODE_UNSPECIFIED;
        case 1:
        case "ERROR_CODE_INVALID_INPUT":
            return ErrorCode.ERROR_CODE_INVALID_INPUT;
        case 2:
        case "ERROR_CODE_NO_MATCHING_PREKEY":
            return ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ErrorCode.UNRECOGNIZED;
    }
}
function errorCodeToJSON(object) {
    switch(object){
        case ErrorCode.ERROR_CODE_UNSPECIFIED:
            return "ERROR_CODE_UNSPECIFIED";
        case ErrorCode.ERROR_CODE_INVALID_INPUT:
            return "ERROR_CODE_INVALID_INPUT";
        case ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY:
            return "ERROR_CODE_NO_MATCHING_PREKEY";
        case ErrorCode.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var JobType;
(function(JobType) {
    JobType[JobType["JOB_TYPE_UNSPECIFIED"] = 0] = "JOB_TYPE_UNSPECIFIED";
    JobType[JobType["JOB_TYPE_REFRESH_V1"] = 1] = "JOB_TYPE_REFRESH_V1";
    JobType[JobType["JOB_TYPE_REFRESH_V2"] = 2] = "JOB_TYPE_REFRESH_V2";
    JobType[JobType["JOB_TYPE_REFRESH_PPPP"] = 3] = "JOB_TYPE_REFRESH_PPPP";
    JobType[JobType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(JobType || (JobType = {}));
function jobTypeFromJSON(object) {
    switch(object){
        case 0:
        case "JOB_TYPE_UNSPECIFIED":
            return JobType.JOB_TYPE_UNSPECIFIED;
        case 1:
        case "JOB_TYPE_REFRESH_V1":
            return JobType.JOB_TYPE_REFRESH_V1;
        case 2:
        case "JOB_TYPE_REFRESH_V2":
            return JobType.JOB_TYPE_REFRESH_V2;
        case 3:
        case "JOB_TYPE_REFRESH_PPPP":
            return JobType.JOB_TYPE_REFRESH_PPPP;
        case -1:
        case "UNRECOGNIZED":
        default:
            return JobType.UNRECOGNIZED;
    }
}
function jobTypeToJSON(object) {
    switch(object){
        case JobType.JOB_TYPE_UNSPECIFIED:
            return "JOB_TYPE_UNSPECIFIED";
        case JobType.JOB_TYPE_REFRESH_V1:
            return "JOB_TYPE_REFRESH_V1";
        case JobType.JOB_TYPE_REFRESH_V2:
            return "JOB_TYPE_REFRESH_V2";
        case JobType.JOB_TYPE_REFRESH_PPPP:
            return "JOB_TYPE_REFRESH_PPPP";
        case JobType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var GetKeystoreStatusResponse_KeystoreStatus;
(function(GetKeystoreStatusResponse_KeystoreStatus) {
    GetKeystoreStatusResponse_KeystoreStatus[GetKeystoreStatusResponse_KeystoreStatus["KEYSTORE_STATUS_UNSPECIFIED"] = 0] = "KEYSTORE_STATUS_UNSPECIFIED";
    GetKeystoreStatusResponse_KeystoreStatus[GetKeystoreStatusResponse_KeystoreStatus["KEYSTORE_STATUS_UNINITIALIZED"] = 1] = "KEYSTORE_STATUS_UNINITIALIZED";
    GetKeystoreStatusResponse_KeystoreStatus[GetKeystoreStatusResponse_KeystoreStatus["KEYSTORE_STATUS_INITIALIZED"] = 2] = "KEYSTORE_STATUS_INITIALIZED";
    GetKeystoreStatusResponse_KeystoreStatus[GetKeystoreStatusResponse_KeystoreStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(GetKeystoreStatusResponse_KeystoreStatus || (GetKeystoreStatusResponse_KeystoreStatus = {}));
function getKeystoreStatusResponse_KeystoreStatusFromJSON(object) {
    switch(object){
        case 0:
        case "KEYSTORE_STATUS_UNSPECIFIED":
            return GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_UNSPECIFIED;
        case 1:
        case "KEYSTORE_STATUS_UNINITIALIZED":
            return GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_UNINITIALIZED;
        case 2:
        case "KEYSTORE_STATUS_INITIALIZED":
            return GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_INITIALIZED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return GetKeystoreStatusResponse_KeystoreStatus.UNRECOGNIZED;
    }
}
function getKeystoreStatusResponse_KeystoreStatusToJSON(object) {
    switch(object){
        case GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_UNSPECIFIED:
            return "KEYSTORE_STATUS_UNSPECIFIED";
        case GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_UNINITIALIZED:
            return "KEYSTORE_STATUS_UNINITIALIZED";
        case GetKeystoreStatusResponse_KeystoreStatus.KEYSTORE_STATUS_INITIALIZED:
            return "KEYSTORE_STATUS_INITIALIZED";
        case GetKeystoreStatusResponse_KeystoreStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseKeystoreError() {
    return {
        message: "",
        code: 0
    };
}
const KeystoreError = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.message !== "") writer.uint32(10).string(message.message);
        if (message.code !== 0) writer.uint32(16).int32(message.code);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeystoreError();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.message = reader.string();
                    break;
                case 2:
                    message.code = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            message: isSet(object.message) ? String(object.message) : "",
            code: isSet(object.code) ? errorCodeFromJSON(object.code) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        message.message !== undefined && (obj.message = message.message);
        message.code !== undefined && (obj.code = errorCodeToJSON(message.code));
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseKeystoreError();
        message.message = (_a = object.message) !== null && _a !== void 0 ? _a : "";
        message.code = (_b = object.code) !== null && _b !== void 0 ? _b : 0;
        return message;
    }
};
function createBaseDecryptV1Request() {
    return {
        requests: []
    };
}
const DecryptV1Request = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.requests)DecryptV1Request_Request.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecryptV1Request();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.requests.push(DecryptV1Request_Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests) ? object.requests.map((e)=>DecryptV1Request_Request.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.requests) obj.requests = message.requests.map((e)=>e ? DecryptV1Request_Request.toJSON(e) : undefined);
        else obj.requests = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseDecryptV1Request();
        message.requests = ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e)=>DecryptV1Request_Request.fromPartial(e))) || [];
        return message;
    }
};
function createBaseDecryptV1Request_Request() {
    return {
        payload: undefined,
        peerKeys: undefined,
        headerBytes: new Uint8Array(),
        isSender: false
    };
}
const DecryptV1Request_Request = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.payload !== undefined) (0, _ciphertextPb.Ciphertext).encode(message.payload, writer.uint32(10).fork()).ldelim();
        if (message.peerKeys !== undefined) (0, _publicKeyPb.PublicKeyBundle).encode(message.peerKeys, writer.uint32(18).fork()).ldelim();
        if (message.headerBytes.length !== 0) writer.uint32(26).bytes(message.headerBytes);
        if (message.isSender === true) writer.uint32(32).bool(message.isSender);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecryptV1Request_Request();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.payload = (0, _ciphertextPb.Ciphertext).decode(reader, reader.uint32());
                    break;
                case 2:
                    message.peerKeys = (0, _publicKeyPb.PublicKeyBundle).decode(reader, reader.uint32());
                    break;
                case 3:
                    message.headerBytes = reader.bytes();
                    break;
                case 4:
                    message.isSender = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            payload: isSet(object.payload) ? (0, _ciphertextPb.Ciphertext).fromJSON(object.payload) : undefined,
            peerKeys: isSet(object.peerKeys) ? (0, _publicKeyPb.PublicKeyBundle).fromJSON(object.peerKeys) : undefined,
            headerBytes: isSet(object.headerBytes) ? bytesFromBase64(object.headerBytes) : new Uint8Array(),
            isSender: isSet(object.isSender) ? Boolean(object.isSender) : false
        };
    },
    toJSON (message) {
        const obj = {};
        message.payload !== undefined && (obj.payload = message.payload ? (0, _ciphertextPb.Ciphertext).toJSON(message.payload) : undefined);
        message.peerKeys !== undefined && (obj.peerKeys = message.peerKeys ? (0, _publicKeyPb.PublicKeyBundle).toJSON(message.peerKeys) : undefined);
        message.headerBytes !== undefined && (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined ? message.headerBytes : new Uint8Array()));
        message.isSender !== undefined && (obj.isSender = message.isSender);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseDecryptV1Request_Request();
        message.payload = object.payload !== undefined && object.payload !== null ? (0, _ciphertextPb.Ciphertext).fromPartial(object.payload) : undefined;
        message.peerKeys = object.peerKeys !== undefined && object.peerKeys !== null ? (0, _publicKeyPb.PublicKeyBundle).fromPartial(object.peerKeys) : undefined;
        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.isSender = (_b = object.isSender) !== null && _b !== void 0 ? _b : false;
        return message;
    }
};
function createBaseDecryptResponse() {
    return {
        responses: []
    };
}
const DecryptResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.responses)DecryptResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecryptResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.responses.push(DecryptResponse_Response.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses) ? object.responses.map((e)=>DecryptResponse_Response.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.responses) obj.responses = message.responses.map((e)=>e ? DecryptResponse_Response.toJSON(e) : undefined);
        else obj.responses = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseDecryptResponse();
        message.responses = ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e)=>DecryptResponse_Response.fromPartial(e))) || [];
        return message;
    }
};
function createBaseDecryptResponse_Response() {
    return {
        result: undefined,
        error: undefined
    };
}
const DecryptResponse_Response = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.result !== undefined) DecryptResponse_Response_Success.encode(message.result, writer.uint32(10).fork()).ldelim();
        if (message.error !== undefined) KeystoreError.encode(message.error, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecryptResponse_Response();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.result = DecryptResponse_Response_Success.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.error = KeystoreError.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            result: isSet(object.result) ? DecryptResponse_Response_Success.fromJSON(object.result) : undefined,
            error: isSet(object.error) ? KeystoreError.fromJSON(object.error) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.result !== undefined && (obj.result = message.result ? DecryptResponse_Response_Success.toJSON(message.result) : undefined);
        message.error !== undefined && (obj.error = message.error ? KeystoreError.toJSON(message.error) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDecryptResponse_Response();
        message.result = object.result !== undefined && object.result !== null ? DecryptResponse_Response_Success.fromPartial(object.result) : undefined;
        message.error = object.error !== undefined && object.error !== null ? KeystoreError.fromPartial(object.error) : undefined;
        return message;
    }
};
function createBaseDecryptResponse_Response_Success() {
    return {
        decrypted: new Uint8Array()
    };
}
const DecryptResponse_Response_Success = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.decrypted.length !== 0) writer.uint32(10).bytes(message.decrypted);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecryptResponse_Response_Success();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.decrypted = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            decrypted: isSet(object.decrypted) ? bytesFromBase64(object.decrypted) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.decrypted !== undefined && (obj.decrypted = base64FromBytes(message.decrypted !== undefined ? message.decrypted : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseDecryptResponse_Response_Success();
        message.decrypted = (_a = object.decrypted) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseDecryptV2Request() {
    return {
        requests: []
    };
}
const DecryptV2Request = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.requests)DecryptV2Request_Request.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecryptV2Request();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.requests.push(DecryptV2Request_Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests) ? object.requests.map((e)=>DecryptV2Request_Request.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.requests) obj.requests = message.requests.map((e)=>e ? DecryptV2Request_Request.toJSON(e) : undefined);
        else obj.requests = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseDecryptV2Request();
        message.requests = ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e)=>DecryptV2Request_Request.fromPartial(e))) || [];
        return message;
    }
};
function createBaseDecryptV2Request_Request() {
    return {
        payload: undefined,
        headerBytes: new Uint8Array(),
        contentTopic: ""
    };
}
const DecryptV2Request_Request = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.payload !== undefined) (0, _ciphertextPb.Ciphertext).encode(message.payload, writer.uint32(10).fork()).ldelim();
        if (message.headerBytes.length !== 0) writer.uint32(18).bytes(message.headerBytes);
        if (message.contentTopic !== "") writer.uint32(26).string(message.contentTopic);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecryptV2Request_Request();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.payload = (0, _ciphertextPb.Ciphertext).decode(reader, reader.uint32());
                    break;
                case 2:
                    message.headerBytes = reader.bytes();
                    break;
                case 3:
                    message.contentTopic = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            payload: isSet(object.payload) ? (0, _ciphertextPb.Ciphertext).fromJSON(object.payload) : undefined,
            headerBytes: isSet(object.headerBytes) ? bytesFromBase64(object.headerBytes) : new Uint8Array(),
            contentTopic: isSet(object.contentTopic) ? String(object.contentTopic) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.payload !== undefined && (obj.payload = message.payload ? (0, _ciphertextPb.Ciphertext).toJSON(message.payload) : undefined);
        message.headerBytes !== undefined && (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined ? message.headerBytes : new Uint8Array()));
        message.contentTopic !== undefined && (obj.contentTopic = message.contentTopic);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseDecryptV2Request_Request();
        message.payload = object.payload !== undefined && object.payload !== null ? (0, _ciphertextPb.Ciphertext).fromPartial(object.payload) : undefined;
        message.headerBytes = (_a = object.headerBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.contentTopic = (_b = object.contentTopic) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseEncryptV1Request() {
    return {
        requests: []
    };
}
const EncryptV1Request = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.requests)EncryptV1Request_Request.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncryptV1Request();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.requests.push(EncryptV1Request_Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests) ? object.requests.map((e)=>EncryptV1Request_Request.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.requests) obj.requests = message.requests.map((e)=>e ? EncryptV1Request_Request.toJSON(e) : undefined);
        else obj.requests = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseEncryptV1Request();
        message.requests = ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e)=>EncryptV1Request_Request.fromPartial(e))) || [];
        return message;
    }
};
function createBaseEncryptV1Request_Request() {
    return {
        recipient: undefined,
        payload: new Uint8Array(),
        headerBytes: new Uint8Array()
    };
}
const EncryptV1Request_Request = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.recipient !== undefined) (0, _publicKeyPb.PublicKeyBundle).encode(message.recipient, writer.uint32(10).fork()).ldelim();
        if (message.payload.length !== 0) writer.uint32(18).bytes(message.payload);
        if (message.headerBytes.length !== 0) writer.uint32(26).bytes(message.headerBytes);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncryptV1Request_Request();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.recipient = (0, _publicKeyPb.PublicKeyBundle).decode(reader, reader.uint32());
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                case 3:
                    message.headerBytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            recipient: isSet(object.recipient) ? (0, _publicKeyPb.PublicKeyBundle).fromJSON(object.recipient) : undefined,
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),
            headerBytes: isSet(object.headerBytes) ? bytesFromBase64(object.headerBytes) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.recipient !== undefined && (obj.recipient = message.recipient ? (0, _publicKeyPb.PublicKeyBundle).toJSON(message.recipient) : undefined);
        message.payload !== undefined && (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        message.headerBytes !== undefined && (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined ? message.headerBytes : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseEncryptV1Request_Request();
        message.recipient = object.recipient !== undefined && object.recipient !== null ? (0, _publicKeyPb.PublicKeyBundle).fromPartial(object.recipient) : undefined;
        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.headerBytes = (_b = object.headerBytes) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    }
};
function createBaseEncryptResponse() {
    return {
        responses: []
    };
}
const EncryptResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.responses)EncryptResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncryptResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.responses.push(EncryptResponse_Response.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses) ? object.responses.map((e)=>EncryptResponse_Response.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.responses) obj.responses = message.responses.map((e)=>e ? EncryptResponse_Response.toJSON(e) : undefined);
        else obj.responses = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseEncryptResponse();
        message.responses = ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e)=>EncryptResponse_Response.fromPartial(e))) || [];
        return message;
    }
};
function createBaseEncryptResponse_Response() {
    return {
        result: undefined,
        error: undefined
    };
}
const EncryptResponse_Response = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.result !== undefined) EncryptResponse_Response_Success.encode(message.result, writer.uint32(10).fork()).ldelim();
        if (message.error !== undefined) KeystoreError.encode(message.error, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncryptResponse_Response();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.result = EncryptResponse_Response_Success.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.error = KeystoreError.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            result: isSet(object.result) ? EncryptResponse_Response_Success.fromJSON(object.result) : undefined,
            error: isSet(object.error) ? KeystoreError.fromJSON(object.error) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.result !== undefined && (obj.result = message.result ? EncryptResponse_Response_Success.toJSON(message.result) : undefined);
        message.error !== undefined && (obj.error = message.error ? KeystoreError.toJSON(message.error) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseEncryptResponse_Response();
        message.result = object.result !== undefined && object.result !== null ? EncryptResponse_Response_Success.fromPartial(object.result) : undefined;
        message.error = object.error !== undefined && object.error !== null ? KeystoreError.fromPartial(object.error) : undefined;
        return message;
    }
};
function createBaseEncryptResponse_Response_Success() {
    return {
        encrypted: undefined,
        senderHmac: new Uint8Array()
    };
}
const EncryptResponse_Response_Success = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.encrypted !== undefined) (0, _ciphertextPb.Ciphertext).encode(message.encrypted, writer.uint32(10).fork()).ldelim();
        if (message.senderHmac.length !== 0) writer.uint32(18).bytes(message.senderHmac);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncryptResponse_Response_Success();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.encrypted = (0, _ciphertextPb.Ciphertext).decode(reader, reader.uint32());
                    break;
                case 2:
                    message.senderHmac = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            encrypted: isSet(object.encrypted) ? (0, _ciphertextPb.Ciphertext).fromJSON(object.encrypted) : undefined,
            senderHmac: isSet(object.senderHmac) ? bytesFromBase64(object.senderHmac) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.encrypted !== undefined && (obj.encrypted = message.encrypted ? (0, _ciphertextPb.Ciphertext).toJSON(message.encrypted) : undefined);
        message.senderHmac !== undefined && (obj.senderHmac = base64FromBytes(message.senderHmac !== undefined ? message.senderHmac : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseEncryptResponse_Response_Success();
        message.encrypted = object.encrypted !== undefined && object.encrypted !== null ? (0, _ciphertextPb.Ciphertext).fromPartial(object.encrypted) : undefined;
        message.senderHmac = (_a = object.senderHmac) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseEncryptV2Request() {
    return {
        requests: []
    };
}
const EncryptV2Request = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.requests)EncryptV2Request_Request.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncryptV2Request();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.requests.push(EncryptV2Request_Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests) ? object.requests.map((e)=>EncryptV2Request_Request.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.requests) obj.requests = message.requests.map((e)=>e ? EncryptV2Request_Request.toJSON(e) : undefined);
        else obj.requests = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseEncryptV2Request();
        message.requests = ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e)=>EncryptV2Request_Request.fromPartial(e))) || [];
        return message;
    }
};
function createBaseEncryptV2Request_Request() {
    return {
        payload: new Uint8Array(),
        headerBytes: new Uint8Array(),
        contentTopic: ""
    };
}
const EncryptV2Request_Request = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.payload.length !== 0) writer.uint32(10).bytes(message.payload);
        if (message.headerBytes.length !== 0) writer.uint32(18).bytes(message.headerBytes);
        if (message.contentTopic !== "") writer.uint32(26).string(message.contentTopic);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncryptV2Request_Request();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.payload = reader.bytes();
                    break;
                case 2:
                    message.headerBytes = reader.bytes();
                    break;
                case 3:
                    message.contentTopic = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),
            headerBytes: isSet(object.headerBytes) ? bytesFromBase64(object.headerBytes) : new Uint8Array(),
            contentTopic: isSet(object.contentTopic) ? String(object.contentTopic) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.payload !== undefined && (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        message.headerBytes !== undefined && (obj.headerBytes = base64FromBytes(message.headerBytes !== undefined ? message.headerBytes : new Uint8Array()));
        message.contentTopic !== undefined && (obj.contentTopic = message.contentTopic);
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseEncryptV2Request_Request();
        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.headerBytes = (_b = object.headerBytes) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.contentTopic = (_c = object.contentTopic) !== null && _c !== void 0 ? _c : "";
        return message;
    }
};
function createBaseSelfEncryptRequest() {
    return {
        requests: []
    };
}
const SelfEncryptRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.requests)SelfEncryptRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelfEncryptRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.requests.push(SelfEncryptRequest_Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests) ? object.requests.map((e)=>SelfEncryptRequest_Request.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.requests) obj.requests = message.requests.map((e)=>e ? SelfEncryptRequest_Request.toJSON(e) : undefined);
        else obj.requests = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSelfEncryptRequest();
        message.requests = ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e)=>SelfEncryptRequest_Request.fromPartial(e))) || [];
        return message;
    }
};
function createBaseSelfEncryptRequest_Request() {
    return {
        payload: new Uint8Array()
    };
}
const SelfEncryptRequest_Request = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.payload.length !== 0) writer.uint32(10).bytes(message.payload);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelfEncryptRequest_Request();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.payload !== undefined && (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSelfEncryptRequest_Request();
        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseSelfEncryptResponse() {
    return {
        responses: []
    };
}
const SelfEncryptResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.responses)SelfEncryptResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelfEncryptResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.responses.push(SelfEncryptResponse_Response.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses) ? object.responses.map((e)=>SelfEncryptResponse_Response.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.responses) obj.responses = message.responses.map((e)=>e ? SelfEncryptResponse_Response.toJSON(e) : undefined);
        else obj.responses = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSelfEncryptResponse();
        message.responses = ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e)=>SelfEncryptResponse_Response.fromPartial(e))) || [];
        return message;
    }
};
function createBaseSelfEncryptResponse_Response() {
    return {
        result: undefined,
        error: undefined
    };
}
const SelfEncryptResponse_Response = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.result !== undefined) SelfEncryptResponse_Response_Success.encode(message.result, writer.uint32(10).fork()).ldelim();
        if (message.error !== undefined) KeystoreError.encode(message.error, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelfEncryptResponse_Response();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.result = SelfEncryptResponse_Response_Success.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.error = KeystoreError.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            result: isSet(object.result) ? SelfEncryptResponse_Response_Success.fromJSON(object.result) : undefined,
            error: isSet(object.error) ? KeystoreError.fromJSON(object.error) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.result !== undefined && (obj.result = message.result ? SelfEncryptResponse_Response_Success.toJSON(message.result) : undefined);
        message.error !== undefined && (obj.error = message.error ? KeystoreError.toJSON(message.error) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSelfEncryptResponse_Response();
        message.result = object.result !== undefined && object.result !== null ? SelfEncryptResponse_Response_Success.fromPartial(object.result) : undefined;
        message.error = object.error !== undefined && object.error !== null ? KeystoreError.fromPartial(object.error) : undefined;
        return message;
    }
};
function createBaseSelfEncryptResponse_Response_Success() {
    return {
        encrypted: new Uint8Array()
    };
}
const SelfEncryptResponse_Response_Success = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.encrypted.length !== 0) writer.uint32(10).bytes(message.encrypted);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelfEncryptResponse_Response_Success();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.encrypted = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            encrypted: isSet(object.encrypted) ? bytesFromBase64(object.encrypted) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.encrypted !== undefined && (obj.encrypted = base64FromBytes(message.encrypted !== undefined ? message.encrypted : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSelfEncryptResponse_Response_Success();
        message.encrypted = (_a = object.encrypted) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseSelfDecryptRequest() {
    return {
        requests: []
    };
}
const SelfDecryptRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.requests)SelfDecryptRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelfDecryptRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.requests.push(SelfDecryptRequest_Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests) ? object.requests.map((e)=>SelfDecryptRequest_Request.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.requests) obj.requests = message.requests.map((e)=>e ? SelfDecryptRequest_Request.toJSON(e) : undefined);
        else obj.requests = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSelfDecryptRequest();
        message.requests = ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e)=>SelfDecryptRequest_Request.fromPartial(e))) || [];
        return message;
    }
};
function createBaseSelfDecryptRequest_Request() {
    return {
        payload: new Uint8Array()
    };
}
const SelfDecryptRequest_Request = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.payload.length !== 0) writer.uint32(10).bytes(message.payload);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelfDecryptRequest_Request();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.payload !== undefined && (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSelfDecryptRequest_Request();
        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseGetPrivatePreferencesTopicIdentifierResponse() {
    return {
        identifier: ""
    };
}
const GetPrivatePreferencesTopicIdentifierResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.identifier !== "") writer.uint32(10).string(message.identifier);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetPrivatePreferencesTopicIdentifierResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.identifier = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            identifier: isSet(object.identifier) ? String(object.identifier) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.identifier !== undefined && (obj.identifier = message.identifier);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetPrivatePreferencesTopicIdentifierResponse();
        message.identifier = (_a = object.identifier) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
function createBaseCreateInviteRequest() {
    return {
        context: undefined,
        recipient: undefined,
        createdNs: (0, _longDefault.default).UZERO,
        consentProof: undefined
    };
}
const CreateInviteRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.context !== undefined) (0, _invitationPb.InvitationV1_Context).encode(message.context, writer.uint32(10).fork()).ldelim();
        if (message.recipient !== undefined) (0, _publicKeyPb.SignedPublicKeyBundle).encode(message.recipient, writer.uint32(18).fork()).ldelim();
        if (!message.createdNs.isZero()) writer.uint32(24).uint64(message.createdNs);
        if (message.consentProof !== undefined) (0, _invitationPb.ConsentProofPayload).encode(message.consentProof, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateInviteRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.context = (0, _invitationPb.InvitationV1_Context).decode(reader, reader.uint32());
                    break;
                case 2:
                    message.recipient = (0, _publicKeyPb.SignedPublicKeyBundle).decode(reader, reader.uint32());
                    break;
                case 3:
                    message.createdNs = reader.uint64();
                    break;
                case 4:
                    message.consentProof = (0, _invitationPb.ConsentProofPayload).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            context: isSet(object.context) ? (0, _invitationPb.InvitationV1_Context).fromJSON(object.context) : undefined,
            recipient: isSet(object.recipient) ? (0, _publicKeyPb.SignedPublicKeyBundle).fromJSON(object.recipient) : undefined,
            createdNs: isSet(object.createdNs) ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO,
            consentProof: isSet(object.consentProof) ? (0, _invitationPb.ConsentProofPayload).fromJSON(object.consentProof) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.context !== undefined && (obj.context = message.context ? (0, _invitationPb.InvitationV1_Context).toJSON(message.context) : undefined);
        message.recipient !== undefined && (obj.recipient = message.recipient ? (0, _publicKeyPb.SignedPublicKeyBundle).toJSON(message.recipient) : undefined);
        message.createdNs !== undefined && (obj.createdNs = (message.createdNs || (0, _longDefault.default).UZERO).toString());
        message.consentProof !== undefined && (obj.consentProof = message.consentProof ? (0, _invitationPb.ConsentProofPayload).toJSON(message.consentProof) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCreateInviteRequest();
        message.context = object.context !== undefined && object.context !== null ? (0, _invitationPb.InvitationV1_Context).fromPartial(object.context) : undefined;
        message.recipient = object.recipient !== undefined && object.recipient !== null ? (0, _publicKeyPb.SignedPublicKeyBundle).fromPartial(object.recipient) : undefined;
        message.createdNs = object.createdNs !== undefined && object.createdNs !== null ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO;
        message.consentProof = object.consentProof !== undefined && object.consentProof !== null ? (0, _invitationPb.ConsentProofPayload).fromPartial(object.consentProof) : undefined;
        return message;
    }
};
function createBaseCreateInviteResponse() {
    return {
        conversation: undefined,
        payload: new Uint8Array()
    };
}
const CreateInviteResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.conversation !== undefined) (0, _conversationReferencePb.ConversationReference).encode(message.conversation, writer.uint32(10).fork()).ldelim();
        if (message.payload.length !== 0) writer.uint32(18).bytes(message.payload);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateInviteResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.conversation = (0, _conversationReferencePb.ConversationReference).decode(reader, reader.uint32());
                    break;
                case 2:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            conversation: isSet(object.conversation) ? (0, _conversationReferencePb.ConversationReference).fromJSON(object.conversation) : undefined,
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.conversation !== undefined && (obj.conversation = message.conversation ? (0, _conversationReferencePb.ConversationReference).toJSON(message.conversation) : undefined);
        message.payload !== undefined && (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseCreateInviteResponse();
        message.conversation = object.conversation !== undefined && object.conversation !== null ? (0, _conversationReferencePb.ConversationReference).fromPartial(object.conversation) : undefined;
        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseSaveInvitesRequest() {
    return {
        requests: []
    };
}
const SaveInvitesRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.requests)SaveInvitesRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSaveInvitesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.requests.push(SaveInvitesRequest_Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests) ? object.requests.map((e)=>SaveInvitesRequest_Request.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.requests) obj.requests = message.requests.map((e)=>e ? SaveInvitesRequest_Request.toJSON(e) : undefined);
        else obj.requests = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSaveInvitesRequest();
        message.requests = ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e)=>SaveInvitesRequest_Request.fromPartial(e))) || [];
        return message;
    }
};
function createBaseSaveInvitesRequest_Request() {
    return {
        contentTopic: "",
        timestampNs: (0, _longDefault.default).UZERO,
        payload: new Uint8Array()
    };
}
const SaveInvitesRequest_Request = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.contentTopic !== "") writer.uint32(10).string(message.contentTopic);
        if (!message.timestampNs.isZero()) writer.uint32(16).uint64(message.timestampNs);
        if (message.payload.length !== 0) writer.uint32(26).bytes(message.payload);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSaveInvitesRequest_Request();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.contentTopic = reader.string();
                    break;
                case 2:
                    message.timestampNs = reader.uint64();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            contentTopic: isSet(object.contentTopic) ? String(object.contentTopic) : "",
            timestampNs: isSet(object.timestampNs) ? (0, _longDefault.default).fromValue(object.timestampNs) : (0, _longDefault.default).UZERO,
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.contentTopic !== undefined && (obj.contentTopic = message.contentTopic);
        message.timestampNs !== undefined && (obj.timestampNs = (message.timestampNs || (0, _longDefault.default).UZERO).toString());
        message.payload !== undefined && (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseSaveInvitesRequest_Request();
        message.contentTopic = (_a = object.contentTopic) !== null && _a !== void 0 ? _a : "";
        message.timestampNs = object.timestampNs !== undefined && object.timestampNs !== null ? (0, _longDefault.default).fromValue(object.timestampNs) : (0, _longDefault.default).UZERO;
        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    }
};
function createBaseSaveInvitesResponse() {
    return {
        responses: []
    };
}
const SaveInvitesResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.responses)SaveInvitesResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSaveInvitesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.responses.push(SaveInvitesResponse_Response.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses) ? object.responses.map((e)=>SaveInvitesResponse_Response.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.responses) obj.responses = message.responses.map((e)=>e ? SaveInvitesResponse_Response.toJSON(e) : undefined);
        else obj.responses = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSaveInvitesResponse();
        message.responses = ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e)=>SaveInvitesResponse_Response.fromPartial(e))) || [];
        return message;
    }
};
function createBaseSaveInvitesResponse_Response() {
    return {
        result: undefined,
        error: undefined
    };
}
const SaveInvitesResponse_Response = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.result !== undefined) SaveInvitesResponse_Response_Success.encode(message.result, writer.uint32(10).fork()).ldelim();
        if (message.error !== undefined) KeystoreError.encode(message.error, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSaveInvitesResponse_Response();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.result = SaveInvitesResponse_Response_Success.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.error = KeystoreError.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            result: isSet(object.result) ? SaveInvitesResponse_Response_Success.fromJSON(object.result) : undefined,
            error: isSet(object.error) ? KeystoreError.fromJSON(object.error) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.result !== undefined && (obj.result = message.result ? SaveInvitesResponse_Response_Success.toJSON(message.result) : undefined);
        message.error !== undefined && (obj.error = message.error ? KeystoreError.toJSON(message.error) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSaveInvitesResponse_Response();
        message.result = object.result !== undefined && object.result !== null ? SaveInvitesResponse_Response_Success.fromPartial(object.result) : undefined;
        message.error = object.error !== undefined && object.error !== null ? KeystoreError.fromPartial(object.error) : undefined;
        return message;
    }
};
function createBaseSaveInvitesResponse_Response_Success() {
    return {
        conversation: undefined
    };
}
const SaveInvitesResponse_Response_Success = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.conversation !== undefined) (0, _conversationReferencePb.ConversationReference).encode(message.conversation, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSaveInvitesResponse_Response_Success();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.conversation = (0, _conversationReferencePb.ConversationReference).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            conversation: isSet(object.conversation) ? (0, _conversationReferencePb.ConversationReference).fromJSON(object.conversation) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.conversation !== undefined && (obj.conversation = message.conversation ? (0, _conversationReferencePb.ConversationReference).toJSON(message.conversation) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSaveInvitesResponse_Response_Success();
        message.conversation = object.conversation !== undefined && object.conversation !== null ? (0, _conversationReferencePb.ConversationReference).fromPartial(object.conversation) : undefined;
        return message;
    }
};
function createBaseCreateAuthTokenRequest() {
    return {
        timestampNs: undefined
    };
}
const CreateAuthTokenRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.timestampNs !== undefined) writer.uint32(8).uint64(message.timestampNs);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateAuthTokenRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.timestampNs = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            timestampNs: isSet(object.timestampNs) ? (0, _longDefault.default).fromValue(object.timestampNs) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.timestampNs !== undefined && (obj.timestampNs = (message.timestampNs || undefined).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseCreateAuthTokenRequest();
        message.timestampNs = object.timestampNs !== undefined && object.timestampNs !== null ? (0, _longDefault.default).fromValue(object.timestampNs) : undefined;
        return message;
    }
};
function createBaseSaveV1ConversationsRequest() {
    return {
        conversations: []
    };
}
const SaveV1ConversationsRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.conversations)(0, _conversationReferencePb.ConversationReference).encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSaveV1ConversationsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.conversations.push((0, _conversationReferencePb.ConversationReference).decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            conversations: Array.isArray(object === null || object === void 0 ? void 0 : object.conversations) ? object.conversations.map((e)=>(0, _conversationReferencePb.ConversationReference).fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.conversations) obj.conversations = message.conversations.map((e)=>e ? (0, _conversationReferencePb.ConversationReference).toJSON(e) : undefined);
        else obj.conversations = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSaveV1ConversationsRequest();
        message.conversations = ((_a = object.conversations) === null || _a === void 0 ? void 0 : _a.map((e)=>(0, _conversationReferencePb.ConversationReference).fromPartial(e))) || [];
        return message;
    }
};
function createBaseSaveV1ConversationsResponse() {
    return {};
}
const SaveV1ConversationsResponse = {
    encode (_, writer = (0, _minimalDefault.default).Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSaveV1ConversationsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseSaveV1ConversationsResponse();
        return message;
    }
};
function createBaseGetConversationsResponse() {
    return {
        conversations: []
    };
}
const GetConversationsResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.conversations)(0, _conversationReferencePb.ConversationReference).encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.conversations.push((0, _conversationReferencePb.ConversationReference).decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            conversations: Array.isArray(object === null || object === void 0 ? void 0 : object.conversations) ? object.conversations.map((e)=>(0, _conversationReferencePb.ConversationReference).fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.conversations) obj.conversations = message.conversations.map((e)=>e ? (0, _conversationReferencePb.ConversationReference).toJSON(e) : undefined);
        else obj.conversations = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetConversationsResponse();
        message.conversations = ((_a = object.conversations) === null || _a === void 0 ? void 0 : _a.map((e)=>(0, _conversationReferencePb.ConversationReference).fromPartial(e))) || [];
        return message;
    }
};
function createBaseGetKeystoreStatusRequest() {
    return {
        walletAddress: ""
    };
}
const GetKeystoreStatusRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.walletAddress !== "") writer.uint32(10).string(message.walletAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetKeystoreStatusRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.walletAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            walletAddress: isSet(object.walletAddress) ? String(object.walletAddress) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.walletAddress !== undefined && (obj.walletAddress = message.walletAddress);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetKeystoreStatusRequest();
        message.walletAddress = (_a = object.walletAddress) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
function createBaseGetKeystoreStatusResponse() {
    return {
        status: 0
    };
}
const GetKeystoreStatusResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.status !== 0) writer.uint32(8).int32(message.status);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetKeystoreStatusResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            status: isSet(object.status) ? getKeystoreStatusResponse_KeystoreStatusFromJSON(object.status) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        message.status !== undefined && (obj.status = getKeystoreStatusResponse_KeystoreStatusToJSON(message.status));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetKeystoreStatusResponse();
        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBaseInitKeystoreRequest() {
    return {
        v1: undefined
    };
}
const InitKeystoreRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) (0, _privateKeyPb.PrivateKeyBundleV1).encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInitKeystoreRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = (0, _privateKeyPb.PrivateKeyBundleV1).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? (0, _privateKeyPb.PrivateKeyBundleV1).fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? (0, _privateKeyPb.PrivateKeyBundleV1).toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseInitKeystoreRequest();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? (0, _privateKeyPb.PrivateKeyBundleV1).fromPartial(object.v1) : undefined;
        return message;
    }
};
function createBaseInitKeystoreResponse() {
    return {
        error: undefined
    };
}
const InitKeystoreResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.error !== undefined) KeystoreError.encode(message.error, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInitKeystoreResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.error = KeystoreError.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            error: isSet(object.error) ? KeystoreError.fromJSON(object.error) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.error !== undefined && (obj.error = message.error ? KeystoreError.toJSON(message.error) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseInitKeystoreResponse();
        message.error = object.error !== undefined && object.error !== null ? KeystoreError.fromPartial(object.error) : undefined;
        return message;
    }
};
function createBaseSignDigestRequest() {
    return {
        digest: new Uint8Array(),
        identityKey: undefined,
        prekeyIndex: undefined
    };
}
const SignDigestRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.digest.length !== 0) writer.uint32(10).bytes(message.digest);
        if (message.identityKey !== undefined) writer.uint32(16).bool(message.identityKey);
        if (message.prekeyIndex !== undefined) writer.uint32(24).uint32(message.prekeyIndex);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignDigestRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.digest = reader.bytes();
                    break;
                case 2:
                    message.identityKey = reader.bool();
                    break;
                case 3:
                    message.prekeyIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            digest: isSet(object.digest) ? bytesFromBase64(object.digest) : new Uint8Array(),
            identityKey: isSet(object.identityKey) ? Boolean(object.identityKey) : undefined,
            prekeyIndex: isSet(object.prekeyIndex) ? Number(object.prekeyIndex) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.digest !== undefined && (obj.digest = base64FromBytes(message.digest !== undefined ? message.digest : new Uint8Array()));
        message.identityKey !== undefined && (obj.identityKey = message.identityKey);
        message.prekeyIndex !== undefined && (obj.prekeyIndex = Math.round(message.prekeyIndex));
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseSignDigestRequest();
        message.digest = (_a = object.digest) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.identityKey = (_b = object.identityKey) !== null && _b !== void 0 ? _b : undefined;
        message.prekeyIndex = (_c = object.prekeyIndex) !== null && _c !== void 0 ? _c : undefined;
        return message;
    }
};
function createBaseGetRefreshJobRequest() {
    return {
        jobType: 0
    };
}
const GetRefreshJobRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.jobType !== 0) writer.uint32(8).int32(message.jobType);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetRefreshJobRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.jobType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            jobType: isSet(object.jobType) ? jobTypeFromJSON(object.jobType) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        message.jobType !== undefined && (obj.jobType = jobTypeToJSON(message.jobType));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetRefreshJobRequest();
        message.jobType = (_a = object.jobType) !== null && _a !== void 0 ? _a : 0;
        return message;
    }
};
function createBaseGetRefreshJobResponse() {
    return {
        lastRunNs: (0, _longDefault.default).ZERO
    };
}
const GetRefreshJobResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (!message.lastRunNs.isZero()) writer.uint32(8).int64(message.lastRunNs);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetRefreshJobResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.lastRunNs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            lastRunNs: isSet(object.lastRunNs) ? (0, _longDefault.default).fromValue(object.lastRunNs) : (0, _longDefault.default).ZERO
        };
    },
    toJSON (message) {
        const obj = {};
        message.lastRunNs !== undefined && (obj.lastRunNs = (message.lastRunNs || (0, _longDefault.default).ZERO).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGetRefreshJobResponse();
        message.lastRunNs = object.lastRunNs !== undefined && object.lastRunNs !== null ? (0, _longDefault.default).fromValue(object.lastRunNs) : (0, _longDefault.default).ZERO;
        return message;
    }
};
function createBaseSetRefeshJobRequest() {
    return {
        jobType: 0,
        lastRunNs: (0, _longDefault.default).ZERO
    };
}
const SetRefeshJobRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.jobType !== 0) writer.uint32(8).int32(message.jobType);
        if (!message.lastRunNs.isZero()) writer.uint32(16).int64(message.lastRunNs);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetRefeshJobRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.jobType = reader.int32();
                    break;
                case 2:
                    message.lastRunNs = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            jobType: isSet(object.jobType) ? jobTypeFromJSON(object.jobType) : 0,
            lastRunNs: isSet(object.lastRunNs) ? (0, _longDefault.default).fromValue(object.lastRunNs) : (0, _longDefault.default).ZERO
        };
    },
    toJSON (message) {
        const obj = {};
        message.jobType !== undefined && (obj.jobType = jobTypeToJSON(message.jobType));
        message.lastRunNs !== undefined && (obj.lastRunNs = (message.lastRunNs || (0, _longDefault.default).ZERO).toString());
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSetRefeshJobRequest();
        message.jobType = (_a = object.jobType) !== null && _a !== void 0 ? _a : 0;
        message.lastRunNs = object.lastRunNs !== undefined && object.lastRunNs !== null ? (0, _longDefault.default).fromValue(object.lastRunNs) : (0, _longDefault.default).ZERO;
        return message;
    }
};
function createBaseSetRefreshJobResponse() {
    return {};
}
const SetRefreshJobResponse = {
    encode (_, writer = (0, _minimalDefault.default).Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSetRefreshJobResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseSetRefreshJobResponse();
        return message;
    }
};
function createBaseTopicMap() {
    return {
        topics: {}
    };
}
const TopicMap = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        Object.entries(message.topics).forEach(([key, value])=>{
            TopicMap_TopicsEntry.encode({
                key: key,
                value
            }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTopicMap();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    const entry1 = TopicMap_TopicsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) message.topics[entry1.key] = entry1.value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            topics: isObject(object.topics) ? Object.entries(object.topics).reduce((acc, [key, value])=>{
                acc[key] = TopicMap_TopicData.fromJSON(value);
                return acc;
            }, {}) : {}
        };
    },
    toJSON (message) {
        const obj = {};
        obj.topics = {};
        if (message.topics) Object.entries(message.topics).forEach(([k, v])=>{
            obj.topics[k] = TopicMap_TopicData.toJSON(v);
        });
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseTopicMap();
        message.topics = Object.entries((_a = object.topics) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value])=>{
            if (value !== undefined) acc[key] = TopicMap_TopicData.fromPartial(value);
            return acc;
        }, {});
        return message;
    }
};
function createBaseTopicMap_TopicData() {
    return {
        createdNs: (0, _longDefault.default).UZERO,
        peerAddress: "",
        invitation: undefined
    };
}
const TopicMap_TopicData = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (!message.createdNs.isZero()) writer.uint32(8).uint64(message.createdNs);
        if (message.peerAddress !== "") writer.uint32(18).string(message.peerAddress);
        if (message.invitation !== undefined) (0, _invitationPb.InvitationV1).encode(message.invitation, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTopicMap_TopicData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.createdNs = reader.uint64();
                    break;
                case 2:
                    message.peerAddress = reader.string();
                    break;
                case 3:
                    message.invitation = (0, _invitationPb.InvitationV1).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            createdNs: isSet(object.createdNs) ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO,
            peerAddress: isSet(object.peerAddress) ? String(object.peerAddress) : "",
            invitation: isSet(object.invitation) ? (0, _invitationPb.InvitationV1).fromJSON(object.invitation) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.createdNs !== undefined && (obj.createdNs = (message.createdNs || (0, _longDefault.default).UZERO).toString());
        message.peerAddress !== undefined && (obj.peerAddress = message.peerAddress);
        message.invitation !== undefined && (obj.invitation = message.invitation ? (0, _invitationPb.InvitationV1).toJSON(message.invitation) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseTopicMap_TopicData();
        message.createdNs = object.createdNs !== undefined && object.createdNs !== null ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO;
        message.peerAddress = (_a = object.peerAddress) !== null && _a !== void 0 ? _a : "";
        message.invitation = object.invitation !== undefined && object.invitation !== null ? (0, _invitationPb.InvitationV1).fromPartial(object.invitation) : undefined;
        return message;
    }
};
function createBaseTopicMap_TopicsEntry() {
    return {
        key: "",
        value: undefined
    };
}
const TopicMap_TopicsEntry = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.key !== "") writer.uint32(10).string(message.key);
        if (message.value !== undefined) TopicMap_TopicData.encode(message.value, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTopicMap_TopicsEntry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = TopicMap_TopicData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? TopicMap_TopicData.fromJSON(object.value) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? TopicMap_TopicData.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseTopicMap_TopicsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = object.value !== undefined && object.value !== null ? TopicMap_TopicData.fromPartial(object.value) : undefined;
        return message;
    }
};
function createBaseGetConversationHmacKeysRequest() {
    return {
        topics: []
    };
}
const GetConversationHmacKeysRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.topics)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationHmacKeysRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.topics.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            topics: Array.isArray(object === null || object === void 0 ? void 0 : object.topics) ? object.topics.map((e)=>String(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.topics) obj.topics = message.topics.map((e)=>e);
        else obj.topics = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetConversationHmacKeysRequest();
        message.topics = ((_a = object.topics) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
function createBaseGetConversationHmacKeysResponse() {
    return {
        hmacKeys: {}
    };
}
const GetConversationHmacKeysResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        Object.entries(message.hmacKeys).forEach(([key, value])=>{
            GetConversationHmacKeysResponse_HmacKeysEntry.encode({
                key: key,
                value
            }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationHmacKeysResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    const entry1 = GetConversationHmacKeysResponse_HmacKeysEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) message.hmacKeys[entry1.key] = entry1.value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            hmacKeys: isObject(object.hmacKeys) ? Object.entries(object.hmacKeys).reduce((acc, [key, value])=>{
                acc[key] = GetConversationHmacKeysResponse_HmacKeys.fromJSON(value);
                return acc;
            }, {}) : {}
        };
    },
    toJSON (message) {
        const obj = {};
        obj.hmacKeys = {};
        if (message.hmacKeys) Object.entries(message.hmacKeys).forEach(([k, v])=>{
            obj.hmacKeys[k] = GetConversationHmacKeysResponse_HmacKeys.toJSON(v);
        });
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetConversationHmacKeysResponse();
        message.hmacKeys = Object.entries((_a = object.hmacKeys) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value])=>{
            if (value !== undefined) acc[key] = GetConversationHmacKeysResponse_HmacKeys.fromPartial(value);
            return acc;
        }, {});
        return message;
    }
};
function createBaseGetConversationHmacKeysResponse_HmacKeyData() {
    return {
        thirtyDayPeriodsSinceEpoch: 0,
        hmacKey: new Uint8Array()
    };
}
const GetConversationHmacKeysResponse_HmacKeyData = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.thirtyDayPeriodsSinceEpoch !== 0) writer.uint32(8).int32(message.thirtyDayPeriodsSinceEpoch);
        if (message.hmacKey.length !== 0) writer.uint32(18).bytes(message.hmacKey);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationHmacKeysResponse_HmacKeyData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.thirtyDayPeriodsSinceEpoch = reader.int32();
                    break;
                case 2:
                    message.hmacKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            thirtyDayPeriodsSinceEpoch: isSet(object.thirtyDayPeriodsSinceEpoch) ? Number(object.thirtyDayPeriodsSinceEpoch) : 0,
            hmacKey: isSet(object.hmacKey) ? bytesFromBase64(object.hmacKey) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.thirtyDayPeriodsSinceEpoch !== undefined && (obj.thirtyDayPeriodsSinceEpoch = Math.round(message.thirtyDayPeriodsSinceEpoch));
        message.hmacKey !== undefined && (obj.hmacKey = base64FromBytes(message.hmacKey !== undefined ? message.hmacKey : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseGetConversationHmacKeysResponse_HmacKeyData();
        message.thirtyDayPeriodsSinceEpoch = (_a = object.thirtyDayPeriodsSinceEpoch) !== null && _a !== void 0 ? _a : 0;
        message.hmacKey = (_b = object.hmacKey) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    }
};
function createBaseGetConversationHmacKeysResponse_HmacKeys() {
    return {
        values: []
    };
}
const GetConversationHmacKeysResponse_HmacKeys = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.values)GetConversationHmacKeysResponse_HmacKeyData.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationHmacKeysResponse_HmacKeys();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.values.push(GetConversationHmacKeysResponse_HmacKeyData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            values: Array.isArray(object === null || object === void 0 ? void 0 : object.values) ? object.values.map((e)=>GetConversationHmacKeysResponse_HmacKeyData.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.values) obj.values = message.values.map((e)=>e ? GetConversationHmacKeysResponse_HmacKeyData.toJSON(e) : undefined);
        else obj.values = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetConversationHmacKeysResponse_HmacKeys();
        message.values = ((_a = object.values) === null || _a === void 0 ? void 0 : _a.map((e)=>GetConversationHmacKeysResponse_HmacKeyData.fromPartial(e))) || [];
        return message;
    }
};
function createBaseGetConversationHmacKeysResponse_HmacKeysEntry() {
    return {
        key: "",
        value: undefined
    };
}
const GetConversationHmacKeysResponse_HmacKeysEntry = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.key !== "") writer.uint32(10).string(message.key);
        if (message.value !== undefined) GetConversationHmacKeysResponse_HmacKeys.encode(message.value, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetConversationHmacKeysResponse_HmacKeysEntry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = GetConversationHmacKeysResponse_HmacKeys.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? GetConversationHmacKeysResponse_HmacKeys.fromJSON(object.value) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? GetConversationHmacKeysResponse_HmacKeys.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetConversationHmacKeysResponse_HmacKeysEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = object.value !== undefined && object.value !== null ? GetConversationHmacKeysResponse_HmacKeys.fromPartial(object.value) : undefined;
        return message;
    }
};
function createBasePrivatePreferencesActionMap() {
    return {
        actions: {}
    };
}
const PrivatePreferencesActionMap = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        Object.entries(message.actions).forEach(([key, value])=>{
            PrivatePreferencesActionMap_ActionsEntry.encode({
                key: key,
                value
            }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivatePreferencesActionMap();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    const entry1 = PrivatePreferencesActionMap_ActionsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) message.actions[entry1.key] = entry1.value;
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            actions: isObject(object.actions) ? Object.entries(object.actions).reduce((acc, [key, value])=>{
                acc[key] = (0, _privatePreferencesPb.PrivatePreferencesAction).fromJSON(value);
                return acc;
            }, {}) : {}
        };
    },
    toJSON (message) {
        const obj = {};
        obj.actions = {};
        if (message.actions) Object.entries(message.actions).forEach(([k, v])=>{
            obj.actions[k] = (0, _privatePreferencesPb.PrivatePreferencesAction).toJSON(v);
        });
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBasePrivatePreferencesActionMap();
        message.actions = Object.entries((_a = object.actions) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value])=>{
            if (value !== undefined) acc[key] = (0, _privatePreferencesPb.PrivatePreferencesAction).fromPartial(value);
            return acc;
        }, {});
        return message;
    }
};
function createBasePrivatePreferencesActionMap_ActionsEntry() {
    return {
        key: "",
        value: undefined
    };
}
const PrivatePreferencesActionMap_ActionsEntry = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.key !== "") writer.uint32(10).string(message.key);
        if (message.value !== undefined) (0, _privatePreferencesPb.PrivatePreferencesAction).encode(message.value, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivatePreferencesActionMap_ActionsEntry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = (0, _privatePreferencesPb.PrivatePreferencesAction).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? (0, _privatePreferencesPb.PrivatePreferencesAction).fromJSON(object.value) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value ? (0, _privatePreferencesPb.PrivatePreferencesAction).toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBasePrivatePreferencesActionMap_ActionsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = object.value !== undefined && object.value !== null ? (0, _privatePreferencesPb.PrivatePreferencesAction).fromPartial(object.value) : undefined;
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","../../message_contents/ciphertext.pb":"dkFEI","../../message_contents/public_key.pb":"6Dba7","../../message_contents/invitation.pb":"1UrlP","../../message_contents/conversation_reference.pb":"jsKKm","../../message_contents/private_key.pb":"11lga","../../message_contents/private_preferences.pb":"8F1sC","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8F1sC":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "PrivatePreferencesAction", ()=>PrivatePreferencesAction);
parcelHelpers.export(exports, "PrivatePreferencesAction_AllowAddress", ()=>PrivatePreferencesAction_AllowAddress);
parcelHelpers.export(exports, "PrivatePreferencesAction_DenyAddress", ()=>PrivatePreferencesAction_DenyAddress);
parcelHelpers.export(exports, "PrivatePreferencesAction_AllowInboxId", ()=>PrivatePreferencesAction_AllowInboxId);
parcelHelpers.export(exports, "PrivatePreferencesAction_DenyInboxId", ()=>PrivatePreferencesAction_DenyInboxId);
parcelHelpers.export(exports, "PrivatePreferencesAction_AllowGroup", ()=>PrivatePreferencesAction_AllowGroup);
parcelHelpers.export(exports, "PrivatePreferencesAction_DenyGroup", ()=>PrivatePreferencesAction_DenyGroup);
parcelHelpers.export(exports, "PrivatePreferencesPayload", ()=>PrivatePreferencesPayload);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _ciphertextPb = require("./ciphertext.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
const protobufPackage = "xmtp.message_contents";
function createBasePrivatePreferencesAction() {
    return {
        allowAddress: undefined,
        denyAddress: undefined,
        allowGroup: undefined,
        denyGroup: undefined,
        allowInboxId: undefined,
        denyInboxId: undefined
    };
}
const PrivatePreferencesAction = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.allowAddress !== undefined) PrivatePreferencesAction_AllowAddress.encode(message.allowAddress, writer.uint32(10).fork()).ldelim();
        if (message.denyAddress !== undefined) PrivatePreferencesAction_DenyAddress.encode(message.denyAddress, writer.uint32(18).fork()).ldelim();
        if (message.allowGroup !== undefined) PrivatePreferencesAction_AllowGroup.encode(message.allowGroup, writer.uint32(26).fork()).ldelim();
        if (message.denyGroup !== undefined) PrivatePreferencesAction_DenyGroup.encode(message.denyGroup, writer.uint32(34).fork()).ldelim();
        if (message.allowInboxId !== undefined) PrivatePreferencesAction_AllowInboxId.encode(message.allowInboxId, writer.uint32(42).fork()).ldelim();
        if (message.denyInboxId !== undefined) PrivatePreferencesAction_DenyInboxId.encode(message.denyInboxId, writer.uint32(50).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivatePreferencesAction();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.allowAddress = PrivatePreferencesAction_AllowAddress.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.denyAddress = PrivatePreferencesAction_DenyAddress.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.allowGroup = PrivatePreferencesAction_AllowGroup.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.denyGroup = PrivatePreferencesAction_DenyGroup.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.allowInboxId = PrivatePreferencesAction_AllowInboxId.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.denyInboxId = PrivatePreferencesAction_DenyInboxId.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            allowAddress: isSet(object.allowAddress) ? PrivatePreferencesAction_AllowAddress.fromJSON(object.allowAddress) : undefined,
            denyAddress: isSet(object.denyAddress) ? PrivatePreferencesAction_DenyAddress.fromJSON(object.denyAddress) : undefined,
            allowGroup: isSet(object.allowGroup) ? PrivatePreferencesAction_AllowGroup.fromJSON(object.allowGroup) : undefined,
            denyGroup: isSet(object.denyGroup) ? PrivatePreferencesAction_DenyGroup.fromJSON(object.denyGroup) : undefined,
            allowInboxId: isSet(object.allowInboxId) ? PrivatePreferencesAction_AllowInboxId.fromJSON(object.allowInboxId) : undefined,
            denyInboxId: isSet(object.denyInboxId) ? PrivatePreferencesAction_DenyInboxId.fromJSON(object.denyInboxId) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.allowAddress !== undefined && (obj.allowAddress = message.allowAddress ? PrivatePreferencesAction_AllowAddress.toJSON(message.allowAddress) : undefined);
        message.denyAddress !== undefined && (obj.denyAddress = message.denyAddress ? PrivatePreferencesAction_DenyAddress.toJSON(message.denyAddress) : undefined);
        message.allowGroup !== undefined && (obj.allowGroup = message.allowGroup ? PrivatePreferencesAction_AllowGroup.toJSON(message.allowGroup) : undefined);
        message.denyGroup !== undefined && (obj.denyGroup = message.denyGroup ? PrivatePreferencesAction_DenyGroup.toJSON(message.denyGroup) : undefined);
        message.allowInboxId !== undefined && (obj.allowInboxId = message.allowInboxId ? PrivatePreferencesAction_AllowInboxId.toJSON(message.allowInboxId) : undefined);
        message.denyInboxId !== undefined && (obj.denyInboxId = message.denyInboxId ? PrivatePreferencesAction_DenyInboxId.toJSON(message.denyInboxId) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePrivatePreferencesAction();
        message.allowAddress = object.allowAddress !== undefined && object.allowAddress !== null ? PrivatePreferencesAction_AllowAddress.fromPartial(object.allowAddress) : undefined;
        message.denyAddress = object.denyAddress !== undefined && object.denyAddress !== null ? PrivatePreferencesAction_DenyAddress.fromPartial(object.denyAddress) : undefined;
        message.allowGroup = object.allowGroup !== undefined && object.allowGroup !== null ? PrivatePreferencesAction_AllowGroup.fromPartial(object.allowGroup) : undefined;
        message.denyGroup = object.denyGroup !== undefined && object.denyGroup !== null ? PrivatePreferencesAction_DenyGroup.fromPartial(object.denyGroup) : undefined;
        message.allowInboxId = object.allowInboxId !== undefined && object.allowInboxId !== null ? PrivatePreferencesAction_AllowInboxId.fromPartial(object.allowInboxId) : undefined;
        message.denyInboxId = object.denyInboxId !== undefined && object.denyInboxId !== null ? PrivatePreferencesAction_DenyInboxId.fromPartial(object.denyInboxId) : undefined;
        return message;
    }
};
function createBasePrivatePreferencesAction_AllowAddress() {
    return {
        walletAddresses: []
    };
}
const PrivatePreferencesAction_AllowAddress = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.walletAddresses)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivatePreferencesAction_AllowAddress();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.walletAddresses.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            walletAddresses: Array.isArray(object === null || object === void 0 ? void 0 : object.walletAddresses) ? object.walletAddresses.map((e)=>String(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.walletAddresses) obj.walletAddresses = message.walletAddresses.map((e)=>e);
        else obj.walletAddresses = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBasePrivatePreferencesAction_AllowAddress();
        message.walletAddresses = ((_a = object.walletAddresses) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
function createBasePrivatePreferencesAction_DenyAddress() {
    return {
        walletAddresses: []
    };
}
const PrivatePreferencesAction_DenyAddress = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.walletAddresses)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivatePreferencesAction_DenyAddress();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.walletAddresses.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            walletAddresses: Array.isArray(object === null || object === void 0 ? void 0 : object.walletAddresses) ? object.walletAddresses.map((e)=>String(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.walletAddresses) obj.walletAddresses = message.walletAddresses.map((e)=>e);
        else obj.walletAddresses = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBasePrivatePreferencesAction_DenyAddress();
        message.walletAddresses = ((_a = object.walletAddresses) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
function createBasePrivatePreferencesAction_AllowInboxId() {
    return {
        inboxIds: []
    };
}
const PrivatePreferencesAction_AllowInboxId = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.inboxIds)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivatePreferencesAction_AllowInboxId();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.inboxIds.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            inboxIds: Array.isArray(object === null || object === void 0 ? void 0 : object.inboxIds) ? object.inboxIds.map((e)=>String(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.inboxIds) obj.inboxIds = message.inboxIds.map((e)=>e);
        else obj.inboxIds = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBasePrivatePreferencesAction_AllowInboxId();
        message.inboxIds = ((_a = object.inboxIds) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
function createBasePrivatePreferencesAction_DenyInboxId() {
    return {
        inboxIds: []
    };
}
const PrivatePreferencesAction_DenyInboxId = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.inboxIds)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivatePreferencesAction_DenyInboxId();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.inboxIds.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            inboxIds: Array.isArray(object === null || object === void 0 ? void 0 : object.inboxIds) ? object.inboxIds.map((e)=>String(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.inboxIds) obj.inboxIds = message.inboxIds.map((e)=>e);
        else obj.inboxIds = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBasePrivatePreferencesAction_DenyInboxId();
        message.inboxIds = ((_a = object.inboxIds) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
function createBasePrivatePreferencesAction_AllowGroup() {
    return {
        groupIds: []
    };
}
const PrivatePreferencesAction_AllowGroup = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.groupIds)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivatePreferencesAction_AllowGroup();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.groupIds.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            groupIds: Array.isArray(object === null || object === void 0 ? void 0 : object.groupIds) ? object.groupIds.map((e)=>String(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.groupIds) obj.groupIds = message.groupIds.map((e)=>e);
        else obj.groupIds = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBasePrivatePreferencesAction_AllowGroup();
        message.groupIds = ((_a = object.groupIds) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
function createBasePrivatePreferencesAction_DenyGroup() {
    return {
        groupIds: []
    };
}
const PrivatePreferencesAction_DenyGroup = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.groupIds)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivatePreferencesAction_DenyGroup();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.groupIds.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            groupIds: Array.isArray(object === null || object === void 0 ? void 0 : object.groupIds) ? object.groupIds.map((e)=>String(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.groupIds) obj.groupIds = message.groupIds.map((e)=>e);
        else obj.groupIds = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBasePrivatePreferencesAction_DenyGroup();
        message.groupIds = ((_a = object.groupIds) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
function createBasePrivatePreferencesPayload() {
    return {
        v1: undefined
    };
}
const PrivatePreferencesPayload = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) (0, _ciphertextPb.Ciphertext).encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePrivatePreferencesPayload();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = (0, _ciphertextPb.Ciphertext).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? (0, _ciphertextPb.Ciphertext).fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? (0, _ciphertextPb.Ciphertext).toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePrivatePreferencesPayload();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? (0, _ciphertextPb.Ciphertext).fromPartial(object.v1) : undefined;
        return message;
    }
};
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","./ciphertext.pb":"dkFEI","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h3MRZ":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "SignedPayload", ()=>SignedPayload);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _signaturePb = require("./signature.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.message_contents";
function createBaseSignedPayload() {
    return {
        payload: new Uint8Array(),
        signature: undefined
    };
}
const SignedPayload = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.payload.length !== 0) writer.uint32(10).bytes(message.payload);
        if (message.signature !== undefined) (0, _signaturePb.Signature).encode(message.signature, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignedPayload();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.payload = reader.bytes();
                    break;
                case 2:
                    message.signature = (0, _signaturePb.Signature).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),
            signature: isSet(object.signature) ? (0, _signaturePb.Signature).fromJSON(object.signature) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.payload !== undefined && (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));
        message.signature !== undefined && (obj.signature = message.signature ? (0, _signaturePb.Signature).toJSON(message.signature) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSignedPayload();
        message.payload = (_a = object.payload) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.signature = object.signature !== undefined && object.signature !== null ? (0, _signaturePb.Signature).fromPartial(object.signature) : undefined;
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","./signature.pb":"hvHvx","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iX6C0":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "EciesMessage", ()=>EciesMessage);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.message_contents";
function createBaseEciesMessage() {
    return {
        v1: undefined
    };
}
const EciesMessage = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) writer.uint32(10).bytes(message.v1);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEciesMessage();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? bytesFromBase64(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 !== undefined ? base64FromBytes(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseEciesMessage();
        message.v1 = (_a = object.v1) !== null && _a !== void 0 ? _a : undefined;
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"loJmb":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "SortDirection", ()=>SortDirection);
parcelHelpers.export(exports, "sortDirectionFromJSON", ()=>sortDirectionFromJSON);
parcelHelpers.export(exports, "sortDirectionToJSON", ()=>sortDirectionToJSON);
parcelHelpers.export(exports, "WelcomeMessage", ()=>WelcomeMessage);
parcelHelpers.export(exports, "WelcomeMessage_V1", ()=>WelcomeMessage_V1);
parcelHelpers.export(exports, "WelcomeMessageInput", ()=>WelcomeMessageInput);
parcelHelpers.export(exports, "WelcomeMessageInput_V1", ()=>WelcomeMessageInput_V1);
parcelHelpers.export(exports, "GroupMessage", ()=>GroupMessage);
parcelHelpers.export(exports, "GroupMessage_V1", ()=>GroupMessage_V1);
parcelHelpers.export(exports, "GroupMessageInput", ()=>GroupMessageInput);
parcelHelpers.export(exports, "GroupMessageInput_V1", ()=>GroupMessageInput_V1);
parcelHelpers.export(exports, "SendGroupMessagesRequest", ()=>SendGroupMessagesRequest);
parcelHelpers.export(exports, "SendWelcomeMessagesRequest", ()=>SendWelcomeMessagesRequest);
parcelHelpers.export(exports, "KeyPackageUpload", ()=>KeyPackageUpload);
parcelHelpers.export(exports, "RegisterInstallationRequest", ()=>RegisterInstallationRequest);
parcelHelpers.export(exports, "RegisterInstallationResponse", ()=>RegisterInstallationResponse);
parcelHelpers.export(exports, "UploadKeyPackageRequest", ()=>UploadKeyPackageRequest);
parcelHelpers.export(exports, "FetchKeyPackagesRequest", ()=>FetchKeyPackagesRequest);
parcelHelpers.export(exports, "FetchKeyPackagesResponse", ()=>FetchKeyPackagesResponse);
parcelHelpers.export(exports, "FetchKeyPackagesResponse_KeyPackage", ()=>FetchKeyPackagesResponse_KeyPackage);
parcelHelpers.export(exports, "RevokeInstallationRequest", ()=>RevokeInstallationRequest);
parcelHelpers.export(exports, "GetIdentityUpdatesRequest", ()=>GetIdentityUpdatesRequest);
parcelHelpers.export(exports, "GetIdentityUpdatesResponse", ()=>GetIdentityUpdatesResponse);
parcelHelpers.export(exports, "GetIdentityUpdatesResponse_NewInstallationUpdate", ()=>GetIdentityUpdatesResponse_NewInstallationUpdate);
parcelHelpers.export(exports, "GetIdentityUpdatesResponse_RevokedInstallationUpdate", ()=>GetIdentityUpdatesResponse_RevokedInstallationUpdate);
parcelHelpers.export(exports, "GetIdentityUpdatesResponse_Update", ()=>GetIdentityUpdatesResponse_Update);
parcelHelpers.export(exports, "GetIdentityUpdatesResponse_WalletUpdates", ()=>GetIdentityUpdatesResponse_WalletUpdates);
parcelHelpers.export(exports, "PagingInfo", ()=>PagingInfo);
parcelHelpers.export(exports, "QueryGroupMessagesRequest", ()=>QueryGroupMessagesRequest);
parcelHelpers.export(exports, "QueryGroupMessagesResponse", ()=>QueryGroupMessagesResponse);
parcelHelpers.export(exports, "QueryWelcomeMessagesRequest", ()=>QueryWelcomeMessagesRequest);
parcelHelpers.export(exports, "QueryWelcomeMessagesResponse", ()=>QueryWelcomeMessagesResponse);
parcelHelpers.export(exports, "SubscribeGroupMessagesRequest", ()=>SubscribeGroupMessagesRequest);
parcelHelpers.export(exports, "SubscribeGroupMessagesRequest_Filter", ()=>SubscribeGroupMessagesRequest_Filter);
parcelHelpers.export(exports, "SubscribeWelcomeMessagesRequest", ()=>SubscribeWelcomeMessagesRequest);
parcelHelpers.export(exports, "SubscribeWelcomeMessagesRequest_Filter", ()=>SubscribeWelcomeMessagesRequest_Filter);
parcelHelpers.export(exports, "MlsApiClientImpl", ()=>MlsApiClientImpl);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _signaturePb = require("../../../message_contents/signature.pb");
var _emptyPb = require("../../../google/protobuf/empty.pb");
var _operators = require("rxjs/operators");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.mls.api.v1";
var SortDirection;
(function(SortDirection) {
    SortDirection[SortDirection["SORT_DIRECTION_UNSPECIFIED"] = 0] = "SORT_DIRECTION_UNSPECIFIED";
    SortDirection[SortDirection["SORT_DIRECTION_ASCENDING"] = 1] = "SORT_DIRECTION_ASCENDING";
    SortDirection[SortDirection["SORT_DIRECTION_DESCENDING"] = 2] = "SORT_DIRECTION_DESCENDING";
    SortDirection[SortDirection["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SortDirection || (SortDirection = {}));
function sortDirectionFromJSON(object) {
    switch(object){
        case 0:
        case "SORT_DIRECTION_UNSPECIFIED":
            return SortDirection.SORT_DIRECTION_UNSPECIFIED;
        case 1:
        case "SORT_DIRECTION_ASCENDING":
            return SortDirection.SORT_DIRECTION_ASCENDING;
        case 2:
        case "SORT_DIRECTION_DESCENDING":
            return SortDirection.SORT_DIRECTION_DESCENDING;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SortDirection.UNRECOGNIZED;
    }
}
function sortDirectionToJSON(object) {
    switch(object){
        case SortDirection.SORT_DIRECTION_UNSPECIFIED:
            return "SORT_DIRECTION_UNSPECIFIED";
        case SortDirection.SORT_DIRECTION_ASCENDING:
            return "SORT_DIRECTION_ASCENDING";
        case SortDirection.SORT_DIRECTION_DESCENDING:
            return "SORT_DIRECTION_DESCENDING";
        case SortDirection.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseWelcomeMessage() {
    return {
        v1: undefined
    };
}
const WelcomeMessage = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) WelcomeMessage_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWelcomeMessage();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = WelcomeMessage_V1.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? WelcomeMessage_V1.fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? WelcomeMessage_V1.toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseWelcomeMessage();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? WelcomeMessage_V1.fromPartial(object.v1) : undefined;
        return message;
    }
};
function createBaseWelcomeMessage_V1() {
    return {
        id: (0, _longDefault.default).UZERO,
        createdNs: (0, _longDefault.default).UZERO,
        installationKey: new Uint8Array(),
        data: new Uint8Array(),
        hpkePublicKey: new Uint8Array()
    };
}
const WelcomeMessage_V1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (!message.id.isZero()) writer.uint32(8).uint64(message.id);
        if (!message.createdNs.isZero()) writer.uint32(16).uint64(message.createdNs);
        if (message.installationKey.length !== 0) writer.uint32(26).bytes(message.installationKey);
        if (message.data.length !== 0) writer.uint32(34).bytes(message.data);
        if (message.hpkePublicKey.length !== 0) writer.uint32(42).bytes(message.hpkePublicKey);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWelcomeMessage_V1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.createdNs = reader.uint64();
                    break;
                case 3:
                    message.installationKey = reader.bytes();
                    break;
                case 4:
                    message.data = reader.bytes();
                    break;
                case 5:
                    message.hpkePublicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            id: isSet(object.id) ? (0, _longDefault.default).fromValue(object.id) : (0, _longDefault.default).UZERO,
            createdNs: isSet(object.createdNs) ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO,
            installationKey: isSet(object.installationKey) ? bytesFromBase64(object.installationKey) : new Uint8Array(),
            data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
            hpkePublicKey: isSet(object.hpkePublicKey) ? bytesFromBase64(object.hpkePublicKey) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.id !== undefined && (obj.id = (message.id || (0, _longDefault.default).UZERO).toString());
        message.createdNs !== undefined && (obj.createdNs = (message.createdNs || (0, _longDefault.default).UZERO).toString());
        message.installationKey !== undefined && (obj.installationKey = base64FromBytes(message.installationKey !== undefined ? message.installationKey : new Uint8Array()));
        message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
        message.hpkePublicKey !== undefined && (obj.hpkePublicKey = base64FromBytes(message.hpkePublicKey !== undefined ? message.hpkePublicKey : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseWelcomeMessage_V1();
        message.id = object.id !== undefined && object.id !== null ? (0, _longDefault.default).fromValue(object.id) : (0, _longDefault.default).UZERO;
        message.createdNs = object.createdNs !== undefined && object.createdNs !== null ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO;
        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.hpkePublicKey = (_c = object.hpkePublicKey) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
    }
};
function createBaseWelcomeMessageInput() {
    return {
        v1: undefined
    };
}
const WelcomeMessageInput = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) WelcomeMessageInput_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWelcomeMessageInput();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = WelcomeMessageInput_V1.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? WelcomeMessageInput_V1.fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? WelcomeMessageInput_V1.toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseWelcomeMessageInput();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? WelcomeMessageInput_V1.fromPartial(object.v1) : undefined;
        return message;
    }
};
function createBaseWelcomeMessageInput_V1() {
    return {
        installationKey: new Uint8Array(),
        data: new Uint8Array(),
        hpkePublicKey: new Uint8Array()
    };
}
const WelcomeMessageInput_V1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.installationKey.length !== 0) writer.uint32(10).bytes(message.installationKey);
        if (message.data.length !== 0) writer.uint32(18).bytes(message.data);
        if (message.hpkePublicKey.length !== 0) writer.uint32(26).bytes(message.hpkePublicKey);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWelcomeMessageInput_V1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.installationKey = reader.bytes();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                case 3:
                    message.hpkePublicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            installationKey: isSet(object.installationKey) ? bytesFromBase64(object.installationKey) : new Uint8Array(),
            data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
            hpkePublicKey: isSet(object.hpkePublicKey) ? bytesFromBase64(object.hpkePublicKey) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.installationKey !== undefined && (obj.installationKey = base64FromBytes(message.installationKey !== undefined ? message.installationKey : new Uint8Array()));
        message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
        message.hpkePublicKey !== undefined && (obj.hpkePublicKey = base64FromBytes(message.hpkePublicKey !== undefined ? message.hpkePublicKey : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseWelcomeMessageInput_V1();
        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.hpkePublicKey = (_c = object.hpkePublicKey) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
    }
};
function createBaseGroupMessage() {
    return {
        v1: undefined
    };
}
const GroupMessage = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) GroupMessage_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMessage();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = GroupMessage_V1.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? GroupMessage_V1.fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? GroupMessage_V1.toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGroupMessage();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? GroupMessage_V1.fromPartial(object.v1) : undefined;
        return message;
    }
};
function createBaseGroupMessage_V1() {
    return {
        id: (0, _longDefault.default).UZERO,
        createdNs: (0, _longDefault.default).UZERO,
        groupId: new Uint8Array(),
        data: new Uint8Array(),
        senderHmac: new Uint8Array(),
        shouldPush: false
    };
}
const GroupMessage_V1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (!message.id.isZero()) writer.uint32(8).uint64(message.id);
        if (!message.createdNs.isZero()) writer.uint32(16).uint64(message.createdNs);
        if (message.groupId.length !== 0) writer.uint32(26).bytes(message.groupId);
        if (message.data.length !== 0) writer.uint32(34).bytes(message.data);
        if (message.senderHmac.length !== 0) writer.uint32(42).bytes(message.senderHmac);
        if (message.shouldPush === true) writer.uint32(48).bool(message.shouldPush);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMessage_V1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.id = reader.uint64();
                    break;
                case 2:
                    message.createdNs = reader.uint64();
                    break;
                case 3:
                    message.groupId = reader.bytes();
                    break;
                case 4:
                    message.data = reader.bytes();
                    break;
                case 5:
                    message.senderHmac = reader.bytes();
                    break;
                case 6:
                    message.shouldPush = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            id: isSet(object.id) ? (0, _longDefault.default).fromValue(object.id) : (0, _longDefault.default).UZERO,
            createdNs: isSet(object.createdNs) ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO,
            groupId: isSet(object.groupId) ? bytesFromBase64(object.groupId) : new Uint8Array(),
            data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
            senderHmac: isSet(object.senderHmac) ? bytesFromBase64(object.senderHmac) : new Uint8Array(),
            shouldPush: isSet(object.shouldPush) ? Boolean(object.shouldPush) : false
        };
    },
    toJSON (message) {
        const obj = {};
        message.id !== undefined && (obj.id = (message.id || (0, _longDefault.default).UZERO).toString());
        message.createdNs !== undefined && (obj.createdNs = (message.createdNs || (0, _longDefault.default).UZERO).toString());
        message.groupId !== undefined && (obj.groupId = base64FromBytes(message.groupId !== undefined ? message.groupId : new Uint8Array()));
        message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
        message.senderHmac !== undefined && (obj.senderHmac = base64FromBytes(message.senderHmac !== undefined ? message.senderHmac : new Uint8Array()));
        message.shouldPush !== undefined && (obj.shouldPush = message.shouldPush);
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseGroupMessage_V1();
        message.id = object.id !== undefined && object.id !== null ? (0, _longDefault.default).fromValue(object.id) : (0, _longDefault.default).UZERO;
        message.createdNs = object.createdNs !== undefined && object.createdNs !== null ? (0, _longDefault.default).fromValue(object.createdNs) : (0, _longDefault.default).UZERO;
        message.groupId = (_a = object.groupId) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.senderHmac = (_c = object.senderHmac) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.shouldPush = (_d = object.shouldPush) !== null && _d !== void 0 ? _d : false;
        return message;
    }
};
function createBaseGroupMessageInput() {
    return {
        v1: undefined
    };
}
const GroupMessageInput = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) GroupMessageInput_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMessageInput();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = GroupMessageInput_V1.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? GroupMessageInput_V1.fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? GroupMessageInput_V1.toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGroupMessageInput();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? GroupMessageInput_V1.fromPartial(object.v1) : undefined;
        return message;
    }
};
function createBaseGroupMessageInput_V1() {
    return {
        data: new Uint8Array(),
        senderHmac: new Uint8Array(),
        shouldPush: false
    };
}
const GroupMessageInput_V1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.data.length !== 0) writer.uint32(10).bytes(message.data);
        if (message.senderHmac.length !== 0) writer.uint32(18).bytes(message.senderHmac);
        if (message.shouldPush === true) writer.uint32(24).bool(message.shouldPush);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMessageInput_V1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.data = reader.bytes();
                    break;
                case 2:
                    message.senderHmac = reader.bytes();
                    break;
                case 3:
                    message.shouldPush = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(),
            senderHmac: isSet(object.senderHmac) ? bytesFromBase64(object.senderHmac) : new Uint8Array(),
            shouldPush: isSet(object.shouldPush) ? Boolean(object.shouldPush) : false
        };
    },
    toJSON (message) {
        const obj = {};
        message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
        message.senderHmac !== undefined && (obj.senderHmac = base64FromBytes(message.senderHmac !== undefined ? message.senderHmac : new Uint8Array()));
        message.shouldPush !== undefined && (obj.shouldPush = message.shouldPush);
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseGroupMessageInput_V1();
        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.senderHmac = (_b = object.senderHmac) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.shouldPush = (_c = object.shouldPush) !== null && _c !== void 0 ? _c : false;
        return message;
    }
};
function createBaseSendGroupMessagesRequest() {
    return {
        messages: []
    };
}
const SendGroupMessagesRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.messages)GroupMessageInput.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendGroupMessagesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.messages.push(GroupMessageInput.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages) ? object.messages.map((e)=>GroupMessageInput.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.messages) obj.messages = message.messages.map((e)=>e ? GroupMessageInput.toJSON(e) : undefined);
        else obj.messages = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSendGroupMessagesRequest();
        message.messages = ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map((e)=>GroupMessageInput.fromPartial(e))) || [];
        return message;
    }
};
function createBaseSendWelcomeMessagesRequest() {
    return {
        messages: []
    };
}
const SendWelcomeMessagesRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.messages)WelcomeMessageInput.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendWelcomeMessagesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.messages.push(WelcomeMessageInput.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages) ? object.messages.map((e)=>WelcomeMessageInput.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.messages) obj.messages = message.messages.map((e)=>e ? WelcomeMessageInput.toJSON(e) : undefined);
        else obj.messages = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSendWelcomeMessagesRequest();
        message.messages = ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map((e)=>WelcomeMessageInput.fromPartial(e))) || [];
        return message;
    }
};
function createBaseKeyPackageUpload() {
    return {
        keyPackageTlsSerialized: new Uint8Array()
    };
}
const KeyPackageUpload = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.keyPackageTlsSerialized.length !== 0) writer.uint32(10).bytes(message.keyPackageTlsSerialized);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseKeyPackageUpload();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyPackageTlsSerialized = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            keyPackageTlsSerialized: isSet(object.keyPackageTlsSerialized) ? bytesFromBase64(object.keyPackageTlsSerialized) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.keyPackageTlsSerialized !== undefined && (obj.keyPackageTlsSerialized = base64FromBytes(message.keyPackageTlsSerialized !== undefined ? message.keyPackageTlsSerialized : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseKeyPackageUpload();
        message.keyPackageTlsSerialized = (_a = object.keyPackageTlsSerialized) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseRegisterInstallationRequest() {
    return {
        keyPackage: undefined,
        isInboxIdCredential: false
    };
}
const RegisterInstallationRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.keyPackage !== undefined) KeyPackageUpload.encode(message.keyPackage, writer.uint32(10).fork()).ldelim();
        if (message.isInboxIdCredential === true) writer.uint32(16).bool(message.isInboxIdCredential);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRegisterInstallationRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyPackage = KeyPackageUpload.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.isInboxIdCredential = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            keyPackage: isSet(object.keyPackage) ? KeyPackageUpload.fromJSON(object.keyPackage) : undefined,
            isInboxIdCredential: isSet(object.isInboxIdCredential) ? Boolean(object.isInboxIdCredential) : false
        };
    },
    toJSON (message) {
        const obj = {};
        message.keyPackage !== undefined && (obj.keyPackage = message.keyPackage ? KeyPackageUpload.toJSON(message.keyPackage) : undefined);
        message.isInboxIdCredential !== undefined && (obj.isInboxIdCredential = message.isInboxIdCredential);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseRegisterInstallationRequest();
        message.keyPackage = object.keyPackage !== undefined && object.keyPackage !== null ? KeyPackageUpload.fromPartial(object.keyPackage) : undefined;
        message.isInboxIdCredential = (_a = object.isInboxIdCredential) !== null && _a !== void 0 ? _a : false;
        return message;
    }
};
function createBaseRegisterInstallationResponse() {
    return {
        installationKey: new Uint8Array()
    };
}
const RegisterInstallationResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.installationKey.length !== 0) writer.uint32(10).bytes(message.installationKey);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRegisterInstallationResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.installationKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            installationKey: isSet(object.installationKey) ? bytesFromBase64(object.installationKey) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.installationKey !== undefined && (obj.installationKey = base64FromBytes(message.installationKey !== undefined ? message.installationKey : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseRegisterInstallationResponse();
        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseUploadKeyPackageRequest() {
    return {
        keyPackage: undefined,
        isInboxIdCredential: false
    };
}
const UploadKeyPackageRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.keyPackage !== undefined) KeyPackageUpload.encode(message.keyPackage, writer.uint32(10).fork()).ldelim();
        if (message.isInboxIdCredential === true) writer.uint32(16).bool(message.isInboxIdCredential);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUploadKeyPackageRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyPackage = KeyPackageUpload.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.isInboxIdCredential = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            keyPackage: isSet(object.keyPackage) ? KeyPackageUpload.fromJSON(object.keyPackage) : undefined,
            isInboxIdCredential: isSet(object.isInboxIdCredential) ? Boolean(object.isInboxIdCredential) : false
        };
    },
    toJSON (message) {
        const obj = {};
        message.keyPackage !== undefined && (obj.keyPackage = message.keyPackage ? KeyPackageUpload.toJSON(message.keyPackage) : undefined);
        message.isInboxIdCredential !== undefined && (obj.isInboxIdCredential = message.isInboxIdCredential);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseUploadKeyPackageRequest();
        message.keyPackage = object.keyPackage !== undefined && object.keyPackage !== null ? KeyPackageUpload.fromPartial(object.keyPackage) : undefined;
        message.isInboxIdCredential = (_a = object.isInboxIdCredential) !== null && _a !== void 0 ? _a : false;
        return message;
    }
};
function createBaseFetchKeyPackagesRequest() {
    return {
        installationKeys: []
    };
}
const FetchKeyPackagesRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.installationKeys)writer.uint32(10).bytes(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFetchKeyPackagesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.installationKeys.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            installationKeys: Array.isArray(object === null || object === void 0 ? void 0 : object.installationKeys) ? object.installationKeys.map((e)=>bytesFromBase64(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.installationKeys) obj.installationKeys = message.installationKeys.map((e)=>base64FromBytes(e !== undefined ? e : new Uint8Array()));
        else obj.installationKeys = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseFetchKeyPackagesRequest();
        message.installationKeys = ((_a = object.installationKeys) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
function createBaseFetchKeyPackagesResponse() {
    return {
        keyPackages: []
    };
}
const FetchKeyPackagesResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.keyPackages)FetchKeyPackagesResponse_KeyPackage.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFetchKeyPackagesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyPackages.push(FetchKeyPackagesResponse_KeyPackage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            keyPackages: Array.isArray(object === null || object === void 0 ? void 0 : object.keyPackages) ? object.keyPackages.map((e)=>FetchKeyPackagesResponse_KeyPackage.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.keyPackages) obj.keyPackages = message.keyPackages.map((e)=>e ? FetchKeyPackagesResponse_KeyPackage.toJSON(e) : undefined);
        else obj.keyPackages = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseFetchKeyPackagesResponse();
        message.keyPackages = ((_a = object.keyPackages) === null || _a === void 0 ? void 0 : _a.map((e)=>FetchKeyPackagesResponse_KeyPackage.fromPartial(e))) || [];
        return message;
    }
};
function createBaseFetchKeyPackagesResponse_KeyPackage() {
    return {
        keyPackageTlsSerialized: new Uint8Array()
    };
}
const FetchKeyPackagesResponse_KeyPackage = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.keyPackageTlsSerialized.length !== 0) writer.uint32(10).bytes(message.keyPackageTlsSerialized);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFetchKeyPackagesResponse_KeyPackage();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyPackageTlsSerialized = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            keyPackageTlsSerialized: isSet(object.keyPackageTlsSerialized) ? bytesFromBase64(object.keyPackageTlsSerialized) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.keyPackageTlsSerialized !== undefined && (obj.keyPackageTlsSerialized = base64FromBytes(message.keyPackageTlsSerialized !== undefined ? message.keyPackageTlsSerialized : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseFetchKeyPackagesResponse_KeyPackage();
        message.keyPackageTlsSerialized = (_a = object.keyPackageTlsSerialized) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseRevokeInstallationRequest() {
    return {
        installationKey: new Uint8Array(),
        walletSignature: undefined
    };
}
const RevokeInstallationRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.installationKey.length !== 0) writer.uint32(10).bytes(message.installationKey);
        if (message.walletSignature !== undefined) (0, _signaturePb.Signature).encode(message.walletSignature, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRevokeInstallationRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.installationKey = reader.bytes();
                    break;
                case 2:
                    message.walletSignature = (0, _signaturePb.Signature).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            installationKey: isSet(object.installationKey) ? bytesFromBase64(object.installationKey) : new Uint8Array(),
            walletSignature: isSet(object.walletSignature) ? (0, _signaturePb.Signature).fromJSON(object.walletSignature) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.installationKey !== undefined && (obj.installationKey = base64FromBytes(message.installationKey !== undefined ? message.installationKey : new Uint8Array()));
        message.walletSignature !== undefined && (obj.walletSignature = message.walletSignature ? (0, _signaturePb.Signature).toJSON(message.walletSignature) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseRevokeInstallationRequest();
        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.walletSignature = object.walletSignature !== undefined && object.walletSignature !== null ? (0, _signaturePb.Signature).fromPartial(object.walletSignature) : undefined;
        return message;
    }
};
function createBaseGetIdentityUpdatesRequest() {
    return {
        accountAddresses: [],
        startTimeNs: (0, _longDefault.default).UZERO
    };
}
const GetIdentityUpdatesRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.accountAddresses)writer.uint32(10).string(v);
        if (!message.startTimeNs.isZero()) writer.uint32(16).uint64(message.startTimeNs);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.accountAddresses.push(reader.string());
                    break;
                case 2:
                    message.startTimeNs = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            accountAddresses: Array.isArray(object === null || object === void 0 ? void 0 : object.accountAddresses) ? object.accountAddresses.map((e)=>String(e)) : [],
            startTimeNs: isSet(object.startTimeNs) ? (0, _longDefault.default).fromValue(object.startTimeNs) : (0, _longDefault.default).UZERO
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.accountAddresses) obj.accountAddresses = message.accountAddresses.map((e)=>e);
        else obj.accountAddresses = [];
        message.startTimeNs !== undefined && (obj.startTimeNs = (message.startTimeNs || (0, _longDefault.default).UZERO).toString());
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetIdentityUpdatesRequest();
        message.accountAddresses = ((_a = object.accountAddresses) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        message.startTimeNs = object.startTimeNs !== undefined && object.startTimeNs !== null ? (0, _longDefault.default).fromValue(object.startTimeNs) : (0, _longDefault.default).UZERO;
        return message;
    }
};
function createBaseGetIdentityUpdatesResponse() {
    return {
        updates: []
    };
}
const GetIdentityUpdatesResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.updates)GetIdentityUpdatesResponse_WalletUpdates.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.updates.push(GetIdentityUpdatesResponse_WalletUpdates.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            updates: Array.isArray(object === null || object === void 0 ? void 0 : object.updates) ? object.updates.map((e)=>GetIdentityUpdatesResponse_WalletUpdates.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.updates) obj.updates = message.updates.map((e)=>e ? GetIdentityUpdatesResponse_WalletUpdates.toJSON(e) : undefined);
        else obj.updates = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetIdentityUpdatesResponse();
        message.updates = ((_a = object.updates) === null || _a === void 0 ? void 0 : _a.map((e)=>GetIdentityUpdatesResponse_WalletUpdates.fromPartial(e))) || [];
        return message;
    }
};
function createBaseGetIdentityUpdatesResponse_NewInstallationUpdate() {
    return {
        installationKey: new Uint8Array(),
        credentialIdentity: new Uint8Array()
    };
}
const GetIdentityUpdatesResponse_NewInstallationUpdate = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.installationKey.length !== 0) writer.uint32(10).bytes(message.installationKey);
        if (message.credentialIdentity.length !== 0) writer.uint32(18).bytes(message.credentialIdentity);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesResponse_NewInstallationUpdate();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.installationKey = reader.bytes();
                    break;
                case 2:
                    message.credentialIdentity = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            installationKey: isSet(object.installationKey) ? bytesFromBase64(object.installationKey) : new Uint8Array(),
            credentialIdentity: isSet(object.credentialIdentity) ? bytesFromBase64(object.credentialIdentity) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.installationKey !== undefined && (obj.installationKey = base64FromBytes(message.installationKey !== undefined ? message.installationKey : new Uint8Array()));
        message.credentialIdentity !== undefined && (obj.credentialIdentity = base64FromBytes(message.credentialIdentity !== undefined ? message.credentialIdentity : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseGetIdentityUpdatesResponse_NewInstallationUpdate();
        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.credentialIdentity = (_b = object.credentialIdentity) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    }
};
function createBaseGetIdentityUpdatesResponse_RevokedInstallationUpdate() {
    return {
        installationKey: new Uint8Array()
    };
}
const GetIdentityUpdatesResponse_RevokedInstallationUpdate = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.installationKey.length !== 0) writer.uint32(10).bytes(message.installationKey);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesResponse_RevokedInstallationUpdate();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.installationKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            installationKey: isSet(object.installationKey) ? bytesFromBase64(object.installationKey) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.installationKey !== undefined && (obj.installationKey = base64FromBytes(message.installationKey !== undefined ? message.installationKey : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetIdentityUpdatesResponse_RevokedInstallationUpdate();
        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseGetIdentityUpdatesResponse_Update() {
    return {
        timestampNs: (0, _longDefault.default).UZERO,
        newInstallation: undefined,
        revokedInstallation: undefined
    };
}
const GetIdentityUpdatesResponse_Update = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (!message.timestampNs.isZero()) writer.uint32(8).uint64(message.timestampNs);
        if (message.newInstallation !== undefined) GetIdentityUpdatesResponse_NewInstallationUpdate.encode(message.newInstallation, writer.uint32(18).fork()).ldelim();
        if (message.revokedInstallation !== undefined) GetIdentityUpdatesResponse_RevokedInstallationUpdate.encode(message.revokedInstallation, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesResponse_Update();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.timestampNs = reader.uint64();
                    break;
                case 2:
                    message.newInstallation = GetIdentityUpdatesResponse_NewInstallationUpdate.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.revokedInstallation = GetIdentityUpdatesResponse_RevokedInstallationUpdate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            timestampNs: isSet(object.timestampNs) ? (0, _longDefault.default).fromValue(object.timestampNs) : (0, _longDefault.default).UZERO,
            newInstallation: isSet(object.newInstallation) ? GetIdentityUpdatesResponse_NewInstallationUpdate.fromJSON(object.newInstallation) : undefined,
            revokedInstallation: isSet(object.revokedInstallation) ? GetIdentityUpdatesResponse_RevokedInstallationUpdate.fromJSON(object.revokedInstallation) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.timestampNs !== undefined && (obj.timestampNs = (message.timestampNs || (0, _longDefault.default).UZERO).toString());
        message.newInstallation !== undefined && (obj.newInstallation = message.newInstallation ? GetIdentityUpdatesResponse_NewInstallationUpdate.toJSON(message.newInstallation) : undefined);
        message.revokedInstallation !== undefined && (obj.revokedInstallation = message.revokedInstallation ? GetIdentityUpdatesResponse_RevokedInstallationUpdate.toJSON(message.revokedInstallation) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGetIdentityUpdatesResponse_Update();
        message.timestampNs = object.timestampNs !== undefined && object.timestampNs !== null ? (0, _longDefault.default).fromValue(object.timestampNs) : (0, _longDefault.default).UZERO;
        message.newInstallation = object.newInstallation !== undefined && object.newInstallation !== null ? GetIdentityUpdatesResponse_NewInstallationUpdate.fromPartial(object.newInstallation) : undefined;
        message.revokedInstallation = object.revokedInstallation !== undefined && object.revokedInstallation !== null ? GetIdentityUpdatesResponse_RevokedInstallationUpdate.fromPartial(object.revokedInstallation) : undefined;
        return message;
    }
};
function createBaseGetIdentityUpdatesResponse_WalletUpdates() {
    return {
        updates: []
    };
}
const GetIdentityUpdatesResponse_WalletUpdates = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.updates)GetIdentityUpdatesResponse_Update.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesResponse_WalletUpdates();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.updates.push(GetIdentityUpdatesResponse_Update.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            updates: Array.isArray(object === null || object === void 0 ? void 0 : object.updates) ? object.updates.map((e)=>GetIdentityUpdatesResponse_Update.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.updates) obj.updates = message.updates.map((e)=>e ? GetIdentityUpdatesResponse_Update.toJSON(e) : undefined);
        else obj.updates = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetIdentityUpdatesResponse_WalletUpdates();
        message.updates = ((_a = object.updates) === null || _a === void 0 ? void 0 : _a.map((e)=>GetIdentityUpdatesResponse_Update.fromPartial(e))) || [];
        return message;
    }
};
function createBasePagingInfo() {
    return {
        direction: 0,
        limit: 0,
        idCursor: (0, _longDefault.default).UZERO
    };
}
const PagingInfo = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.direction !== 0) writer.uint32(8).int32(message.direction);
        if (message.limit !== 0) writer.uint32(16).uint32(message.limit);
        if (!message.idCursor.isZero()) writer.uint32(24).uint64(message.idCursor);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePagingInfo();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.direction = reader.int32();
                    break;
                case 2:
                    message.limit = reader.uint32();
                    break;
                case 3:
                    message.idCursor = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            direction: isSet(object.direction) ? sortDirectionFromJSON(object.direction) : 0,
            limit: isSet(object.limit) ? Number(object.limit) : 0,
            idCursor: isSet(object.idCursor) ? (0, _longDefault.default).fromValue(object.idCursor) : (0, _longDefault.default).UZERO
        };
    },
    toJSON (message) {
        const obj = {};
        message.direction !== undefined && (obj.direction = sortDirectionToJSON(message.direction));
        message.limit !== undefined && (obj.limit = Math.round(message.limit));
        message.idCursor !== undefined && (obj.idCursor = (message.idCursor || (0, _longDefault.default).UZERO).toString());
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBasePagingInfo();
        message.direction = (_a = object.direction) !== null && _a !== void 0 ? _a : 0;
        message.limit = (_b = object.limit) !== null && _b !== void 0 ? _b : 0;
        message.idCursor = object.idCursor !== undefined && object.idCursor !== null ? (0, _longDefault.default).fromValue(object.idCursor) : (0, _longDefault.default).UZERO;
        return message;
    }
};
function createBaseQueryGroupMessagesRequest() {
    return {
        groupId: new Uint8Array(),
        pagingInfo: undefined
    };
}
const QueryGroupMessagesRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.groupId.length !== 0) writer.uint32(10).bytes(message.groupId);
        if (message.pagingInfo !== undefined) PagingInfo.encode(message.pagingInfo, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGroupMessagesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.groupId = reader.bytes();
                    break;
                case 2:
                    message.pagingInfo = PagingInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            groupId: isSet(object.groupId) ? bytesFromBase64(object.groupId) : new Uint8Array(),
            pagingInfo: isSet(object.pagingInfo) ? PagingInfo.fromJSON(object.pagingInfo) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.groupId !== undefined && (obj.groupId = base64FromBytes(message.groupId !== undefined ? message.groupId : new Uint8Array()));
        message.pagingInfo !== undefined && (obj.pagingInfo = message.pagingInfo ? PagingInfo.toJSON(message.pagingInfo) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseQueryGroupMessagesRequest();
        message.groupId = (_a = object.groupId) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.pagingInfo = object.pagingInfo !== undefined && object.pagingInfo !== null ? PagingInfo.fromPartial(object.pagingInfo) : undefined;
        return message;
    }
};
function createBaseQueryGroupMessagesResponse() {
    return {
        messages: [],
        pagingInfo: undefined
    };
}
const QueryGroupMessagesResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.messages)GroupMessage.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagingInfo !== undefined) PagingInfo.encode(message.pagingInfo, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGroupMessagesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.messages.push(GroupMessage.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagingInfo = PagingInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages) ? object.messages.map((e)=>GroupMessage.fromJSON(e)) : [],
            pagingInfo: isSet(object.pagingInfo) ? PagingInfo.fromJSON(object.pagingInfo) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.messages) obj.messages = message.messages.map((e)=>e ? GroupMessage.toJSON(e) : undefined);
        else obj.messages = [];
        message.pagingInfo !== undefined && (obj.pagingInfo = message.pagingInfo ? PagingInfo.toJSON(message.pagingInfo) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseQueryGroupMessagesResponse();
        message.messages = ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map((e)=>GroupMessage.fromPartial(e))) || [];
        message.pagingInfo = object.pagingInfo !== undefined && object.pagingInfo !== null ? PagingInfo.fromPartial(object.pagingInfo) : undefined;
        return message;
    }
};
function createBaseQueryWelcomeMessagesRequest() {
    return {
        installationKey: new Uint8Array(),
        pagingInfo: undefined
    };
}
const QueryWelcomeMessagesRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.installationKey.length !== 0) writer.uint32(10).bytes(message.installationKey);
        if (message.pagingInfo !== undefined) PagingInfo.encode(message.pagingInfo, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryWelcomeMessagesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.installationKey = reader.bytes();
                    break;
                case 2:
                    message.pagingInfo = PagingInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            installationKey: isSet(object.installationKey) ? bytesFromBase64(object.installationKey) : new Uint8Array(),
            pagingInfo: isSet(object.pagingInfo) ? PagingInfo.fromJSON(object.pagingInfo) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.installationKey !== undefined && (obj.installationKey = base64FromBytes(message.installationKey !== undefined ? message.installationKey : new Uint8Array()));
        message.pagingInfo !== undefined && (obj.pagingInfo = message.pagingInfo ? PagingInfo.toJSON(message.pagingInfo) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseQueryWelcomeMessagesRequest();
        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.pagingInfo = object.pagingInfo !== undefined && object.pagingInfo !== null ? PagingInfo.fromPartial(object.pagingInfo) : undefined;
        return message;
    }
};
function createBaseQueryWelcomeMessagesResponse() {
    return {
        messages: [],
        pagingInfo: undefined
    };
}
const QueryWelcomeMessagesResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.messages)WelcomeMessage.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.pagingInfo !== undefined) PagingInfo.encode(message.pagingInfo, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryWelcomeMessagesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.messages.push(WelcomeMessage.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.pagingInfo = PagingInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages) ? object.messages.map((e)=>WelcomeMessage.fromJSON(e)) : [],
            pagingInfo: isSet(object.pagingInfo) ? PagingInfo.fromJSON(object.pagingInfo) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.messages) obj.messages = message.messages.map((e)=>e ? WelcomeMessage.toJSON(e) : undefined);
        else obj.messages = [];
        message.pagingInfo !== undefined && (obj.pagingInfo = message.pagingInfo ? PagingInfo.toJSON(message.pagingInfo) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseQueryWelcomeMessagesResponse();
        message.messages = ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map((e)=>WelcomeMessage.fromPartial(e))) || [];
        message.pagingInfo = object.pagingInfo !== undefined && object.pagingInfo !== null ? PagingInfo.fromPartial(object.pagingInfo) : undefined;
        return message;
    }
};
function createBaseSubscribeGroupMessagesRequest() {
    return {
        filters: []
    };
}
const SubscribeGroupMessagesRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.filters)SubscribeGroupMessagesRequest_Filter.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscribeGroupMessagesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.filters.push(SubscribeGroupMessagesRequest_Filter.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            filters: Array.isArray(object === null || object === void 0 ? void 0 : object.filters) ? object.filters.map((e)=>SubscribeGroupMessagesRequest_Filter.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.filters) obj.filters = message.filters.map((e)=>e ? SubscribeGroupMessagesRequest_Filter.toJSON(e) : undefined);
        else obj.filters = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSubscribeGroupMessagesRequest();
        message.filters = ((_a = object.filters) === null || _a === void 0 ? void 0 : _a.map((e)=>SubscribeGroupMessagesRequest_Filter.fromPartial(e))) || [];
        return message;
    }
};
function createBaseSubscribeGroupMessagesRequest_Filter() {
    return {
        groupId: new Uint8Array(),
        idCursor: (0, _longDefault.default).UZERO
    };
}
const SubscribeGroupMessagesRequest_Filter = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.groupId.length !== 0) writer.uint32(10).bytes(message.groupId);
        if (!message.idCursor.isZero()) writer.uint32(16).uint64(message.idCursor);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscribeGroupMessagesRequest_Filter();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.groupId = reader.bytes();
                    break;
                case 2:
                    message.idCursor = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            groupId: isSet(object.groupId) ? bytesFromBase64(object.groupId) : new Uint8Array(),
            idCursor: isSet(object.idCursor) ? (0, _longDefault.default).fromValue(object.idCursor) : (0, _longDefault.default).UZERO
        };
    },
    toJSON (message) {
        const obj = {};
        message.groupId !== undefined && (obj.groupId = base64FromBytes(message.groupId !== undefined ? message.groupId : new Uint8Array()));
        message.idCursor !== undefined && (obj.idCursor = (message.idCursor || (0, _longDefault.default).UZERO).toString());
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSubscribeGroupMessagesRequest_Filter();
        message.groupId = (_a = object.groupId) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.idCursor = object.idCursor !== undefined && object.idCursor !== null ? (0, _longDefault.default).fromValue(object.idCursor) : (0, _longDefault.default).UZERO;
        return message;
    }
};
function createBaseSubscribeWelcomeMessagesRequest() {
    return {
        filters: []
    };
}
const SubscribeWelcomeMessagesRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.filters)SubscribeWelcomeMessagesRequest_Filter.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscribeWelcomeMessagesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.filters.push(SubscribeWelcomeMessagesRequest_Filter.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            filters: Array.isArray(object === null || object === void 0 ? void 0 : object.filters) ? object.filters.map((e)=>SubscribeWelcomeMessagesRequest_Filter.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.filters) obj.filters = message.filters.map((e)=>e ? SubscribeWelcomeMessagesRequest_Filter.toJSON(e) : undefined);
        else obj.filters = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSubscribeWelcomeMessagesRequest();
        message.filters = ((_a = object.filters) === null || _a === void 0 ? void 0 : _a.map((e)=>SubscribeWelcomeMessagesRequest_Filter.fromPartial(e))) || [];
        return message;
    }
};
function createBaseSubscribeWelcomeMessagesRequest_Filter() {
    return {
        installationKey: new Uint8Array(),
        idCursor: (0, _longDefault.default).UZERO
    };
}
const SubscribeWelcomeMessagesRequest_Filter = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.installationKey.length !== 0) writer.uint32(10).bytes(message.installationKey);
        if (!message.idCursor.isZero()) writer.uint32(16).uint64(message.idCursor);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscribeWelcomeMessagesRequest_Filter();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.installationKey = reader.bytes();
                    break;
                case 2:
                    message.idCursor = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            installationKey: isSet(object.installationKey) ? bytesFromBase64(object.installationKey) : new Uint8Array(),
            idCursor: isSet(object.idCursor) ? (0, _longDefault.default).fromValue(object.idCursor) : (0, _longDefault.default).UZERO
        };
    },
    toJSON (message) {
        const obj = {};
        message.installationKey !== undefined && (obj.installationKey = base64FromBytes(message.installationKey !== undefined ? message.installationKey : new Uint8Array()));
        message.idCursor !== undefined && (obj.idCursor = (message.idCursor || (0, _longDefault.default).UZERO).toString());
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSubscribeWelcomeMessagesRequest_Filter();
        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.idCursor = object.idCursor !== undefined && object.idCursor !== null ? (0, _longDefault.default).fromValue(object.idCursor) : (0, _longDefault.default).UZERO;
        return message;
    }
};
class MlsApiClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.SendGroupMessages = this.SendGroupMessages.bind(this);
        this.SendWelcomeMessages = this.SendWelcomeMessages.bind(this);
        this.RegisterInstallation = this.RegisterInstallation.bind(this);
        this.UploadKeyPackage = this.UploadKeyPackage.bind(this);
        this.FetchKeyPackages = this.FetchKeyPackages.bind(this);
        this.RevokeInstallation = this.RevokeInstallation.bind(this);
        this.GetIdentityUpdates = this.GetIdentityUpdates.bind(this);
        this.QueryGroupMessages = this.QueryGroupMessages.bind(this);
        this.QueryWelcomeMessages = this.QueryWelcomeMessages.bind(this);
        this.SubscribeGroupMessages = this.SubscribeGroupMessages.bind(this);
        this.SubscribeWelcomeMessages = this.SubscribeWelcomeMessages.bind(this);
    }
    SendGroupMessages(request) {
        const data = SendGroupMessagesRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.mls.api.v1.MlsApi", "SendGroupMessages", data);
        return promise.then((data)=>(0, _emptyPb.Empty).decode(new (0, _minimalDefault.default).Reader(data)));
    }
    SendWelcomeMessages(request) {
        const data = SendWelcomeMessagesRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.mls.api.v1.MlsApi", "SendWelcomeMessages", data);
        return promise.then((data)=>(0, _emptyPb.Empty).decode(new (0, _minimalDefault.default).Reader(data)));
    }
    RegisterInstallation(request) {
        const data = RegisterInstallationRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.mls.api.v1.MlsApi", "RegisterInstallation", data);
        return promise.then((data)=>RegisterInstallationResponse.decode(new (0, _minimalDefault.default).Reader(data)));
    }
    UploadKeyPackage(request) {
        const data = UploadKeyPackageRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.mls.api.v1.MlsApi", "UploadKeyPackage", data);
        return promise.then((data)=>(0, _emptyPb.Empty).decode(new (0, _minimalDefault.default).Reader(data)));
    }
    FetchKeyPackages(request) {
        const data = FetchKeyPackagesRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.mls.api.v1.MlsApi", "FetchKeyPackages", data);
        return promise.then((data)=>FetchKeyPackagesResponse.decode(new (0, _minimalDefault.default).Reader(data)));
    }
    RevokeInstallation(request) {
        const data = RevokeInstallationRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.mls.api.v1.MlsApi", "RevokeInstallation", data);
        return promise.then((data)=>(0, _emptyPb.Empty).decode(new (0, _minimalDefault.default).Reader(data)));
    }
    GetIdentityUpdates(request) {
        const data = GetIdentityUpdatesRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.mls.api.v1.MlsApi", "GetIdentityUpdates", data);
        return promise.then((data)=>GetIdentityUpdatesResponse.decode(new (0, _minimalDefault.default).Reader(data)));
    }
    QueryGroupMessages(request) {
        const data = QueryGroupMessagesRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.mls.api.v1.MlsApi", "QueryGroupMessages", data);
        return promise.then((data)=>QueryGroupMessagesResponse.decode(new (0, _minimalDefault.default).Reader(data)));
    }
    QueryWelcomeMessages(request) {
        const data = QueryWelcomeMessagesRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.mls.api.v1.MlsApi", "QueryWelcomeMessages", data);
        return promise.then((data)=>QueryWelcomeMessagesResponse.decode(new (0, _minimalDefault.default).Reader(data)));
    }
    SubscribeGroupMessages(request) {
        const data = SubscribeGroupMessagesRequest.encode(request).finish();
        const result = this.rpc.serverStreamingRequest("xmtp.mls.api.v1.MlsApi", "SubscribeGroupMessages", data);
        return result.pipe((0, _operators.map)((data)=>GroupMessage.decode(new (0, _minimalDefault.default).Reader(data))));
    }
    SubscribeWelcomeMessages(request) {
        const data = SubscribeWelcomeMessagesRequest.encode(request).finish();
        const result = this.rpc.serverStreamingRequest("xmtp.mls.api.v1.MlsApi", "SubscribeWelcomeMessages", data);
        return result.pipe((0, _operators.map)((data)=>WelcomeMessage.decode(new (0, _minimalDefault.default).Reader(data))));
    }
}
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","../../../message_contents/signature.pb":"hvHvx","../../../google/protobuf/empty.pb":"6qi1y","rxjs/operators":"hLs7d","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6qi1y":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "Empty", ()=>Empty);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
const protobufPackage = "google.protobuf";
function createBaseEmpty() {
    return {};
}
const Empty = {
    encode (_, writer = (0, _minimalDefault.default).Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEmpty();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBaseEmpty();
        return message;
    }
};
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}

},{"long":"3JDQT","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hLs7d":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "audit", ()=>(0, _audit.audit));
parcelHelpers.export(exports, "auditTime", ()=>(0, _auditTime.auditTime));
parcelHelpers.export(exports, "buffer", ()=>(0, _buffer.buffer));
parcelHelpers.export(exports, "bufferCount", ()=>(0, _bufferCount.bufferCount));
parcelHelpers.export(exports, "bufferTime", ()=>(0, _bufferTime.bufferTime));
parcelHelpers.export(exports, "bufferToggle", ()=>(0, _bufferToggle.bufferToggle));
parcelHelpers.export(exports, "bufferWhen", ()=>(0, _bufferWhen.bufferWhen));
parcelHelpers.export(exports, "catchError", ()=>(0, _catchError.catchError));
parcelHelpers.export(exports, "combineAll", ()=>(0, _combineAll.combineAll));
parcelHelpers.export(exports, "combineLatestAll", ()=>(0, _combineLatestAll.combineLatestAll));
parcelHelpers.export(exports, "combineLatest", ()=>(0, _combineLatest.combineLatest));
parcelHelpers.export(exports, "combineLatestWith", ()=>(0, _combineLatestWith.combineLatestWith));
parcelHelpers.export(exports, "concat", ()=>(0, _concat.concat));
parcelHelpers.export(exports, "concatAll", ()=>(0, _concatAll.concatAll));
parcelHelpers.export(exports, "concatMap", ()=>(0, _concatMap.concatMap));
parcelHelpers.export(exports, "concatMapTo", ()=>(0, _concatMapTo.concatMapTo));
parcelHelpers.export(exports, "concatWith", ()=>(0, _concatWith.concatWith));
parcelHelpers.export(exports, "connect", ()=>(0, _connect.connect));
parcelHelpers.export(exports, "count", ()=>(0, _count.count));
parcelHelpers.export(exports, "debounce", ()=>(0, _debounce.debounce));
parcelHelpers.export(exports, "debounceTime", ()=>(0, _debounceTime.debounceTime));
parcelHelpers.export(exports, "defaultIfEmpty", ()=>(0, _defaultIfEmpty.defaultIfEmpty));
parcelHelpers.export(exports, "delay", ()=>(0, _delay.delay));
parcelHelpers.export(exports, "delayWhen", ()=>(0, _delayWhen.delayWhen));
parcelHelpers.export(exports, "dematerialize", ()=>(0, _dematerialize.dematerialize));
parcelHelpers.export(exports, "distinct", ()=>(0, _distinct.distinct));
parcelHelpers.export(exports, "distinctUntilChanged", ()=>(0, _distinctUntilChanged.distinctUntilChanged));
parcelHelpers.export(exports, "distinctUntilKeyChanged", ()=>(0, _distinctUntilKeyChanged.distinctUntilKeyChanged));
parcelHelpers.export(exports, "elementAt", ()=>(0, _elementAt.elementAt));
parcelHelpers.export(exports, "endWith", ()=>(0, _endWith.endWith));
parcelHelpers.export(exports, "every", ()=>(0, _every.every));
parcelHelpers.export(exports, "exhaust", ()=>(0, _exhaust.exhaust));
parcelHelpers.export(exports, "exhaustAll", ()=>(0, _exhaustAll.exhaustAll));
parcelHelpers.export(exports, "exhaustMap", ()=>(0, _exhaustMap.exhaustMap));
parcelHelpers.export(exports, "expand", ()=>(0, _expand.expand));
parcelHelpers.export(exports, "filter", ()=>(0, _filter.filter));
parcelHelpers.export(exports, "finalize", ()=>(0, _finalize.finalize));
parcelHelpers.export(exports, "find", ()=>(0, _find.find));
parcelHelpers.export(exports, "findIndex", ()=>(0, _findIndex.findIndex));
parcelHelpers.export(exports, "first", ()=>(0, _first.first));
parcelHelpers.export(exports, "groupBy", ()=>(0, _groupBy.groupBy));
parcelHelpers.export(exports, "ignoreElements", ()=>(0, _ignoreElements.ignoreElements));
parcelHelpers.export(exports, "isEmpty", ()=>(0, _isEmpty.isEmpty));
parcelHelpers.export(exports, "last", ()=>(0, _last.last));
parcelHelpers.export(exports, "map", ()=>(0, _map.map));
parcelHelpers.export(exports, "mapTo", ()=>(0, _mapTo.mapTo));
parcelHelpers.export(exports, "materialize", ()=>(0, _materialize.materialize));
parcelHelpers.export(exports, "max", ()=>(0, _max.max));
parcelHelpers.export(exports, "merge", ()=>(0, _merge.merge));
parcelHelpers.export(exports, "mergeAll", ()=>(0, _mergeAll.mergeAll));
parcelHelpers.export(exports, "flatMap", ()=>(0, _flatMap.flatMap));
parcelHelpers.export(exports, "mergeMap", ()=>(0, _mergeMap.mergeMap));
parcelHelpers.export(exports, "mergeMapTo", ()=>(0, _mergeMapTo.mergeMapTo));
parcelHelpers.export(exports, "mergeScan", ()=>(0, _mergeScan.mergeScan));
parcelHelpers.export(exports, "mergeWith", ()=>(0, _mergeWith.mergeWith));
parcelHelpers.export(exports, "min", ()=>(0, _min.min));
parcelHelpers.export(exports, "multicast", ()=>(0, _multicast.multicast));
parcelHelpers.export(exports, "observeOn", ()=>(0, _observeOn.observeOn));
parcelHelpers.export(exports, "onErrorResumeNext", ()=>(0, _onErrorResumeNextWith.onErrorResumeNext));
parcelHelpers.export(exports, "pairwise", ()=>(0, _pairwise.pairwise));
parcelHelpers.export(exports, "partition", ()=>(0, _partition.partition));
parcelHelpers.export(exports, "pluck", ()=>(0, _pluck.pluck));
parcelHelpers.export(exports, "publish", ()=>(0, _publish.publish));
parcelHelpers.export(exports, "publishBehavior", ()=>(0, _publishBehavior.publishBehavior));
parcelHelpers.export(exports, "publishLast", ()=>(0, _publishLast.publishLast));
parcelHelpers.export(exports, "publishReplay", ()=>(0, _publishReplay.publishReplay));
parcelHelpers.export(exports, "race", ()=>(0, _race.race));
parcelHelpers.export(exports, "raceWith", ()=>(0, _raceWith.raceWith));
parcelHelpers.export(exports, "reduce", ()=>(0, _reduce.reduce));
parcelHelpers.export(exports, "repeat", ()=>(0, _repeat.repeat));
parcelHelpers.export(exports, "repeatWhen", ()=>(0, _repeatWhen.repeatWhen));
parcelHelpers.export(exports, "retry", ()=>(0, _retry.retry));
parcelHelpers.export(exports, "retryWhen", ()=>(0, _retryWhen.retryWhen));
parcelHelpers.export(exports, "refCount", ()=>(0, _refCount.refCount));
parcelHelpers.export(exports, "sample", ()=>(0, _sample.sample));
parcelHelpers.export(exports, "sampleTime", ()=>(0, _sampleTime.sampleTime));
parcelHelpers.export(exports, "scan", ()=>(0, _scan.scan));
parcelHelpers.export(exports, "sequenceEqual", ()=>(0, _sequenceEqual.sequenceEqual));
parcelHelpers.export(exports, "share", ()=>(0, _share.share));
parcelHelpers.export(exports, "shareReplay", ()=>(0, _shareReplay.shareReplay));
parcelHelpers.export(exports, "single", ()=>(0, _single.single));
parcelHelpers.export(exports, "skip", ()=>(0, _skip.skip));
parcelHelpers.export(exports, "skipLast", ()=>(0, _skipLast.skipLast));
parcelHelpers.export(exports, "skipUntil", ()=>(0, _skipUntil.skipUntil));
parcelHelpers.export(exports, "skipWhile", ()=>(0, _skipWhile.skipWhile));
parcelHelpers.export(exports, "startWith", ()=>(0, _startWith.startWith));
parcelHelpers.export(exports, "subscribeOn", ()=>(0, _subscribeOn.subscribeOn));
parcelHelpers.export(exports, "switchAll", ()=>(0, _switchAll.switchAll));
parcelHelpers.export(exports, "switchMap", ()=>(0, _switchMap.switchMap));
parcelHelpers.export(exports, "switchMapTo", ()=>(0, _switchMapTo.switchMapTo));
parcelHelpers.export(exports, "switchScan", ()=>(0, _switchScan.switchScan));
parcelHelpers.export(exports, "take", ()=>(0, _take.take));
parcelHelpers.export(exports, "takeLast", ()=>(0, _takeLast.takeLast));
parcelHelpers.export(exports, "takeUntil", ()=>(0, _takeUntil.takeUntil));
parcelHelpers.export(exports, "takeWhile", ()=>(0, _takeWhile.takeWhile));
parcelHelpers.export(exports, "tap", ()=>(0, _tap.tap));
parcelHelpers.export(exports, "throttle", ()=>(0, _throttle.throttle));
parcelHelpers.export(exports, "throttleTime", ()=>(0, _throttleTime.throttleTime));
parcelHelpers.export(exports, "throwIfEmpty", ()=>(0, _throwIfEmpty.throwIfEmpty));
parcelHelpers.export(exports, "timeInterval", ()=>(0, _timeInterval.timeInterval));
parcelHelpers.export(exports, "timeout", ()=>(0, _timeout.timeout));
parcelHelpers.export(exports, "timeoutWith", ()=>(0, _timeoutWith.timeoutWith));
parcelHelpers.export(exports, "timestamp", ()=>(0, _timestamp.timestamp));
parcelHelpers.export(exports, "toArray", ()=>(0, _toArray.toArray));
parcelHelpers.export(exports, "window", ()=>(0, _window.window));
parcelHelpers.export(exports, "windowCount", ()=>(0, _windowCount.windowCount));
parcelHelpers.export(exports, "windowTime", ()=>(0, _windowTime.windowTime));
parcelHelpers.export(exports, "windowToggle", ()=>(0, _windowToggle.windowToggle));
parcelHelpers.export(exports, "windowWhen", ()=>(0, _windowWhen.windowWhen));
parcelHelpers.export(exports, "withLatestFrom", ()=>(0, _withLatestFrom.withLatestFrom));
parcelHelpers.export(exports, "zip", ()=>(0, _zip.zip));
parcelHelpers.export(exports, "zipAll", ()=>(0, _zipAll.zipAll));
parcelHelpers.export(exports, "zipWith", ()=>(0, _zipWith.zipWith));
var _audit = require("../internal/operators/audit");
var _auditTime = require("../internal/operators/auditTime");
var _buffer = require("../internal/operators/buffer");
var _bufferCount = require("../internal/operators/bufferCount");
var _bufferTime = require("../internal/operators/bufferTime");
var _bufferToggle = require("../internal/operators/bufferToggle");
var _bufferWhen = require("../internal/operators/bufferWhen");
var _catchError = require("../internal/operators/catchError");
var _combineAll = require("../internal/operators/combineAll");
var _combineLatestAll = require("../internal/operators/combineLatestAll");
var _combineLatest = require("../internal/operators/combineLatest");
var _combineLatestWith = require("../internal/operators/combineLatestWith");
var _concat = require("../internal/operators/concat");
var _concatAll = require("../internal/operators/concatAll");
var _concatMap = require("../internal/operators/concatMap");
var _concatMapTo = require("../internal/operators/concatMapTo");
var _concatWith = require("../internal/operators/concatWith");
var _connect = require("../internal/operators/connect");
var _count = require("../internal/operators/count");
var _debounce = require("../internal/operators/debounce");
var _debounceTime = require("../internal/operators/debounceTime");
var _defaultIfEmpty = require("../internal/operators/defaultIfEmpty");
var _delay = require("../internal/operators/delay");
var _delayWhen = require("../internal/operators/delayWhen");
var _dematerialize = require("../internal/operators/dematerialize");
var _distinct = require("../internal/operators/distinct");
var _distinctUntilChanged = require("../internal/operators/distinctUntilChanged");
var _distinctUntilKeyChanged = require("../internal/operators/distinctUntilKeyChanged");
var _elementAt = require("../internal/operators/elementAt");
var _endWith = require("../internal/operators/endWith");
var _every = require("../internal/operators/every");
var _exhaust = require("../internal/operators/exhaust");
var _exhaustAll = require("../internal/operators/exhaustAll");
var _exhaustMap = require("../internal/operators/exhaustMap");
var _expand = require("../internal/operators/expand");
var _filter = require("../internal/operators/filter");
var _finalize = require("../internal/operators/finalize");
var _find = require("../internal/operators/find");
var _findIndex = require("../internal/operators/findIndex");
var _first = require("../internal/operators/first");
var _groupBy = require("../internal/operators/groupBy");
var _ignoreElements = require("../internal/operators/ignoreElements");
var _isEmpty = require("../internal/operators/isEmpty");
var _last = require("../internal/operators/last");
var _map = require("../internal/operators/map");
var _mapTo = require("../internal/operators/mapTo");
var _materialize = require("../internal/operators/materialize");
var _max = require("../internal/operators/max");
var _merge = require("../internal/operators/merge");
var _mergeAll = require("../internal/operators/mergeAll");
var _flatMap = require("../internal/operators/flatMap");
var _mergeMap = require("../internal/operators/mergeMap");
var _mergeMapTo = require("../internal/operators/mergeMapTo");
var _mergeScan = require("../internal/operators/mergeScan");
var _mergeWith = require("../internal/operators/mergeWith");
var _min = require("../internal/operators/min");
var _multicast = require("../internal/operators/multicast");
var _observeOn = require("../internal/operators/observeOn");
var _onErrorResumeNextWith = require("../internal/operators/onErrorResumeNextWith");
var _pairwise = require("../internal/operators/pairwise");
var _partition = require("../internal/operators/partition");
var _pluck = require("../internal/operators/pluck");
var _publish = require("../internal/operators/publish");
var _publishBehavior = require("../internal/operators/publishBehavior");
var _publishLast = require("../internal/operators/publishLast");
var _publishReplay = require("../internal/operators/publishReplay");
var _race = require("../internal/operators/race");
var _raceWith = require("../internal/operators/raceWith");
var _reduce = require("../internal/operators/reduce");
var _repeat = require("../internal/operators/repeat");
var _repeatWhen = require("../internal/operators/repeatWhen");
var _retry = require("../internal/operators/retry");
var _retryWhen = require("../internal/operators/retryWhen");
var _refCount = require("../internal/operators/refCount");
var _sample = require("../internal/operators/sample");
var _sampleTime = require("../internal/operators/sampleTime");
var _scan = require("../internal/operators/scan");
var _sequenceEqual = require("../internal/operators/sequenceEqual");
var _share = require("../internal/operators/share");
var _shareReplay = require("../internal/operators/shareReplay");
var _single = require("../internal/operators/single");
var _skip = require("../internal/operators/skip");
var _skipLast = require("../internal/operators/skipLast");
var _skipUntil = require("../internal/operators/skipUntil");
var _skipWhile = require("../internal/operators/skipWhile");
var _startWith = require("../internal/operators/startWith");
var _subscribeOn = require("../internal/operators/subscribeOn");
var _switchAll = require("../internal/operators/switchAll");
var _switchMap = require("../internal/operators/switchMap");
var _switchMapTo = require("../internal/operators/switchMapTo");
var _switchScan = require("../internal/operators/switchScan");
var _take = require("../internal/operators/take");
var _takeLast = require("../internal/operators/takeLast");
var _takeUntil = require("../internal/operators/takeUntil");
var _takeWhile = require("../internal/operators/takeWhile");
var _tap = require("../internal/operators/tap");
var _throttle = require("../internal/operators/throttle");
var _throttleTime = require("../internal/operators/throttleTime");
var _throwIfEmpty = require("../internal/operators/throwIfEmpty");
var _timeInterval = require("../internal/operators/timeInterval");
var _timeout = require("../internal/operators/timeout");
var _timeoutWith = require("../internal/operators/timeoutWith");
var _timestamp = require("../internal/operators/timestamp");
var _toArray = require("../internal/operators/toArray");
var _window = require("../internal/operators/window");
var _windowCount = require("../internal/operators/windowCount");
var _windowTime = require("../internal/operators/windowTime");
var _windowToggle = require("../internal/operators/windowToggle");
var _windowWhen = require("../internal/operators/windowWhen");
var _withLatestFrom = require("../internal/operators/withLatestFrom");
var _zip = require("../internal/operators/zip");
var _zipAll = require("../internal/operators/zipAll");
var _zipWith = require("../internal/operators/zipWith");

},{"../internal/operators/audit":false,"../internal/operators/auditTime":false,"../internal/operators/buffer":false,"../internal/operators/bufferCount":false,"../internal/operators/bufferTime":false,"../internal/operators/bufferToggle":false,"../internal/operators/bufferWhen":false,"../internal/operators/catchError":false,"../internal/operators/combineAll":false,"../internal/operators/combineLatestAll":false,"../internal/operators/combineLatest":false,"../internal/operators/combineLatestWith":false,"../internal/operators/concat":false,"../internal/operators/concatAll":false,"../internal/operators/concatMap":false,"../internal/operators/concatMapTo":false,"../internal/operators/concatWith":false,"../internal/operators/connect":false,"../internal/operators/count":false,"../internal/operators/debounce":false,"../internal/operators/debounceTime":false,"../internal/operators/defaultIfEmpty":false,"../internal/operators/delay":false,"../internal/operators/delayWhen":false,"../internal/operators/dematerialize":false,"../internal/operators/distinct":false,"../internal/operators/distinctUntilChanged":false,"../internal/operators/distinctUntilKeyChanged":false,"../internal/operators/elementAt":false,"../internal/operators/endWith":false,"../internal/operators/every":false,"../internal/operators/exhaust":false,"../internal/operators/exhaustAll":false,"../internal/operators/exhaustMap":false,"../internal/operators/expand":false,"../internal/operators/filter":false,"../internal/operators/finalize":false,"../internal/operators/find":false,"../internal/operators/findIndex":false,"../internal/operators/first":false,"../internal/operators/groupBy":false,"../internal/operators/ignoreElements":false,"../internal/operators/isEmpty":false,"../internal/operators/last":false,"../internal/operators/map":"25iUP","../internal/operators/mapTo":false,"../internal/operators/materialize":false,"../internal/operators/max":false,"../internal/operators/merge":false,"../internal/operators/mergeAll":false,"../internal/operators/flatMap":false,"../internal/operators/mergeMap":false,"../internal/operators/mergeMapTo":false,"../internal/operators/mergeScan":false,"../internal/operators/mergeWith":false,"../internal/operators/min":false,"../internal/operators/multicast":false,"../internal/operators/observeOn":false,"../internal/operators/onErrorResumeNextWith":false,"../internal/operators/pairwise":false,"../internal/operators/partition":false,"../internal/operators/pluck":false,"../internal/operators/publish":false,"../internal/operators/publishBehavior":false,"../internal/operators/publishLast":false,"../internal/operators/publishReplay":false,"../internal/operators/race":false,"../internal/operators/raceWith":false,"../internal/operators/reduce":false,"../internal/operators/repeat":false,"../internal/operators/repeatWhen":false,"../internal/operators/retry":false,"../internal/operators/retryWhen":false,"../internal/operators/refCount":false,"../internal/operators/sample":false,"../internal/operators/sampleTime":false,"../internal/operators/scan":false,"../internal/operators/sequenceEqual":false,"../internal/operators/share":false,"../internal/operators/shareReplay":false,"../internal/operators/single":false,"../internal/operators/skip":false,"../internal/operators/skipLast":false,"../internal/operators/skipUntil":false,"../internal/operators/skipWhile":false,"../internal/operators/startWith":false,"../internal/operators/subscribeOn":false,"../internal/operators/switchAll":false,"../internal/operators/switchMap":false,"../internal/operators/switchMapTo":false,"../internal/operators/switchScan":false,"../internal/operators/take":false,"../internal/operators/takeLast":false,"../internal/operators/takeUntil":false,"../internal/operators/takeWhile":false,"../internal/operators/tap":false,"../internal/operators/throttle":false,"../internal/operators/throttleTime":false,"../internal/operators/throwIfEmpty":false,"../internal/operators/timeInterval":false,"../internal/operators/timeout":false,"../internal/operators/timeoutWith":false,"../internal/operators/timestamp":false,"../internal/operators/toArray":false,"../internal/operators/window":false,"../internal/operators/windowCount":false,"../internal/operators/windowTime":false,"../internal/operators/windowToggle":false,"../internal/operators/windowWhen":false,"../internal/operators/withLatestFrom":false,"../internal/operators/zip":false,"../internal/operators/zipAll":false,"../internal/operators/zipWith":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"25iUP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "map", ()=>map);
var _lift = require("../util/lift");
var _operatorSubscriber = require("./OperatorSubscriber");
function map(project, thisArg) {
    return (0, _lift.operate)(function(source, subscriber) {
        var index = 0;
        source.subscribe((0, _operatorSubscriber.createOperatorSubscriber)(subscriber, function(value) {
            subscriber.next(project.call(thisArg, value, index++));
        }));
    });
}

},{"../util/lift":"7CiSs","./OperatorSubscriber":"96z9b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7CiSs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasLift", ()=>hasLift);
parcelHelpers.export(exports, "operate", ()=>operate);
var _isFunction = require("./isFunction");
function hasLift(source) {
    return (0, _isFunction.isFunction)(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
    return function(source) {
        if (hasLift(source)) return source.lift(function(liftedSource) {
            try {
                return init(liftedSource, this);
            } catch (err) {
                this.error(err);
            }
        });
        throw new TypeError("Unable to lift unknown Observable type");
    };
}

},{"./isFunction":"dEyyK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dEyyK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isFunction", ()=>isFunction);
function isFunction(value) {
    return typeof value === "function";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"96z9b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createOperatorSubscriber", ()=>createOperatorSubscriber);
parcelHelpers.export(exports, "OperatorSubscriber", ()=>OperatorSubscriber);
var _tslib = require("tslib");
var _subscriber = require("../Subscriber");
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
    (0, _tslib.__extends)(OperatorSubscriber, _super);
    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext ? function(value) {
            try {
                onNext(value);
            } catch (err) {
                destination.error(err);
            }
        } : _super.prototype._next;
        _this._error = onError ? function(err) {
            try {
                onError(err);
            } catch (err) {
                destination.error(err);
            } finally{
                this.unsubscribe();
            }
        } : _super.prototype._error;
        _this._complete = onComplete ? function() {
            try {
                onComplete();
            } catch (err) {
                destination.error(err);
            } finally{
                this.unsubscribe();
            }
        } : _super.prototype._complete;
        return _this;
    }
    OperatorSubscriber.prototype.unsubscribe = function() {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var closed_1 = this.closed;
            _super.prototype.unsubscribe.call(this);
            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 || _a.call(this));
        }
    };
    return OperatorSubscriber;
}((0, _subscriber.Subscriber));

},{"tslib":"8wyHd","../Subscriber":"1VFFQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8wyHd":[function(require,module,exports) {
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__extends", ()=>__extends);
parcelHelpers.export(exports, "__assign", ()=>__assign);
parcelHelpers.export(exports, "__rest", ()=>__rest);
parcelHelpers.export(exports, "__decorate", ()=>__decorate);
parcelHelpers.export(exports, "__param", ()=>__param);
parcelHelpers.export(exports, "__esDecorate", ()=>__esDecorate);
parcelHelpers.export(exports, "__runInitializers", ()=>__runInitializers);
parcelHelpers.export(exports, "__propKey", ()=>__propKey);
parcelHelpers.export(exports, "__setFunctionName", ()=>__setFunctionName);
parcelHelpers.export(exports, "__metadata", ()=>__metadata);
parcelHelpers.export(exports, "__awaiter", ()=>__awaiter);
parcelHelpers.export(exports, "__generator", ()=>__generator);
parcelHelpers.export(exports, "__createBinding", ()=>__createBinding);
parcelHelpers.export(exports, "__exportStar", ()=>__exportStar);
parcelHelpers.export(exports, "__values", ()=>__values);
parcelHelpers.export(exports, "__read", ()=>__read);
/** @deprecated */ parcelHelpers.export(exports, "__spread", ()=>__spread);
/** @deprecated */ parcelHelpers.export(exports, "__spreadArrays", ()=>__spreadArrays);
parcelHelpers.export(exports, "__spreadArray", ()=>__spreadArray);
parcelHelpers.export(exports, "__await", ()=>__await);
parcelHelpers.export(exports, "__asyncGenerator", ()=>__asyncGenerator);
parcelHelpers.export(exports, "__asyncDelegator", ()=>__asyncDelegator);
parcelHelpers.export(exports, "__asyncValues", ()=>__asyncValues);
parcelHelpers.export(exports, "__makeTemplateObject", ()=>__makeTemplateObject);
parcelHelpers.export(exports, "__importStar", ()=>__importStar);
parcelHelpers.export(exports, "__importDefault", ()=>__importDefault);
parcelHelpers.export(exports, "__classPrivateFieldGet", ()=>__classPrivateFieldGet);
parcelHelpers.export(exports, "__classPrivateFieldSet", ()=>__classPrivateFieldSet);
parcelHelpers.export(exports, "__classPrivateFieldIn", ()=>__classPrivateFieldIn);
parcelHelpers.export(exports, "__addDisposableResource", ()=>__addDisposableResource);
parcelHelpers.export(exports, "__disposeResources", ()=>__disposeResources);
parcelHelpers.export(exports, "__rewriteRelativeImportExtension", ()=>__rewriteRelativeImportExtension);
var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
}
function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++)value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    return useValue ? value : void 0;
}
function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", {
        configurable: true,
        value: prefix ? "".concat(prefix, " ", name) : name
    });
}
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function __exportStar(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: false
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) Object.defineProperty(cooked, "raw", {
        value: raw
    });
    else cooked.raw = raw;
    return cooked;
}
var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
var ownKeys = function(o) {
    ownKeys = Object.getOwnPropertyNames || function(o) {
        var ar = [];
        for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
    };
    return ownKeys(o);
};
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
    }
    __setModuleDefault(result, mod);
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) env.stack.push({
        async: true
    });
    return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
    function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
    }
    var r, s = 0;
    function next() {
        while(r = env.stack.pop())try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                });
            } else s |= 1;
        } catch (e) {
            fail(e);
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
    }
    return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
        return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
    return path;
}
exports.default = {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __esDecorate,
    __runInitializers,
    __propKey,
    __setFunctionName,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources,
    __rewriteRelativeImportExtension
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1VFFQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Subscriber", ()=>Subscriber);
parcelHelpers.export(exports, "SafeSubscriber", ()=>SafeSubscriber);
parcelHelpers.export(exports, "EMPTY_OBSERVER", ()=>EMPTY_OBSERVER);
var _tslib = require("tslib");
var _isFunction = require("./util/isFunction");
var _subscription = require("./Subscription");
var _config = require("./config");
var _reportUnhandledError = require("./util/reportUnhandledError");
var _noop = require("./util/noop");
var _notificationFactories = require("./NotificationFactories");
var _timeoutProvider = require("./scheduler/timeoutProvider");
var _errorContext = require("./util/errorContext");
var Subscriber = function(_super) {
    (0, _tslib.__extends)(Subscriber, _super);
    function Subscriber(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
            _this.destination = destination;
            if ((0, _subscription.isSubscription)(destination)) destination.add(_this);
        } else _this.destination = EMPTY_OBSERVER;
        return _this;
    }
    Subscriber.create = function(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
    };
    Subscriber.prototype.next = function(value) {
        if (this.isStopped) handleStoppedNotification((0, _notificationFactories.nextNotification)(value), this);
        else this._next(value);
    };
    Subscriber.prototype.error = function(err) {
        if (this.isStopped) handleStoppedNotification((0, _notificationFactories.errorNotification)(err), this);
        else {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function() {
        if (this.isStopped) handleStoppedNotification((0, _notificationFactories.COMPLETE_NOTIFICATION), this);
        else {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function() {
        if (!this.closed) {
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
            this.destination = null;
        }
    };
    Subscriber.prototype._next = function(value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function(err) {
        try {
            this.destination.error(err);
        } finally{
            this.unsubscribe();
        }
    };
    Subscriber.prototype._complete = function() {
        try {
            this.destination.complete();
        } finally{
            this.unsubscribe();
        }
    };
    return Subscriber;
}((0, _subscription.Subscription));
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
    function ConsumerObserver(partialObserver) {
        this.partialObserver = partialObserver;
    }
    ConsumerObserver.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) try {
            partialObserver.next(value);
        } catch (error) {
            handleUnhandledError(error);
        }
    };
    ConsumerObserver.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) try {
            partialObserver.error(err);
        } catch (error) {
            handleUnhandledError(error);
        }
        else handleUnhandledError(err);
    };
    ConsumerObserver.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) try {
            partialObserver.complete();
        } catch (error) {
            handleUnhandledError(error);
        }
    };
    return ConsumerObserver;
}();
var SafeSubscriber = function(_super) {
    (0, _tslib.__extends)(SafeSubscriber, _super);
    function SafeSubscriber(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if ((0, _isFunction.isFunction)(observerOrNext) || !observerOrNext) partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,
            error: error !== null && error !== void 0 ? error : undefined,
            complete: complete !== null && complete !== void 0 ? complete : undefined
        };
        else {
            var context_1;
            if (_this && (0, _config.config).useDeprecatedNextContext) {
                context_1 = Object.create(observerOrNext);
                context_1.unsubscribe = function() {
                    return _this.unsubscribe();
                };
                partialObserver = {
                    next: observerOrNext.next && bind(observerOrNext.next, context_1),
                    error: observerOrNext.error && bind(observerOrNext.error, context_1),
                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
                };
            } else partialObserver = observerOrNext;
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
    }
    return SafeSubscriber;
}(Subscriber);
function handleUnhandledError(error) {
    if ((0, _config.config).useDeprecatedSynchronousErrorHandling) (0, _errorContext.captureError)(error);
    else (0, _reportUnhandledError.reportUnhandledError)(error);
}
function defaultErrorHandler(err) {
    throw err;
}
function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = (0, _config.config).onStoppedNotification;
    onStoppedNotification && (0, _timeoutProvider.timeoutProvider).setTimeout(function() {
        return onStoppedNotification(notification, subscriber);
    });
}
var EMPTY_OBSERVER = {
    closed: true,
    next: (0, _noop.noop),
    error: defaultErrorHandler,
    complete: (0, _noop.noop)
};

},{"tslib":"8wyHd","./util/isFunction":"dEyyK","./Subscription":"lFyhg","./config":"fX0gC","./util/reportUnhandledError":"aVM3K","./util/noop":"l8uEm","./NotificationFactories":"hwqFj","./scheduler/timeoutProvider":"1FR9J","./util/errorContext":"gU38l","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lFyhg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Subscription", ()=>Subscription);
parcelHelpers.export(exports, "EMPTY_SUBSCRIPTION", ()=>EMPTY_SUBSCRIPTION);
parcelHelpers.export(exports, "isSubscription", ()=>isSubscription);
var _tslib = require("tslib");
var _isFunction = require("./util/isFunction");
var _unsubscriptionError = require("./util/UnsubscriptionError");
var _arrRemove = require("./util/arrRemove");
var Subscription = function() {
    function Subscription(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
    }
    Subscription.prototype.unsubscribe = function() {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
            this.closed = true;
            var _parentage = this._parentage;
            if (_parentage) {
                this._parentage = null;
                if (Array.isArray(_parentage)) try {
                    for(var _parentage_1 = (0, _tslib.__values)(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()){
                        var parent_1 = _parentage_1_1.value;
                        parent_1.remove(this);
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
                else _parentage.remove(this);
            }
            var initialFinalizer = this.initialTeardown;
            if ((0, _isFunction.isFunction)(initialFinalizer)) try {
                initialFinalizer();
            } catch (e) {
                errors = e instanceof (0, _unsubscriptionError.UnsubscriptionError) ? e.errors : [
                    e
                ];
            }
            var _finalizers = this._finalizers;
            if (_finalizers) {
                this._finalizers = null;
                try {
                    for(var _finalizers_1 = (0, _tslib.__values)(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()){
                        var finalizer = _finalizers_1_1.value;
                        try {
                            execFinalizer(finalizer);
                        } catch (err) {
                            errors = errors !== null && errors !== void 0 ? errors : [];
                            if (err instanceof (0, _unsubscriptionError.UnsubscriptionError)) errors = (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], (0, _tslib.__read)(errors)), (0, _tslib.__read)(err.errors));
                            else errors.push(err);
                        }
                    }
                } catch (e_2_1) {
                    e_2 = {
                        error: e_2_1
                    };
                } finally{
                    try {
                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
                    } finally{
                        if (e_2) throw e_2.error;
                    }
                }
            }
            if (errors) throw new (0, _unsubscriptionError.UnsubscriptionError)(errors);
        }
    };
    Subscription.prototype.add = function(teardown) {
        var _a;
        if (teardown && teardown !== this) {
            if (this.closed) execFinalizer(teardown);
            else {
                if (teardown instanceof Subscription) {
                    if (teardown.closed || teardown._hasParent(this)) return;
                    teardown._addParent(this);
                }
                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
            }
        }
    };
    Subscription.prototype._hasParent = function(parent) {
        var _parentage = this._parentage;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription.prototype._addParent = function(parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [
            _parentage,
            parent
        ] : parent;
    };
    Subscription.prototype._removeParent = function(parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) this._parentage = null;
        else if (Array.isArray(_parentage)) (0, _arrRemove.arrRemove)(_parentage, parent);
    };
    Subscription.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && (0, _arrRemove.arrRemove)(_finalizers, teardown);
        if (teardown instanceof Subscription) teardown._removeParent(this);
    };
    Subscription.EMPTY = function() {
        var empty = new Subscription();
        empty.closed = true;
        return empty;
    }();
    return Subscription;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && (0, _isFunction.isFunction)(value.remove) && (0, _isFunction.isFunction)(value.add) && (0, _isFunction.isFunction)(value.unsubscribe);
}
function execFinalizer(finalizer) {
    if ((0, _isFunction.isFunction)(finalizer)) finalizer();
    else finalizer.unsubscribe();
}

},{"tslib":"8wyHd","./util/isFunction":"dEyyK","./util/UnsubscriptionError":"GSF7Z","./util/arrRemove":"dLHeW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"GSF7Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnsubscriptionError", ()=>UnsubscriptionError);
var _createErrorClass = require("./createErrorClass");
var UnsubscriptionError = (0, _createErrorClass.createErrorClass)(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
            return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
    };
});

},{"./createErrorClass":"i1v8Q","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i1v8Q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createErrorClass", ()=>createErrorClass);
function createErrorClass(createImpl) {
    var _super = function(instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dLHeW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arrRemove", ()=>arrRemove);
function arrRemove(arr, item) {
    if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fX0gC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "config", ()=>config);
var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aVM3K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "reportUnhandledError", ()=>reportUnhandledError);
var _config = require("../config");
var _timeoutProvider = require("../scheduler/timeoutProvider");
function reportUnhandledError(err) {
    (0, _timeoutProvider.timeoutProvider).setTimeout(function() {
        var onUnhandledError = (0, _config.config).onUnhandledError;
        if (onUnhandledError) onUnhandledError(err);
        else throw err;
    });
}

},{"../config":"fX0gC","../scheduler/timeoutProvider":"1FR9J","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1FR9J":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "timeoutProvider", ()=>timeoutProvider);
var _tslib = require("tslib");
var timeoutProvider = {
    setTimeout: function(handler, timeout) {
        var args = [];
        for(var _i = 2; _i < arguments.length; _i++)args[_i - 2] = arguments[_i];
        var delegate = timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) return delegate.setTimeout.apply(delegate, (0, _tslib.__spreadArray)([
            handler,
            timeout
        ], (0, _tslib.__read)(args)));
        return setTimeout.apply(void 0, (0, _tslib.__spreadArray)([
            handler,
            timeout
        ], (0, _tslib.__read)(args)));
    },
    clearTimeout: function(handle) {
        var delegate = timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined
};

},{"tslib":"8wyHd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l8uEm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "noop", ()=>noop);
function noop() {}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hwqFj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "COMPLETE_NOTIFICATION", ()=>COMPLETE_NOTIFICATION);
parcelHelpers.export(exports, "errorNotification", ()=>errorNotification);
parcelHelpers.export(exports, "nextNotification", ()=>nextNotification);
parcelHelpers.export(exports, "createNotification", ()=>createNotification);
var COMPLETE_NOTIFICATION = function() {
    return createNotification("C", undefined, undefined);
}();
function errorNotification(error) {
    return createNotification("E", undefined, error);
}
function nextNotification(value) {
    return createNotification("N", value, undefined);
}
function createNotification(kind, value, error) {
    return {
        kind: kind,
        value: value,
        error: error
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gU38l":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "errorContext", ()=>errorContext);
parcelHelpers.export(exports, "captureError", ()=>captureError);
var _config = require("../config");
var context = null;
function errorContext(cb) {
    if ((0, _config.config).useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context;
        if (isRoot) context = {
            errorThrown: false,
            error: null
        };
        cb();
        if (isRoot) {
            var _a = context, errorThrown = _a.errorThrown, error = _a.error;
            context = null;
            if (errorThrown) throw error;
        }
    } else cb();
}
function captureError(err) {
    if ((0, _config.config).useDeprecatedSynchronousErrorHandling && context) {
        context.errorThrown = true;
        context.error = err;
    }
}

},{"../config":"fX0gC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9QQ5s":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "AdminListUpdateType", ()=>AdminListUpdateType);
parcelHelpers.export(exports, "adminListUpdateTypeFromJSON", ()=>adminListUpdateTypeFromJSON);
parcelHelpers.export(exports, "adminListUpdateTypeToJSON", ()=>adminListUpdateTypeToJSON);
parcelHelpers.export(exports, "PermissionUpdateType", ()=>PermissionUpdateType);
parcelHelpers.export(exports, "permissionUpdateTypeFromJSON", ()=>permissionUpdateTypeFromJSON);
parcelHelpers.export(exports, "permissionUpdateTypeToJSON", ()=>permissionUpdateTypeToJSON);
parcelHelpers.export(exports, "PermissionPolicyOption", ()=>PermissionPolicyOption);
parcelHelpers.export(exports, "permissionPolicyOptionFromJSON", ()=>permissionPolicyOptionFromJSON);
parcelHelpers.export(exports, "permissionPolicyOptionToJSON", ()=>permissionPolicyOptionToJSON);
parcelHelpers.export(exports, "SendMessageData", ()=>SendMessageData);
parcelHelpers.export(exports, "SendMessageData_V1", ()=>SendMessageData_V1);
parcelHelpers.export(exports, "AccountAddresses", ()=>AccountAddresses);
parcelHelpers.export(exports, "InstallationIds", ()=>InstallationIds);
parcelHelpers.export(exports, "AddressesOrInstallationIds", ()=>AddressesOrInstallationIds);
parcelHelpers.export(exports, "AddMembersData", ()=>AddMembersData);
parcelHelpers.export(exports, "AddMembersData_V1", ()=>AddMembersData_V1);
parcelHelpers.export(exports, "RemoveMembersData", ()=>RemoveMembersData);
parcelHelpers.export(exports, "RemoveMembersData_V1", ()=>RemoveMembersData_V1);
parcelHelpers.export(exports, "UpdateGroupMembershipData", ()=>UpdateGroupMembershipData);
parcelHelpers.export(exports, "UpdateGroupMembershipData_V1", ()=>UpdateGroupMembershipData_V1);
parcelHelpers.export(exports, "UpdateGroupMembershipData_V1_MembershipUpdatesEntry", ()=>UpdateGroupMembershipData_V1_MembershipUpdatesEntry);
parcelHelpers.export(exports, "UpdateMetadataData", ()=>UpdateMetadataData);
parcelHelpers.export(exports, "UpdateMetadataData_V1", ()=>UpdateMetadataData_V1);
parcelHelpers.export(exports, "UpdateAdminListsData", ()=>UpdateAdminListsData);
parcelHelpers.export(exports, "UpdateAdminListsData_V1", ()=>UpdateAdminListsData_V1);
parcelHelpers.export(exports, "UpdatePermissionData", ()=>UpdatePermissionData);
parcelHelpers.export(exports, "UpdatePermissionData_V1", ()=>UpdatePermissionData_V1);
parcelHelpers.export(exports, "PostCommitAction", ()=>PostCommitAction);
parcelHelpers.export(exports, "PostCommitAction_Installation", ()=>PostCommitAction_Installation);
parcelHelpers.export(exports, "PostCommitAction_SendWelcomes", ()=>PostCommitAction_SendWelcomes);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.mls.database";
var AdminListUpdateType;
(function(AdminListUpdateType) {
    AdminListUpdateType[AdminListUpdateType["ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED"] = 0] = "ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED";
    AdminListUpdateType[AdminListUpdateType["ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN"] = 1] = "ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN";
    AdminListUpdateType[AdminListUpdateType["ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN"] = 2] = "ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN";
    AdminListUpdateType[AdminListUpdateType["ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN"] = 3] = "ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN";
    AdminListUpdateType[AdminListUpdateType["ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN"] = 4] = "ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN";
    AdminListUpdateType[AdminListUpdateType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AdminListUpdateType || (AdminListUpdateType = {}));
function adminListUpdateTypeFromJSON(object) {
    switch(object){
        case 0:
        case "ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED":
            return AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED;
        case 1:
        case "ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN":
            return AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN;
        case 2:
        case "ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN":
            return AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN;
        case 3:
        case "ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN":
            return AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN;
        case 4:
        case "ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN":
            return AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN;
        case -1:
        case "UNRECOGNIZED":
        default:
            return AdminListUpdateType.UNRECOGNIZED;
    }
}
function adminListUpdateTypeToJSON(object) {
    switch(object){
        case AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED:
            return "ADMIN_LIST_UPDATE_TYPE_UNSPECIFIED";
        case AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN:
            return "ADMIN_LIST_UPDATE_TYPE_ADD_ADMIN";
        case AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN:
            return "ADMIN_LIST_UPDATE_TYPE_REMOVE_ADMIN";
        case AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN:
            return "ADMIN_LIST_UPDATE_TYPE_ADD_SUPER_ADMIN";
        case AdminListUpdateType.ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN:
            return "ADMIN_LIST_UPDATE_TYPE_REMOVE_SUPER_ADMIN";
        case AdminListUpdateType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var PermissionUpdateType;
(function(PermissionUpdateType) {
    PermissionUpdateType[PermissionUpdateType["PERMISSION_UPDATE_TYPE_UNSPECIFIED"] = 0] = "PERMISSION_UPDATE_TYPE_UNSPECIFIED";
    PermissionUpdateType[PermissionUpdateType["PERMISSION_UPDATE_TYPE_ADD_MEMBER"] = 1] = "PERMISSION_UPDATE_TYPE_ADD_MEMBER";
    PermissionUpdateType[PermissionUpdateType["PERMISSION_UPDATE_TYPE_REMOVE_MEMBER"] = 2] = "PERMISSION_UPDATE_TYPE_REMOVE_MEMBER";
    PermissionUpdateType[PermissionUpdateType["PERMISSION_UPDATE_TYPE_ADD_ADMIN"] = 3] = "PERMISSION_UPDATE_TYPE_ADD_ADMIN";
    PermissionUpdateType[PermissionUpdateType["PERMISSION_UPDATE_TYPE_REMOVE_ADMIN"] = 4] = "PERMISSION_UPDATE_TYPE_REMOVE_ADMIN";
    PermissionUpdateType[PermissionUpdateType["PERMISSION_UPDATE_TYPE_UPDATE_METADATA"] = 5] = "PERMISSION_UPDATE_TYPE_UPDATE_METADATA";
    PermissionUpdateType[PermissionUpdateType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PermissionUpdateType || (PermissionUpdateType = {}));
function permissionUpdateTypeFromJSON(object) {
    switch(object){
        case 0:
        case "PERMISSION_UPDATE_TYPE_UNSPECIFIED":
            return PermissionUpdateType.PERMISSION_UPDATE_TYPE_UNSPECIFIED;
        case 1:
        case "PERMISSION_UPDATE_TYPE_ADD_MEMBER":
            return PermissionUpdateType.PERMISSION_UPDATE_TYPE_ADD_MEMBER;
        case 2:
        case "PERMISSION_UPDATE_TYPE_REMOVE_MEMBER":
            return PermissionUpdateType.PERMISSION_UPDATE_TYPE_REMOVE_MEMBER;
        case 3:
        case "PERMISSION_UPDATE_TYPE_ADD_ADMIN":
            return PermissionUpdateType.PERMISSION_UPDATE_TYPE_ADD_ADMIN;
        case 4:
        case "PERMISSION_UPDATE_TYPE_REMOVE_ADMIN":
            return PermissionUpdateType.PERMISSION_UPDATE_TYPE_REMOVE_ADMIN;
        case 5:
        case "PERMISSION_UPDATE_TYPE_UPDATE_METADATA":
            return PermissionUpdateType.PERMISSION_UPDATE_TYPE_UPDATE_METADATA;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PermissionUpdateType.UNRECOGNIZED;
    }
}
function permissionUpdateTypeToJSON(object) {
    switch(object){
        case PermissionUpdateType.PERMISSION_UPDATE_TYPE_UNSPECIFIED:
            return "PERMISSION_UPDATE_TYPE_UNSPECIFIED";
        case PermissionUpdateType.PERMISSION_UPDATE_TYPE_ADD_MEMBER:
            return "PERMISSION_UPDATE_TYPE_ADD_MEMBER";
        case PermissionUpdateType.PERMISSION_UPDATE_TYPE_REMOVE_MEMBER:
            return "PERMISSION_UPDATE_TYPE_REMOVE_MEMBER";
        case PermissionUpdateType.PERMISSION_UPDATE_TYPE_ADD_ADMIN:
            return "PERMISSION_UPDATE_TYPE_ADD_ADMIN";
        case PermissionUpdateType.PERMISSION_UPDATE_TYPE_REMOVE_ADMIN:
            return "PERMISSION_UPDATE_TYPE_REMOVE_ADMIN";
        case PermissionUpdateType.PERMISSION_UPDATE_TYPE_UPDATE_METADATA:
            return "PERMISSION_UPDATE_TYPE_UPDATE_METADATA";
        case PermissionUpdateType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var PermissionPolicyOption;
(function(PermissionPolicyOption) {
    PermissionPolicyOption[PermissionPolicyOption["PERMISSION_POLICY_OPTION_UNSPECIFIED"] = 0] = "PERMISSION_POLICY_OPTION_UNSPECIFIED";
    PermissionPolicyOption[PermissionPolicyOption["PERMISSION_POLICY_OPTION_ALLOW"] = 1] = "PERMISSION_POLICY_OPTION_ALLOW";
    PermissionPolicyOption[PermissionPolicyOption["PERMISSION_POLICY_OPTION_DENY"] = 2] = "PERMISSION_POLICY_OPTION_DENY";
    PermissionPolicyOption[PermissionPolicyOption["PERMISSION_POLICY_OPTION_ADMIN_ONLY"] = 3] = "PERMISSION_POLICY_OPTION_ADMIN_ONLY";
    PermissionPolicyOption[PermissionPolicyOption["PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY"] = 4] = "PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY";
    PermissionPolicyOption[PermissionPolicyOption["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PermissionPolicyOption || (PermissionPolicyOption = {}));
function permissionPolicyOptionFromJSON(object) {
    switch(object){
        case 0:
        case "PERMISSION_POLICY_OPTION_UNSPECIFIED":
            return PermissionPolicyOption.PERMISSION_POLICY_OPTION_UNSPECIFIED;
        case 1:
        case "PERMISSION_POLICY_OPTION_ALLOW":
            return PermissionPolicyOption.PERMISSION_POLICY_OPTION_ALLOW;
        case 2:
        case "PERMISSION_POLICY_OPTION_DENY":
            return PermissionPolicyOption.PERMISSION_POLICY_OPTION_DENY;
        case 3:
        case "PERMISSION_POLICY_OPTION_ADMIN_ONLY":
            return PermissionPolicyOption.PERMISSION_POLICY_OPTION_ADMIN_ONLY;
        case 4:
        case "PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY":
            return PermissionPolicyOption.PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY;
        case -1:
        case "UNRECOGNIZED":
        default:
            return PermissionPolicyOption.UNRECOGNIZED;
    }
}
function permissionPolicyOptionToJSON(object) {
    switch(object){
        case PermissionPolicyOption.PERMISSION_POLICY_OPTION_UNSPECIFIED:
            return "PERMISSION_POLICY_OPTION_UNSPECIFIED";
        case PermissionPolicyOption.PERMISSION_POLICY_OPTION_ALLOW:
            return "PERMISSION_POLICY_OPTION_ALLOW";
        case PermissionPolicyOption.PERMISSION_POLICY_OPTION_DENY:
            return "PERMISSION_POLICY_OPTION_DENY";
        case PermissionPolicyOption.PERMISSION_POLICY_OPTION_ADMIN_ONLY:
            return "PERMISSION_POLICY_OPTION_ADMIN_ONLY";
        case PermissionPolicyOption.PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY:
            return "PERMISSION_POLICY_OPTION_SUPER_ADMIN_ONLY";
        case PermissionPolicyOption.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseSendMessageData() {
    return {
        v1: undefined
    };
}
const SendMessageData = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) SendMessageData_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendMessageData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = SendMessageData_V1.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? SendMessageData_V1.fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? SendMessageData_V1.toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSendMessageData();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? SendMessageData_V1.fromPartial(object.v1) : undefined;
        return message;
    }
};
function createBaseSendMessageData_V1() {
    return {
        payloadBytes: new Uint8Array()
    };
}
const SendMessageData_V1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.payloadBytes.length !== 0) writer.uint32(10).bytes(message.payloadBytes);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendMessageData_V1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.payloadBytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            payloadBytes: isSet(object.payloadBytes) ? bytesFromBase64(object.payloadBytes) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.payloadBytes !== undefined && (obj.payloadBytes = base64FromBytes(message.payloadBytes !== undefined ? message.payloadBytes : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseSendMessageData_V1();
        message.payloadBytes = (_a = object.payloadBytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseAccountAddresses() {
    return {
        accountAddresses: []
    };
}
const AccountAddresses = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.accountAddresses)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAccountAddresses();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.accountAddresses.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            accountAddresses: Array.isArray(object === null || object === void 0 ? void 0 : object.accountAddresses) ? object.accountAddresses.map((e)=>String(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.accountAddresses) obj.accountAddresses = message.accountAddresses.map((e)=>e);
        else obj.accountAddresses = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseAccountAddresses();
        message.accountAddresses = ((_a = object.accountAddresses) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
function createBaseInstallationIds() {
    return {
        installationIds: []
    };
}
const InstallationIds = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.installationIds)writer.uint32(10).bytes(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInstallationIds();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.installationIds.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            installationIds: Array.isArray(object === null || object === void 0 ? void 0 : object.installationIds) ? object.installationIds.map((e)=>bytesFromBase64(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.installationIds) obj.installationIds = message.installationIds.map((e)=>base64FromBytes(e !== undefined ? e : new Uint8Array()));
        else obj.installationIds = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseInstallationIds();
        message.installationIds = ((_a = object.installationIds) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
function createBaseAddressesOrInstallationIds() {
    return {
        accountAddresses: undefined,
        installationIds: undefined
    };
}
const AddressesOrInstallationIds = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.accountAddresses !== undefined) AccountAddresses.encode(message.accountAddresses, writer.uint32(10).fork()).ldelim();
        if (message.installationIds !== undefined) InstallationIds.encode(message.installationIds, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddressesOrInstallationIds();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.accountAddresses = AccountAddresses.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.installationIds = InstallationIds.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            accountAddresses: isSet(object.accountAddresses) ? AccountAddresses.fromJSON(object.accountAddresses) : undefined,
            installationIds: isSet(object.installationIds) ? InstallationIds.fromJSON(object.installationIds) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.accountAddresses !== undefined && (obj.accountAddresses = message.accountAddresses ? AccountAddresses.toJSON(message.accountAddresses) : undefined);
        message.installationIds !== undefined && (obj.installationIds = message.installationIds ? InstallationIds.toJSON(message.installationIds) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseAddressesOrInstallationIds();
        message.accountAddresses = object.accountAddresses !== undefined && object.accountAddresses !== null ? AccountAddresses.fromPartial(object.accountAddresses) : undefined;
        message.installationIds = object.installationIds !== undefined && object.installationIds !== null ? InstallationIds.fromPartial(object.installationIds) : undefined;
        return message;
    }
};
function createBaseAddMembersData() {
    return {
        v1: undefined
    };
}
const AddMembersData = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) AddMembersData_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddMembersData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = AddMembersData_V1.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? AddMembersData_V1.fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? AddMembersData_V1.toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseAddMembersData();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? AddMembersData_V1.fromPartial(object.v1) : undefined;
        return message;
    }
};
function createBaseAddMembersData_V1() {
    return {
        addressesOrInstallationIds: undefined
    };
}
const AddMembersData_V1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.addressesOrInstallationIds !== undefined) AddressesOrInstallationIds.encode(message.addressesOrInstallationIds, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddMembersData_V1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.addressesOrInstallationIds = AddressesOrInstallationIds.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            addressesOrInstallationIds: isSet(object.addressesOrInstallationIds) ? AddressesOrInstallationIds.fromJSON(object.addressesOrInstallationIds) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.addressesOrInstallationIds !== undefined && (obj.addressesOrInstallationIds = message.addressesOrInstallationIds ? AddressesOrInstallationIds.toJSON(message.addressesOrInstallationIds) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseAddMembersData_V1();
        message.addressesOrInstallationIds = object.addressesOrInstallationIds !== undefined && object.addressesOrInstallationIds !== null ? AddressesOrInstallationIds.fromPartial(object.addressesOrInstallationIds) : undefined;
        return message;
    }
};
function createBaseRemoveMembersData() {
    return {
        v1: undefined
    };
}
const RemoveMembersData = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) RemoveMembersData_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemoveMembersData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = RemoveMembersData_V1.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? RemoveMembersData_V1.fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? RemoveMembersData_V1.toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRemoveMembersData();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? RemoveMembersData_V1.fromPartial(object.v1) : undefined;
        return message;
    }
};
function createBaseRemoveMembersData_V1() {
    return {
        addressesOrInstallationIds: undefined
    };
}
const RemoveMembersData_V1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.addressesOrInstallationIds !== undefined) AddressesOrInstallationIds.encode(message.addressesOrInstallationIds, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemoveMembersData_V1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.addressesOrInstallationIds = AddressesOrInstallationIds.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            addressesOrInstallationIds: isSet(object.addressesOrInstallationIds) ? AddressesOrInstallationIds.fromJSON(object.addressesOrInstallationIds) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.addressesOrInstallationIds !== undefined && (obj.addressesOrInstallationIds = message.addressesOrInstallationIds ? AddressesOrInstallationIds.toJSON(message.addressesOrInstallationIds) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRemoveMembersData_V1();
        message.addressesOrInstallationIds = object.addressesOrInstallationIds !== undefined && object.addressesOrInstallationIds !== null ? AddressesOrInstallationIds.fromPartial(object.addressesOrInstallationIds) : undefined;
        return message;
    }
};
function createBaseUpdateGroupMembershipData() {
    return {
        v1: undefined
    };
}
const UpdateGroupMembershipData = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) UpdateGroupMembershipData_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateGroupMembershipData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = UpdateGroupMembershipData_V1.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? UpdateGroupMembershipData_V1.fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? UpdateGroupMembershipData_V1.toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseUpdateGroupMembershipData();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? UpdateGroupMembershipData_V1.fromPartial(object.v1) : undefined;
        return message;
    }
};
function createBaseUpdateGroupMembershipData_V1() {
    return {
        membershipUpdates: {},
        removedMembers: [],
        failedInstallations: []
    };
}
const UpdateGroupMembershipData_V1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        Object.entries(message.membershipUpdates).forEach(([key, value])=>{
            UpdateGroupMembershipData_V1_MembershipUpdatesEntry.encode({
                key: key,
                value
            }, writer.uint32(10).fork()).ldelim();
        });
        for (const v of message.removedMembers)writer.uint32(18).string(v);
        for (const v of message.failedInstallations)writer.uint32(26).bytes(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateGroupMembershipData_V1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    const entry1 = UpdateGroupMembershipData_V1_MembershipUpdatesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) message.membershipUpdates[entry1.key] = entry1.value;
                    break;
                case 2:
                    message.removedMembers.push(reader.string());
                    break;
                case 3:
                    message.failedInstallations.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            membershipUpdates: isObject(object.membershipUpdates) ? Object.entries(object.membershipUpdates).reduce((acc, [key, value])=>{
                acc[key] = (0, _longDefault.default).fromValue(value);
                return acc;
            }, {}) : {},
            removedMembers: Array.isArray(object === null || object === void 0 ? void 0 : object.removedMembers) ? object.removedMembers.map((e)=>String(e)) : [],
            failedInstallations: Array.isArray(object === null || object === void 0 ? void 0 : object.failedInstallations) ? object.failedInstallations.map((e)=>bytesFromBase64(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        obj.membershipUpdates = {};
        if (message.membershipUpdates) Object.entries(message.membershipUpdates).forEach(([k, v])=>{
            obj.membershipUpdates[k] = v.toString();
        });
        if (message.removedMembers) obj.removedMembers = message.removedMembers.map((e)=>e);
        else obj.removedMembers = [];
        if (message.failedInstallations) obj.failedInstallations = message.failedInstallations.map((e)=>base64FromBytes(e !== undefined ? e : new Uint8Array()));
        else obj.failedInstallations = [];
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseUpdateGroupMembershipData_V1();
        message.membershipUpdates = Object.entries((_a = object.membershipUpdates) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value])=>{
            if (value !== undefined) acc[key] = (0, _longDefault.default).fromValue(value);
            return acc;
        }, {});
        message.removedMembers = ((_b = object.removedMembers) === null || _b === void 0 ? void 0 : _b.map((e)=>e)) || [];
        message.failedInstallations = ((_c = object.failedInstallations) === null || _c === void 0 ? void 0 : _c.map((e)=>e)) || [];
        return message;
    }
};
function createBaseUpdateGroupMembershipData_V1_MembershipUpdatesEntry() {
    return {
        key: "",
        value: (0, _longDefault.default).UZERO
    };
}
const UpdateGroupMembershipData_V1_MembershipUpdatesEntry = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.key !== "") writer.uint32(10).string(message.key);
        if (!message.value.isZero()) writer.uint32(16).uint64(message.value);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateGroupMembershipData_V1_MembershipUpdatesEntry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? (0, _longDefault.default).fromValue(object.value) : (0, _longDefault.default).UZERO
        };
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = (message.value || (0, _longDefault.default).UZERO).toString());
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseUpdateGroupMembershipData_V1_MembershipUpdatesEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = object.value !== undefined && object.value !== null ? (0, _longDefault.default).fromValue(object.value) : (0, _longDefault.default).UZERO;
        return message;
    }
};
function createBaseUpdateMetadataData() {
    return {
        v1: undefined
    };
}
const UpdateMetadataData = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) UpdateMetadataData_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateMetadataData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = UpdateMetadataData_V1.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? UpdateMetadataData_V1.fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? UpdateMetadataData_V1.toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseUpdateMetadataData();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? UpdateMetadataData_V1.fromPartial(object.v1) : undefined;
        return message;
    }
};
function createBaseUpdateMetadataData_V1() {
    return {
        fieldName: "",
        fieldValue: ""
    };
}
const UpdateMetadataData_V1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.fieldName !== "") writer.uint32(10).string(message.fieldName);
        if (message.fieldValue !== "") writer.uint32(18).string(message.fieldValue);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateMetadataData_V1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.fieldName = reader.string();
                    break;
                case 2:
                    message.fieldValue = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            fieldName: isSet(object.fieldName) ? String(object.fieldName) : "",
            fieldValue: isSet(object.fieldValue) ? String(object.fieldValue) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.fieldName !== undefined && (obj.fieldName = message.fieldName);
        message.fieldValue !== undefined && (obj.fieldValue = message.fieldValue);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseUpdateMetadataData_V1();
        message.fieldName = (_a = object.fieldName) !== null && _a !== void 0 ? _a : "";
        message.fieldValue = (_b = object.fieldValue) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseUpdateAdminListsData() {
    return {
        v1: undefined
    };
}
const UpdateAdminListsData = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) UpdateAdminListsData_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateAdminListsData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = UpdateAdminListsData_V1.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? UpdateAdminListsData_V1.fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? UpdateAdminListsData_V1.toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseUpdateAdminListsData();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? UpdateAdminListsData_V1.fromPartial(object.v1) : undefined;
        return message;
    }
};
function createBaseUpdateAdminListsData_V1() {
    return {
        adminListUpdateType: 0,
        inboxId: ""
    };
}
const UpdateAdminListsData_V1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.adminListUpdateType !== 0) writer.uint32(8).int32(message.adminListUpdateType);
        if (message.inboxId !== "") writer.uint32(18).string(message.inboxId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateAdminListsData_V1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.adminListUpdateType = reader.int32();
                    break;
                case 2:
                    message.inboxId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            adminListUpdateType: isSet(object.adminListUpdateType) ? adminListUpdateTypeFromJSON(object.adminListUpdateType) : 0,
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.adminListUpdateType !== undefined && (obj.adminListUpdateType = adminListUpdateTypeToJSON(message.adminListUpdateType));
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseUpdateAdminListsData_V1();
        message.adminListUpdateType = (_a = object.adminListUpdateType) !== null && _a !== void 0 ? _a : 0;
        message.inboxId = (_b = object.inboxId) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseUpdatePermissionData() {
    return {
        v1: undefined
    };
}
const UpdatePermissionData = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) UpdatePermissionData_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdatePermissionData();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = UpdatePermissionData_V1.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? UpdatePermissionData_V1.fromJSON(object.v1) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? UpdatePermissionData_V1.toJSON(message.v1) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseUpdatePermissionData();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? UpdatePermissionData_V1.fromPartial(object.v1) : undefined;
        return message;
    }
};
function createBaseUpdatePermissionData_V1() {
    return {
        permissionUpdateType: 0,
        permissionPolicyOption: 0,
        metadataFieldName: undefined
    };
}
const UpdatePermissionData_V1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.permissionUpdateType !== 0) writer.uint32(8).int32(message.permissionUpdateType);
        if (message.permissionPolicyOption !== 0) writer.uint32(16).int32(message.permissionPolicyOption);
        if (message.metadataFieldName !== undefined) writer.uint32(26).string(message.metadataFieldName);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdatePermissionData_V1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.permissionUpdateType = reader.int32();
                    break;
                case 2:
                    message.permissionPolicyOption = reader.int32();
                    break;
                case 3:
                    message.metadataFieldName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            permissionUpdateType: isSet(object.permissionUpdateType) ? permissionUpdateTypeFromJSON(object.permissionUpdateType) : 0,
            permissionPolicyOption: isSet(object.permissionPolicyOption) ? permissionPolicyOptionFromJSON(object.permissionPolicyOption) : 0,
            metadataFieldName: isSet(object.metadataFieldName) ? String(object.metadataFieldName) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.permissionUpdateType !== undefined && (obj.permissionUpdateType = permissionUpdateTypeToJSON(message.permissionUpdateType));
        message.permissionPolicyOption !== undefined && (obj.permissionPolicyOption = permissionPolicyOptionToJSON(message.permissionPolicyOption));
        message.metadataFieldName !== undefined && (obj.metadataFieldName = message.metadataFieldName);
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseUpdatePermissionData_V1();
        message.permissionUpdateType = (_a = object.permissionUpdateType) !== null && _a !== void 0 ? _a : 0;
        message.permissionPolicyOption = (_b = object.permissionPolicyOption) !== null && _b !== void 0 ? _b : 0;
        message.metadataFieldName = (_c = object.metadataFieldName) !== null && _c !== void 0 ? _c : undefined;
        return message;
    }
};
function createBasePostCommitAction() {
    return {
        sendWelcomes: undefined
    };
}
const PostCommitAction = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.sendWelcomes !== undefined) PostCommitAction_SendWelcomes.encode(message.sendWelcomes, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostCommitAction();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.sendWelcomes = PostCommitAction_SendWelcomes.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            sendWelcomes: isSet(object.sendWelcomes) ? PostCommitAction_SendWelcomes.fromJSON(object.sendWelcomes) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.sendWelcomes !== undefined && (obj.sendWelcomes = message.sendWelcomes ? PostCommitAction_SendWelcomes.toJSON(message.sendWelcomes) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePostCommitAction();
        message.sendWelcomes = object.sendWelcomes !== undefined && object.sendWelcomes !== null ? PostCommitAction_SendWelcomes.fromPartial(object.sendWelcomes) : undefined;
        return message;
    }
};
function createBasePostCommitAction_Installation() {
    return {
        installationKey: new Uint8Array(),
        hpkePublicKey: new Uint8Array()
    };
}
const PostCommitAction_Installation = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.installationKey.length !== 0) writer.uint32(10).bytes(message.installationKey);
        if (message.hpkePublicKey.length !== 0) writer.uint32(18).bytes(message.hpkePublicKey);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostCommitAction_Installation();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.installationKey = reader.bytes();
                    break;
                case 2:
                    message.hpkePublicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            installationKey: isSet(object.installationKey) ? bytesFromBase64(object.installationKey) : new Uint8Array(),
            hpkePublicKey: isSet(object.hpkePublicKey) ? bytesFromBase64(object.hpkePublicKey) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.installationKey !== undefined && (obj.installationKey = base64FromBytes(message.installationKey !== undefined ? message.installationKey : new Uint8Array()));
        message.hpkePublicKey !== undefined && (obj.hpkePublicKey = base64FromBytes(message.hpkePublicKey !== undefined ? message.hpkePublicKey : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBasePostCommitAction_Installation();
        message.installationKey = (_a = object.installationKey) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.hpkePublicKey = (_b = object.hpkePublicKey) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    }
};
function createBasePostCommitAction_SendWelcomes() {
    return {
        installations: [],
        welcomeMessage: new Uint8Array()
    };
}
const PostCommitAction_SendWelcomes = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.installations)PostCommitAction_Installation.encode(v, writer.uint32(10).fork()).ldelim();
        if (message.welcomeMessage.length !== 0) writer.uint32(18).bytes(message.welcomeMessage);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostCommitAction_SendWelcomes();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.installations.push(PostCommitAction_Installation.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.welcomeMessage = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            installations: Array.isArray(object === null || object === void 0 ? void 0 : object.installations) ? object.installations.map((e)=>PostCommitAction_Installation.fromJSON(e)) : [],
            welcomeMessage: isSet(object.welcomeMessage) ? bytesFromBase64(object.welcomeMessage) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.installations) obj.installations = message.installations.map((e)=>e ? PostCommitAction_Installation.toJSON(e) : undefined);
        else obj.installations = [];
        message.welcomeMessage !== undefined && (obj.welcomeMessage = base64FromBytes(message.welcomeMessage !== undefined ? message.welcomeMessage : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBasePostCommitAction_SendWelcomes();
        message.installations = ((_a = object.installations) === null || _a === void 0 ? void 0 : _a.map((e)=>PostCommitAction_Installation.fromPartial(e))) || [];
        message.welcomeMessage = (_b = object.welcomeMessage) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d2gKr":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "Compression", ()=>Compression);
parcelHelpers.export(exports, "compressionFromJSON", ()=>compressionFromJSON);
parcelHelpers.export(exports, "compressionToJSON", ()=>compressionToJSON);
parcelHelpers.export(exports, "DeviceSyncKind", ()=>DeviceSyncKind);
parcelHelpers.export(exports, "deviceSyncKindFromJSON", ()=>deviceSyncKindFromJSON);
parcelHelpers.export(exports, "deviceSyncKindToJSON", ()=>deviceSyncKindToJSON);
parcelHelpers.export(exports, "ContentTypeId", ()=>ContentTypeId);
parcelHelpers.export(exports, "EncodedContent", ()=>EncodedContent);
parcelHelpers.export(exports, "EncodedContent_ParametersEntry", ()=>EncodedContent_ParametersEntry);
parcelHelpers.export(exports, "PlaintextEnvelope", ()=>PlaintextEnvelope);
parcelHelpers.export(exports, "PlaintextEnvelope_V1", ()=>PlaintextEnvelope_V1);
parcelHelpers.export(exports, "PlaintextEnvelope_V2", ()=>PlaintextEnvelope_V2);
parcelHelpers.export(exports, "DeviceSyncRequest", ()=>DeviceSyncRequest);
parcelHelpers.export(exports, "DeviceSyncReply", ()=>DeviceSyncReply);
parcelHelpers.export(exports, "DeviceSyncKeyType", ()=>DeviceSyncKeyType);
parcelHelpers.export(exports, "UserPreferenceUpdate", ()=>UserPreferenceUpdate);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.mls.message_contents";
var Compression;
(function(Compression) {
    Compression[Compression["COMPRESSION_DEFLATE"] = 0] = "COMPRESSION_DEFLATE";
    Compression[Compression["COMPRESSION_GZIP"] = 1] = "COMPRESSION_GZIP";
    Compression[Compression["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Compression || (Compression = {}));
function compressionFromJSON(object) {
    switch(object){
        case 0:
        case "COMPRESSION_DEFLATE":
            return Compression.COMPRESSION_DEFLATE;
        case 1:
        case "COMPRESSION_GZIP":
            return Compression.COMPRESSION_GZIP;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Compression.UNRECOGNIZED;
    }
}
function compressionToJSON(object) {
    switch(object){
        case Compression.COMPRESSION_DEFLATE:
            return "COMPRESSION_DEFLATE";
        case Compression.COMPRESSION_GZIP:
            return "COMPRESSION_GZIP";
        case Compression.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var DeviceSyncKind;
(function(DeviceSyncKind) {
    DeviceSyncKind[DeviceSyncKind["DEVICE_SYNC_KIND_UNSPECIFIED"] = 0] = "DEVICE_SYNC_KIND_UNSPECIFIED";
    DeviceSyncKind[DeviceSyncKind["DEVICE_SYNC_KIND_MESSAGE_HISTORY"] = 1] = "DEVICE_SYNC_KIND_MESSAGE_HISTORY";
    DeviceSyncKind[DeviceSyncKind["DEVICE_SYNC_KIND_CONSENT"] = 2] = "DEVICE_SYNC_KIND_CONSENT";
    DeviceSyncKind[DeviceSyncKind["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DeviceSyncKind || (DeviceSyncKind = {}));
function deviceSyncKindFromJSON(object) {
    switch(object){
        case 0:
        case "DEVICE_SYNC_KIND_UNSPECIFIED":
            return DeviceSyncKind.DEVICE_SYNC_KIND_UNSPECIFIED;
        case 1:
        case "DEVICE_SYNC_KIND_MESSAGE_HISTORY":
            return DeviceSyncKind.DEVICE_SYNC_KIND_MESSAGE_HISTORY;
        case 2:
        case "DEVICE_SYNC_KIND_CONSENT":
            return DeviceSyncKind.DEVICE_SYNC_KIND_CONSENT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return DeviceSyncKind.UNRECOGNIZED;
    }
}
function deviceSyncKindToJSON(object) {
    switch(object){
        case DeviceSyncKind.DEVICE_SYNC_KIND_UNSPECIFIED:
            return "DEVICE_SYNC_KIND_UNSPECIFIED";
        case DeviceSyncKind.DEVICE_SYNC_KIND_MESSAGE_HISTORY:
            return "DEVICE_SYNC_KIND_MESSAGE_HISTORY";
        case DeviceSyncKind.DEVICE_SYNC_KIND_CONSENT:
            return "DEVICE_SYNC_KIND_CONSENT";
        case DeviceSyncKind.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseContentTypeId() {
    return {
        authorityId: "",
        typeId: "",
        versionMajor: 0,
        versionMinor: 0
    };
}
const ContentTypeId = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.authorityId !== "") writer.uint32(10).string(message.authorityId);
        if (message.typeId !== "") writer.uint32(18).string(message.typeId);
        if (message.versionMajor !== 0) writer.uint32(24).uint32(message.versionMajor);
        if (message.versionMinor !== 0) writer.uint32(32).uint32(message.versionMinor);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContentTypeId();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.authorityId = reader.string();
                    break;
                case 2:
                    message.typeId = reader.string();
                    break;
                case 3:
                    message.versionMajor = reader.uint32();
                    break;
                case 4:
                    message.versionMinor = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            authorityId: isSet(object.authorityId) ? String(object.authorityId) : "",
            typeId: isSet(object.typeId) ? String(object.typeId) : "",
            versionMajor: isSet(object.versionMajor) ? Number(object.versionMajor) : 0,
            versionMinor: isSet(object.versionMinor) ? Number(object.versionMinor) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        message.authorityId !== undefined && (obj.authorityId = message.authorityId);
        message.typeId !== undefined && (obj.typeId = message.typeId);
        message.versionMajor !== undefined && (obj.versionMajor = Math.round(message.versionMajor));
        message.versionMinor !== undefined && (obj.versionMinor = Math.round(message.versionMinor));
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseContentTypeId();
        message.authorityId = (_a = object.authorityId) !== null && _a !== void 0 ? _a : "";
        message.typeId = (_b = object.typeId) !== null && _b !== void 0 ? _b : "";
        message.versionMajor = (_c = object.versionMajor) !== null && _c !== void 0 ? _c : 0;
        message.versionMinor = (_d = object.versionMinor) !== null && _d !== void 0 ? _d : 0;
        return message;
    }
};
function createBaseEncodedContent() {
    return {
        type: undefined,
        parameters: {},
        fallback: undefined,
        compression: undefined,
        content: new Uint8Array()
    };
}
const EncodedContent = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.type !== undefined) ContentTypeId.encode(message.type, writer.uint32(10).fork()).ldelim();
        Object.entries(message.parameters).forEach(([key, value])=>{
            EncodedContent_ParametersEntry.encode({
                key: key,
                value
            }, writer.uint32(18).fork()).ldelim();
        });
        if (message.fallback !== undefined) writer.uint32(26).string(message.fallback);
        if (message.compression !== undefined) writer.uint32(40).int32(message.compression);
        if (message.content.length !== 0) writer.uint32(34).bytes(message.content);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncodedContent();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.type = ContentTypeId.decode(reader, reader.uint32());
                    break;
                case 2:
                    const entry2 = EncodedContent_ParametersEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) message.parameters[entry2.key] = entry2.value;
                    break;
                case 3:
                    message.fallback = reader.string();
                    break;
                case 5:
                    message.compression = reader.int32();
                    break;
                case 4:
                    message.content = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            type: isSet(object.type) ? ContentTypeId.fromJSON(object.type) : undefined,
            parameters: isObject(object.parameters) ? Object.entries(object.parameters).reduce((acc, [key, value])=>{
                acc[key] = String(value);
                return acc;
            }, {}) : {},
            fallback: isSet(object.fallback) ? String(object.fallback) : undefined,
            compression: isSet(object.compression) ? compressionFromJSON(object.compression) : undefined,
            content: isSet(object.content) ? bytesFromBase64(object.content) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.type !== undefined && (obj.type = message.type ? ContentTypeId.toJSON(message.type) : undefined);
        obj.parameters = {};
        if (message.parameters) Object.entries(message.parameters).forEach(([k, v])=>{
            obj.parameters[k] = v;
        });
        message.fallback !== undefined && (obj.fallback = message.fallback);
        message.compression !== undefined && (obj.compression = message.compression !== undefined ? compressionToJSON(message.compression) : undefined);
        message.content !== undefined && (obj.content = base64FromBytes(message.content !== undefined ? message.content : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseEncodedContent();
        message.type = object.type !== undefined && object.type !== null ? ContentTypeId.fromPartial(object.type) : undefined;
        message.parameters = Object.entries((_a = object.parameters) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value])=>{
            if (value !== undefined) acc[key] = String(value);
            return acc;
        }, {});
        message.fallback = (_b = object.fallback) !== null && _b !== void 0 ? _b : undefined;
        message.compression = (_c = object.compression) !== null && _c !== void 0 ? _c : undefined;
        message.content = (_d = object.content) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
    }
};
function createBaseEncodedContent_ParametersEntry() {
    return {
        key: "",
        value: ""
    };
}
const EncodedContent_ParametersEntry = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.key !== "") writer.uint32(10).string(message.key);
        if (message.value !== "") writer.uint32(18).string(message.value);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncodedContent_ParametersEntry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? String(object.value) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseEncodedContent_ParametersEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBasePlaintextEnvelope() {
    return {
        v1: undefined,
        v2: undefined
    };
}
const PlaintextEnvelope = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.v1 !== undefined) PlaintextEnvelope_V1.encode(message.v1, writer.uint32(10).fork()).ldelim();
        if (message.v2 !== undefined) PlaintextEnvelope_V2.encode(message.v2, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaintextEnvelope();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.v1 = PlaintextEnvelope_V1.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.v2 = PlaintextEnvelope_V2.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            v1: isSet(object.v1) ? PlaintextEnvelope_V1.fromJSON(object.v1) : undefined,
            v2: isSet(object.v2) ? PlaintextEnvelope_V2.fromJSON(object.v2) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.v1 !== undefined && (obj.v1 = message.v1 ? PlaintextEnvelope_V1.toJSON(message.v1) : undefined);
        message.v2 !== undefined && (obj.v2 = message.v2 ? PlaintextEnvelope_V2.toJSON(message.v2) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePlaintextEnvelope();
        message.v1 = object.v1 !== undefined && object.v1 !== null ? PlaintextEnvelope_V1.fromPartial(object.v1) : undefined;
        message.v2 = object.v2 !== undefined && object.v2 !== null ? PlaintextEnvelope_V2.fromPartial(object.v2) : undefined;
        return message;
    }
};
function createBasePlaintextEnvelope_V1() {
    return {
        content: new Uint8Array(),
        idempotencyKey: ""
    };
}
const PlaintextEnvelope_V1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.content.length !== 0) writer.uint32(10).bytes(message.content);
        if (message.idempotencyKey !== "") writer.uint32(18).string(message.idempotencyKey);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaintextEnvelope_V1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.content = reader.bytes();
                    break;
                case 2:
                    message.idempotencyKey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            content: isSet(object.content) ? bytesFromBase64(object.content) : new Uint8Array(),
            idempotencyKey: isSet(object.idempotencyKey) ? String(object.idempotencyKey) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.content !== undefined && (obj.content = base64FromBytes(message.content !== undefined ? message.content : new Uint8Array()));
        message.idempotencyKey !== undefined && (obj.idempotencyKey = message.idempotencyKey);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBasePlaintextEnvelope_V1();
        message.content = (_a = object.content) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.idempotencyKey = (_b = object.idempotencyKey) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBasePlaintextEnvelope_V2() {
    return {
        idempotencyKey: "",
        content: undefined,
        deviceSyncRequest: undefined,
        deviceSyncReply: undefined,
        userPreferenceUpdate: undefined
    };
}
const PlaintextEnvelope_V2 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.idempotencyKey !== "") writer.uint32(10).string(message.idempotencyKey);
        if (message.content !== undefined) writer.uint32(18).bytes(message.content);
        if (message.deviceSyncRequest !== undefined) DeviceSyncRequest.encode(message.deviceSyncRequest, writer.uint32(26).fork()).ldelim();
        if (message.deviceSyncReply !== undefined) DeviceSyncReply.encode(message.deviceSyncReply, writer.uint32(34).fork()).ldelim();
        if (message.userPreferenceUpdate !== undefined) UserPreferenceUpdate.encode(message.userPreferenceUpdate, writer.uint32(42).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePlaintextEnvelope_V2();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.idempotencyKey = reader.string();
                    break;
                case 2:
                    message.content = reader.bytes();
                    break;
                case 3:
                    message.deviceSyncRequest = DeviceSyncRequest.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.deviceSyncReply = DeviceSyncReply.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.userPreferenceUpdate = UserPreferenceUpdate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            idempotencyKey: isSet(object.idempotencyKey) ? String(object.idempotencyKey) : "",
            content: isSet(object.content) ? bytesFromBase64(object.content) : undefined,
            deviceSyncRequest: isSet(object.deviceSyncRequest) ? DeviceSyncRequest.fromJSON(object.deviceSyncRequest) : undefined,
            deviceSyncReply: isSet(object.deviceSyncReply) ? DeviceSyncReply.fromJSON(object.deviceSyncReply) : undefined,
            userPreferenceUpdate: isSet(object.userPreferenceUpdate) ? UserPreferenceUpdate.fromJSON(object.userPreferenceUpdate) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.idempotencyKey !== undefined && (obj.idempotencyKey = message.idempotencyKey);
        message.content !== undefined && (obj.content = message.content !== undefined ? base64FromBytes(message.content) : undefined);
        message.deviceSyncRequest !== undefined && (obj.deviceSyncRequest = message.deviceSyncRequest ? DeviceSyncRequest.toJSON(message.deviceSyncRequest) : undefined);
        message.deviceSyncReply !== undefined && (obj.deviceSyncReply = message.deviceSyncReply ? DeviceSyncReply.toJSON(message.deviceSyncReply) : undefined);
        message.userPreferenceUpdate !== undefined && (obj.userPreferenceUpdate = message.userPreferenceUpdate ? UserPreferenceUpdate.toJSON(message.userPreferenceUpdate) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBasePlaintextEnvelope_V2();
        message.idempotencyKey = (_a = object.idempotencyKey) !== null && _a !== void 0 ? _a : "";
        message.content = (_b = object.content) !== null && _b !== void 0 ? _b : undefined;
        message.deviceSyncRequest = object.deviceSyncRequest !== undefined && object.deviceSyncRequest !== null ? DeviceSyncRequest.fromPartial(object.deviceSyncRequest) : undefined;
        message.deviceSyncReply = object.deviceSyncReply !== undefined && object.deviceSyncReply !== null ? DeviceSyncReply.fromPartial(object.deviceSyncReply) : undefined;
        message.userPreferenceUpdate = object.userPreferenceUpdate !== undefined && object.userPreferenceUpdate !== null ? UserPreferenceUpdate.fromPartial(object.userPreferenceUpdate) : undefined;
        return message;
    }
};
function createBaseDeviceSyncRequest() {
    return {
        requestId: "",
        pinCode: "",
        kind: 0
    };
}
const DeviceSyncRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.requestId !== "") writer.uint32(10).string(message.requestId);
        if (message.pinCode !== "") writer.uint32(18).string(message.pinCode);
        if (message.kind !== 0) writer.uint32(24).int32(message.kind);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeviceSyncRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.pinCode = reader.string();
                    break;
                case 3:
                    message.kind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            requestId: isSet(object.requestId) ? String(object.requestId) : "",
            pinCode: isSet(object.pinCode) ? String(object.pinCode) : "",
            kind: isSet(object.kind) ? deviceSyncKindFromJSON(object.kind) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        message.requestId !== undefined && (obj.requestId = message.requestId);
        message.pinCode !== undefined && (obj.pinCode = message.pinCode);
        message.kind !== undefined && (obj.kind = deviceSyncKindToJSON(message.kind));
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseDeviceSyncRequest();
        message.requestId = (_a = object.requestId) !== null && _a !== void 0 ? _a : "";
        message.pinCode = (_b = object.pinCode) !== null && _b !== void 0 ? _b : "";
        message.kind = (_c = object.kind) !== null && _c !== void 0 ? _c : 0;
        return message;
    }
};
function createBaseDeviceSyncReply() {
    return {
        requestId: "",
        url: "",
        encryptionKey: undefined,
        timestampNs: (0, _longDefault.default).UZERO,
        kind: 0
    };
}
const DeviceSyncReply = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.requestId !== "") writer.uint32(10).string(message.requestId);
        if (message.url !== "") writer.uint32(18).string(message.url);
        if (message.encryptionKey !== undefined) DeviceSyncKeyType.encode(message.encryptionKey, writer.uint32(26).fork()).ldelim();
        if (!message.timestampNs.isZero()) writer.uint32(32).uint64(message.timestampNs);
        if (message.kind !== 0) writer.uint32(40).int32(message.kind);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeviceSyncReply();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.url = reader.string();
                    break;
                case 3:
                    message.encryptionKey = DeviceSyncKeyType.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.timestampNs = reader.uint64();
                    break;
                case 5:
                    message.kind = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            requestId: isSet(object.requestId) ? String(object.requestId) : "",
            url: isSet(object.url) ? String(object.url) : "",
            encryptionKey: isSet(object.encryptionKey) ? DeviceSyncKeyType.fromJSON(object.encryptionKey) : undefined,
            timestampNs: isSet(object.timestampNs) ? (0, _longDefault.default).fromValue(object.timestampNs) : (0, _longDefault.default).UZERO,
            kind: isSet(object.kind) ? deviceSyncKindFromJSON(object.kind) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        message.requestId !== undefined && (obj.requestId = message.requestId);
        message.url !== undefined && (obj.url = message.url);
        message.encryptionKey !== undefined && (obj.encryptionKey = message.encryptionKey ? DeviceSyncKeyType.toJSON(message.encryptionKey) : undefined);
        message.timestampNs !== undefined && (obj.timestampNs = (message.timestampNs || (0, _longDefault.default).UZERO).toString());
        message.kind !== undefined && (obj.kind = deviceSyncKindToJSON(message.kind));
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseDeviceSyncReply();
        message.requestId = (_a = object.requestId) !== null && _a !== void 0 ? _a : "";
        message.url = (_b = object.url) !== null && _b !== void 0 ? _b : "";
        message.encryptionKey = object.encryptionKey !== undefined && object.encryptionKey !== null ? DeviceSyncKeyType.fromPartial(object.encryptionKey) : undefined;
        message.timestampNs = object.timestampNs !== undefined && object.timestampNs !== null ? (0, _longDefault.default).fromValue(object.timestampNs) : (0, _longDefault.default).UZERO;
        message.kind = (_c = object.kind) !== null && _c !== void 0 ? _c : 0;
        return message;
    }
};
function createBaseDeviceSyncKeyType() {
    return {
        aes256Gcm: undefined
    };
}
const DeviceSyncKeyType = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.aes256Gcm !== undefined) writer.uint32(10).bytes(message.aes256Gcm);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeviceSyncKeyType();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.aes256Gcm = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            aes256Gcm: isSet(object.aes256Gcm) ? bytesFromBase64(object.aes256Gcm) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.aes256Gcm !== undefined && (obj.aes256Gcm = message.aes256Gcm !== undefined ? base64FromBytes(message.aes256Gcm) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseDeviceSyncKeyType();
        message.aes256Gcm = (_a = object.aes256Gcm) !== null && _a !== void 0 ? _a : undefined;
        return message;
    }
};
function createBaseUserPreferenceUpdate() {
    return {
        contents: []
    };
}
const UserPreferenceUpdate = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.contents)writer.uint32(10).bytes(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserPreferenceUpdate();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.contents.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            contents: Array.isArray(object === null || object === void 0 ? void 0 : object.contents) ? object.contents.map((e)=>bytesFromBase64(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.contents) obj.contents = message.contents.map((e)=>base64FromBytes(e !== undefined ? e : new Uint8Array()));
        else obj.contents = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseUserPreferenceUpdate();
        message.contents = ((_a = object.contents) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2plVM":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "GroupMembership", ()=>GroupMembership);
parcelHelpers.export(exports, "GroupMembership_MembersEntry", ()=>GroupMembership_MembersEntry);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.mls.message_contents";
function createBaseGroupMembership() {
    return {
        members: {},
        failedInstallations: []
    };
}
const GroupMembership = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        Object.entries(message.members).forEach(([key, value])=>{
            GroupMembership_MembersEntry.encode({
                key: key,
                value
            }, writer.uint32(10).fork()).ldelim();
        });
        for (const v of message.failedInstallations)writer.uint32(18).bytes(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMembership();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    const entry1 = GroupMembership_MembersEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) message.members[entry1.key] = entry1.value;
                    break;
                case 2:
                    message.failedInstallations.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            members: isObject(object.members) ? Object.entries(object.members).reduce((acc, [key, value])=>{
                acc[key] = (0, _longDefault.default).fromValue(value);
                return acc;
            }, {}) : {},
            failedInstallations: Array.isArray(object === null || object === void 0 ? void 0 : object.failedInstallations) ? object.failedInstallations.map((e)=>bytesFromBase64(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        obj.members = {};
        if (message.members) Object.entries(message.members).forEach(([k, v])=>{
            obj.members[k] = v.toString();
        });
        if (message.failedInstallations) obj.failedInstallations = message.failedInstallations.map((e)=>base64FromBytes(e !== undefined ? e : new Uint8Array()));
        else obj.failedInstallations = [];
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseGroupMembership();
        message.members = Object.entries((_a = object.members) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value])=>{
            if (value !== undefined) acc[key] = (0, _longDefault.default).fromValue(value);
            return acc;
        }, {});
        message.failedInstallations = ((_b = object.failedInstallations) === null || _b === void 0 ? void 0 : _b.map((e)=>e)) || [];
        return message;
    }
};
function createBaseGroupMembership_MembersEntry() {
    return {
        key: "",
        value: (0, _longDefault.default).UZERO
    };
}
const GroupMembership_MembersEntry = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.key !== "") writer.uint32(10).string(message.key);
        if (!message.value.isZero()) writer.uint32(16).uint64(message.value);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMembership_MembersEntry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? (0, _longDefault.default).fromValue(object.value) : (0, _longDefault.default).UZERO
        };
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = (message.value || (0, _longDefault.default).UZERO).toString());
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGroupMembership_MembersEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = object.value !== undefined && object.value !== null ? (0, _longDefault.default).fromValue(object.value) : (0, _longDefault.default).UZERO;
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"wFUqg":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "ConversationType", ()=>ConversationType);
parcelHelpers.export(exports, "conversationTypeFromJSON", ()=>conversationTypeFromJSON);
parcelHelpers.export(exports, "conversationTypeToJSON", ()=>conversationTypeToJSON);
parcelHelpers.export(exports, "GroupMetadataV1", ()=>GroupMetadataV1);
parcelHelpers.export(exports, "Inbox", ()=>Inbox);
parcelHelpers.export(exports, "DmMembers", ()=>DmMembers);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
const protobufPackage = "xmtp.mls.message_contents";
var ConversationType;
(function(ConversationType) {
    ConversationType[ConversationType["CONVERSATION_TYPE_UNSPECIFIED"] = 0] = "CONVERSATION_TYPE_UNSPECIFIED";
    ConversationType[ConversationType["CONVERSATION_TYPE_GROUP"] = 1] = "CONVERSATION_TYPE_GROUP";
    ConversationType[ConversationType["CONVERSATION_TYPE_DM"] = 2] = "CONVERSATION_TYPE_DM";
    ConversationType[ConversationType["CONVERSATION_TYPE_SYNC"] = 3] = "CONVERSATION_TYPE_SYNC";
    ConversationType[ConversationType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConversationType || (ConversationType = {}));
function conversationTypeFromJSON(object) {
    switch(object){
        case 0:
        case "CONVERSATION_TYPE_UNSPECIFIED":
            return ConversationType.CONVERSATION_TYPE_UNSPECIFIED;
        case 1:
        case "CONVERSATION_TYPE_GROUP":
            return ConversationType.CONVERSATION_TYPE_GROUP;
        case 2:
        case "CONVERSATION_TYPE_DM":
            return ConversationType.CONVERSATION_TYPE_DM;
        case 3:
        case "CONVERSATION_TYPE_SYNC":
            return ConversationType.CONVERSATION_TYPE_SYNC;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ConversationType.UNRECOGNIZED;
    }
}
function conversationTypeToJSON(object) {
    switch(object){
        case ConversationType.CONVERSATION_TYPE_UNSPECIFIED:
            return "CONVERSATION_TYPE_UNSPECIFIED";
        case ConversationType.CONVERSATION_TYPE_GROUP:
            return "CONVERSATION_TYPE_GROUP";
        case ConversationType.CONVERSATION_TYPE_DM:
            return "CONVERSATION_TYPE_DM";
        case ConversationType.CONVERSATION_TYPE_SYNC:
            return "CONVERSATION_TYPE_SYNC";
        case ConversationType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseGroupMetadataV1() {
    return {
        conversationType: 0,
        creatorAccountAddress: "",
        creatorInboxId: "",
        dmMembers: undefined
    };
}
const GroupMetadataV1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.conversationType !== 0) writer.uint32(8).int32(message.conversationType);
        if (message.creatorAccountAddress !== "") writer.uint32(18).string(message.creatorAccountAddress);
        if (message.creatorInboxId !== "") writer.uint32(26).string(message.creatorInboxId);
        if (message.dmMembers !== undefined) DmMembers.encode(message.dmMembers, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMetadataV1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.conversationType = reader.int32();
                    break;
                case 2:
                    message.creatorAccountAddress = reader.string();
                    break;
                case 3:
                    message.creatorInboxId = reader.string();
                    break;
                case 4:
                    message.dmMembers = DmMembers.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            conversationType: isSet(object.conversationType) ? conversationTypeFromJSON(object.conversationType) : 0,
            creatorAccountAddress: isSet(object.creatorAccountAddress) ? String(object.creatorAccountAddress) : "",
            creatorInboxId: isSet(object.creatorInboxId) ? String(object.creatorInboxId) : "",
            dmMembers: isSet(object.dmMembers) ? DmMembers.fromJSON(object.dmMembers) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.conversationType !== undefined && (obj.conversationType = conversationTypeToJSON(message.conversationType));
        message.creatorAccountAddress !== undefined && (obj.creatorAccountAddress = message.creatorAccountAddress);
        message.creatorInboxId !== undefined && (obj.creatorInboxId = message.creatorInboxId);
        message.dmMembers !== undefined && (obj.dmMembers = message.dmMembers ? DmMembers.toJSON(message.dmMembers) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseGroupMetadataV1();
        message.conversationType = (_a = object.conversationType) !== null && _a !== void 0 ? _a : 0;
        message.creatorAccountAddress = (_b = object.creatorAccountAddress) !== null && _b !== void 0 ? _b : "";
        message.creatorInboxId = (_c = object.creatorInboxId) !== null && _c !== void 0 ? _c : "";
        message.dmMembers = object.dmMembers !== undefined && object.dmMembers !== null ? DmMembers.fromPartial(object.dmMembers) : undefined;
        return message;
    }
};
function createBaseInbox() {
    return {
        inboxId: ""
    };
}
const Inbox = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.inboxId !== "") writer.uint32(10).string(message.inboxId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInbox();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.inboxId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseInbox();
        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
function createBaseDmMembers() {
    return {
        dmMemberOne: undefined,
        dmMemberTwo: undefined
    };
}
const DmMembers = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.dmMemberOne !== undefined) Inbox.encode(message.dmMemberOne, writer.uint32(10).fork()).ldelim();
        if (message.dmMemberTwo !== undefined) Inbox.encode(message.dmMemberTwo, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDmMembers();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.dmMemberOne = Inbox.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.dmMemberTwo = Inbox.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            dmMemberOne: isSet(object.dmMemberOne) ? Inbox.fromJSON(object.dmMemberOne) : undefined,
            dmMemberTwo: isSet(object.dmMemberTwo) ? Inbox.fromJSON(object.dmMemberTwo) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.dmMemberOne !== undefined && (obj.dmMemberOne = message.dmMemberOne ? Inbox.toJSON(message.dmMemberOne) : undefined);
        message.dmMemberTwo !== undefined && (obj.dmMemberTwo = message.dmMemberTwo ? Inbox.toJSON(message.dmMemberTwo) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseDmMembers();
        message.dmMemberOne = object.dmMemberOne !== undefined && object.dmMemberOne !== null ? Inbox.fromPartial(object.dmMemberOne) : undefined;
        message.dmMemberTwo = object.dmMemberTwo !== undefined && object.dmMemberTwo !== null ? Inbox.fromPartial(object.dmMemberTwo) : undefined;
        return message;
    }
};
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8NVDI":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "GroupMutableMetadataV1", ()=>GroupMutableMetadataV1);
parcelHelpers.export(exports, "GroupMutableMetadataV1_AttributesEntry", ()=>GroupMutableMetadataV1_AttributesEntry);
parcelHelpers.export(exports, "Inboxes", ()=>Inboxes);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
const protobufPackage = "xmtp.mls.message_contents";
function createBaseGroupMutableMetadataV1() {
    return {
        attributes: {},
        adminList: undefined,
        superAdminList: undefined
    };
}
const GroupMutableMetadataV1 = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        Object.entries(message.attributes).forEach(([key, value])=>{
            GroupMutableMetadataV1_AttributesEntry.encode({
                key: key,
                value
            }, writer.uint32(10).fork()).ldelim();
        });
        if (message.adminList !== undefined) Inboxes.encode(message.adminList, writer.uint32(18).fork()).ldelim();
        if (message.superAdminList !== undefined) Inboxes.encode(message.superAdminList, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMutableMetadataV1();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    const entry1 = GroupMutableMetadataV1_AttributesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) message.attributes[entry1.key] = entry1.value;
                    break;
                case 2:
                    message.adminList = Inboxes.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.superAdminList = Inboxes.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            attributes: isObject(object.attributes) ? Object.entries(object.attributes).reduce((acc, [key, value])=>{
                acc[key] = String(value);
                return acc;
            }, {}) : {},
            adminList: isSet(object.adminList) ? Inboxes.fromJSON(object.adminList) : undefined,
            superAdminList: isSet(object.superAdminList) ? Inboxes.fromJSON(object.superAdminList) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        obj.attributes = {};
        if (message.attributes) Object.entries(message.attributes).forEach(([k, v])=>{
            obj.attributes[k] = v;
        });
        message.adminList !== undefined && (obj.adminList = message.adminList ? Inboxes.toJSON(message.adminList) : undefined);
        message.superAdminList !== undefined && (obj.superAdminList = message.superAdminList ? Inboxes.toJSON(message.superAdminList) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGroupMutableMetadataV1();
        message.attributes = Object.entries((_a = object.attributes) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value])=>{
            if (value !== undefined) acc[key] = String(value);
            return acc;
        }, {});
        message.adminList = object.adminList !== undefined && object.adminList !== null ? Inboxes.fromPartial(object.adminList) : undefined;
        message.superAdminList = object.superAdminList !== undefined && object.superAdminList !== null ? Inboxes.fromPartial(object.superAdminList) : undefined;
        return message;
    }
};
function createBaseGroupMutableMetadataV1_AttributesEntry() {
    return {
        key: "",
        value: ""
    };
}
const GroupMutableMetadataV1_AttributesEntry = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.key !== "") writer.uint32(10).string(message.key);
        if (message.value !== "") writer.uint32(18).string(message.value);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMutableMetadataV1_AttributesEntry();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            key: isSet(object.key) ? String(object.key) : "",
            value: isSet(object.value) ? String(object.value) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key);
        message.value !== undefined && (obj.value = message.value);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseGroupMutableMetadataV1_AttributesEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseInboxes() {
    return {
        inboxIds: []
    };
}
const Inboxes = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.inboxIds)writer.uint32(10).string(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInboxes();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.inboxIds.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            inboxIds: Array.isArray(object === null || object === void 0 ? void 0 : object.inboxIds) ? object.inboxIds.map((e)=>String(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.inboxIds) obj.inboxIds = message.inboxIds.map((e)=>e);
        else obj.inboxIds = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseInboxes();
        message.inboxIds = ((_a = object.inboxIds) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        return message;
    }
};
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dGyFg":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "MembershipChange", ()=>MembershipChange);
parcelHelpers.export(exports, "GroupMembershipChanges", ()=>GroupMembershipChanges);
parcelHelpers.export(exports, "GroupUpdated", ()=>GroupUpdated);
parcelHelpers.export(exports, "GroupUpdated_Inbox", ()=>GroupUpdated_Inbox);
parcelHelpers.export(exports, "GroupUpdated_MetadataFieldChange", ()=>GroupUpdated_MetadataFieldChange);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.mls.message_contents";
function createBaseMembershipChange() {
    return {
        installationIds: [],
        accountAddress: "",
        initiatedByAccountAddress: ""
    };
}
const MembershipChange = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.installationIds)writer.uint32(10).bytes(v);
        if (message.accountAddress !== "") writer.uint32(18).string(message.accountAddress);
        if (message.initiatedByAccountAddress !== "") writer.uint32(26).string(message.initiatedByAccountAddress);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMembershipChange();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.installationIds.push(reader.bytes());
                    break;
                case 2:
                    message.accountAddress = reader.string();
                    break;
                case 3:
                    message.initiatedByAccountAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            installationIds: Array.isArray(object === null || object === void 0 ? void 0 : object.installationIds) ? object.installationIds.map((e)=>bytesFromBase64(e)) : [],
            accountAddress: isSet(object.accountAddress) ? String(object.accountAddress) : "",
            initiatedByAccountAddress: isSet(object.initiatedByAccountAddress) ? String(object.initiatedByAccountAddress) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.installationIds) obj.installationIds = message.installationIds.map((e)=>base64FromBytes(e !== undefined ? e : new Uint8Array()));
        else obj.installationIds = [];
        message.accountAddress !== undefined && (obj.accountAddress = message.accountAddress);
        message.initiatedByAccountAddress !== undefined && (obj.initiatedByAccountAddress = message.initiatedByAccountAddress);
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseMembershipChange();
        message.installationIds = ((_a = object.installationIds) === null || _a === void 0 ? void 0 : _a.map((e)=>e)) || [];
        message.accountAddress = (_b = object.accountAddress) !== null && _b !== void 0 ? _b : "";
        message.initiatedByAccountAddress = (_c = object.initiatedByAccountAddress) !== null && _c !== void 0 ? _c : "";
        return message;
    }
};
function createBaseGroupMembershipChanges() {
    return {
        membersAdded: [],
        membersRemoved: [],
        installationsAdded: [],
        installationsRemoved: []
    };
}
const GroupMembershipChanges = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.membersAdded)MembershipChange.encode(v, writer.uint32(10).fork()).ldelim();
        for (const v of message.membersRemoved)MembershipChange.encode(v, writer.uint32(18).fork()).ldelim();
        for (const v of message.installationsAdded)MembershipChange.encode(v, writer.uint32(26).fork()).ldelim();
        for (const v of message.installationsRemoved)MembershipChange.encode(v, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMembershipChanges();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.membersAdded.push(MembershipChange.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.membersRemoved.push(MembershipChange.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.installationsAdded.push(MembershipChange.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.installationsRemoved.push(MembershipChange.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            membersAdded: Array.isArray(object === null || object === void 0 ? void 0 : object.membersAdded) ? object.membersAdded.map((e)=>MembershipChange.fromJSON(e)) : [],
            membersRemoved: Array.isArray(object === null || object === void 0 ? void 0 : object.membersRemoved) ? object.membersRemoved.map((e)=>MembershipChange.fromJSON(e)) : [],
            installationsAdded: Array.isArray(object === null || object === void 0 ? void 0 : object.installationsAdded) ? object.installationsAdded.map((e)=>MembershipChange.fromJSON(e)) : [],
            installationsRemoved: Array.isArray(object === null || object === void 0 ? void 0 : object.installationsRemoved) ? object.installationsRemoved.map((e)=>MembershipChange.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.membersAdded) obj.membersAdded = message.membersAdded.map((e)=>e ? MembershipChange.toJSON(e) : undefined);
        else obj.membersAdded = [];
        if (message.membersRemoved) obj.membersRemoved = message.membersRemoved.map((e)=>e ? MembershipChange.toJSON(e) : undefined);
        else obj.membersRemoved = [];
        if (message.installationsAdded) obj.installationsAdded = message.installationsAdded.map((e)=>e ? MembershipChange.toJSON(e) : undefined);
        else obj.installationsAdded = [];
        if (message.installationsRemoved) obj.installationsRemoved = message.installationsRemoved.map((e)=>e ? MembershipChange.toJSON(e) : undefined);
        else obj.installationsRemoved = [];
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseGroupMembershipChanges();
        message.membersAdded = ((_a = object.membersAdded) === null || _a === void 0 ? void 0 : _a.map((e)=>MembershipChange.fromPartial(e))) || [];
        message.membersRemoved = ((_b = object.membersRemoved) === null || _b === void 0 ? void 0 : _b.map((e)=>MembershipChange.fromPartial(e))) || [];
        message.installationsAdded = ((_c = object.installationsAdded) === null || _c === void 0 ? void 0 : _c.map((e)=>MembershipChange.fromPartial(e))) || [];
        message.installationsRemoved = ((_d = object.installationsRemoved) === null || _d === void 0 ? void 0 : _d.map((e)=>MembershipChange.fromPartial(e))) || [];
        return message;
    }
};
function createBaseGroupUpdated() {
    return {
        initiatedByInboxId: "",
        addedInboxes: [],
        removedInboxes: [],
        metadataFieldChanges: []
    };
}
const GroupUpdated = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.initiatedByInboxId !== "") writer.uint32(10).string(message.initiatedByInboxId);
        for (const v of message.addedInboxes)GroupUpdated_Inbox.encode(v, writer.uint32(18).fork()).ldelim();
        for (const v of message.removedInboxes)GroupUpdated_Inbox.encode(v, writer.uint32(26).fork()).ldelim();
        for (const v of message.metadataFieldChanges)GroupUpdated_MetadataFieldChange.encode(v, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupUpdated();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.initiatedByInboxId = reader.string();
                    break;
                case 2:
                    message.addedInboxes.push(GroupUpdated_Inbox.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.removedInboxes.push(GroupUpdated_Inbox.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.metadataFieldChanges.push(GroupUpdated_MetadataFieldChange.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            initiatedByInboxId: isSet(object.initiatedByInboxId) ? String(object.initiatedByInboxId) : "",
            addedInboxes: Array.isArray(object === null || object === void 0 ? void 0 : object.addedInboxes) ? object.addedInboxes.map((e)=>GroupUpdated_Inbox.fromJSON(e)) : [],
            removedInboxes: Array.isArray(object === null || object === void 0 ? void 0 : object.removedInboxes) ? object.removedInboxes.map((e)=>GroupUpdated_Inbox.fromJSON(e)) : [],
            metadataFieldChanges: Array.isArray(object === null || object === void 0 ? void 0 : object.metadataFieldChanges) ? object.metadataFieldChanges.map((e)=>GroupUpdated_MetadataFieldChange.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        message.initiatedByInboxId !== undefined && (obj.initiatedByInboxId = message.initiatedByInboxId);
        if (message.addedInboxes) obj.addedInboxes = message.addedInboxes.map((e)=>e ? GroupUpdated_Inbox.toJSON(e) : undefined);
        else obj.addedInboxes = [];
        if (message.removedInboxes) obj.removedInboxes = message.removedInboxes.map((e)=>e ? GroupUpdated_Inbox.toJSON(e) : undefined);
        else obj.removedInboxes = [];
        if (message.metadataFieldChanges) obj.metadataFieldChanges = message.metadataFieldChanges.map((e)=>e ? GroupUpdated_MetadataFieldChange.toJSON(e) : undefined);
        else obj.metadataFieldChanges = [];
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseGroupUpdated();
        message.initiatedByInboxId = (_a = object.initiatedByInboxId) !== null && _a !== void 0 ? _a : "";
        message.addedInboxes = ((_b = object.addedInboxes) === null || _b === void 0 ? void 0 : _b.map((e)=>GroupUpdated_Inbox.fromPartial(e))) || [];
        message.removedInboxes = ((_c = object.removedInboxes) === null || _c === void 0 ? void 0 : _c.map((e)=>GroupUpdated_Inbox.fromPartial(e))) || [];
        message.metadataFieldChanges = ((_d = object.metadataFieldChanges) === null || _d === void 0 ? void 0 : _d.map((e)=>GroupUpdated_MetadataFieldChange.fromPartial(e))) || [];
        return message;
    }
};
function createBaseGroupUpdated_Inbox() {
    return {
        inboxId: ""
    };
}
const GroupUpdated_Inbox = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.inboxId !== "") writer.uint32(10).string(message.inboxId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupUpdated_Inbox();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.inboxId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGroupUpdated_Inbox();
        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
function createBaseGroupUpdated_MetadataFieldChange() {
    return {
        fieldName: "",
        oldValue: undefined,
        newValue: undefined
    };
}
const GroupUpdated_MetadataFieldChange = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.fieldName !== "") writer.uint32(10).string(message.fieldName);
        if (message.oldValue !== undefined) writer.uint32(18).string(message.oldValue);
        if (message.newValue !== undefined) writer.uint32(26).string(message.newValue);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupUpdated_MetadataFieldChange();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.fieldName = reader.string();
                    break;
                case 2:
                    message.oldValue = reader.string();
                    break;
                case 3:
                    message.newValue = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            fieldName: isSet(object.fieldName) ? String(object.fieldName) : "",
            oldValue: isSet(object.oldValue) ? String(object.oldValue) : undefined,
            newValue: isSet(object.newValue) ? String(object.newValue) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.fieldName !== undefined && (obj.fieldName = message.fieldName);
        message.oldValue !== undefined && (obj.oldValue = message.oldValue);
        message.newValue !== undefined && (obj.newValue = message.newValue);
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseGroupUpdated_MetadataFieldChange();
        message.fieldName = (_a = object.fieldName) !== null && _a !== void 0 ? _a : "";
        message.oldValue = (_b = object.oldValue) !== null && _b !== void 0 ? _b : undefined;
        message.newValue = (_c = object.newValue) !== null && _c !== void 0 ? _c : undefined;
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2YLwu":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "ValidateInboxIdKeyPackagesRequest", ()=>ValidateInboxIdKeyPackagesRequest);
parcelHelpers.export(exports, "ValidateInboxIdKeyPackagesRequest_KeyPackage", ()=>ValidateInboxIdKeyPackagesRequest_KeyPackage);
parcelHelpers.export(exports, "ValidateInboxIdKeyPackagesResponse", ()=>ValidateInboxIdKeyPackagesResponse);
parcelHelpers.export(exports, "ValidateInboxIdKeyPackagesResponse_Response", ()=>ValidateInboxIdKeyPackagesResponse_Response);
parcelHelpers.export(exports, "ValidateKeyPackagesRequest", ()=>ValidateKeyPackagesRequest);
parcelHelpers.export(exports, "ValidateKeyPackagesRequest_KeyPackage", ()=>ValidateKeyPackagesRequest_KeyPackage);
parcelHelpers.export(exports, "ValidateKeyPackagesResponse", ()=>ValidateKeyPackagesResponse);
parcelHelpers.export(exports, "ValidateKeyPackagesResponse_ValidationResponse", ()=>ValidateKeyPackagesResponse_ValidationResponse);
parcelHelpers.export(exports, "ValidateGroupMessagesRequest", ()=>ValidateGroupMessagesRequest);
parcelHelpers.export(exports, "ValidateGroupMessagesRequest_GroupMessage", ()=>ValidateGroupMessagesRequest_GroupMessage);
parcelHelpers.export(exports, "ValidateGroupMessagesResponse", ()=>ValidateGroupMessagesResponse);
parcelHelpers.export(exports, "ValidateGroupMessagesResponse_ValidationResponse", ()=>ValidateGroupMessagesResponse_ValidationResponse);
parcelHelpers.export(exports, "GetAssociationStateRequest", ()=>GetAssociationStateRequest);
parcelHelpers.export(exports, "GetAssociationStateResponse", ()=>GetAssociationStateResponse);
parcelHelpers.export(exports, "ValidationApiClientImpl", ()=>ValidationApiClientImpl);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _credentialPb = require("../../identity/credential.pb");
var _associationPb = require("../../identity/associations/association.pb");
var _identityPb = require("../../identity/api/v1/identity.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.mls_validation.v1";
function createBaseValidateInboxIdKeyPackagesRequest() {
    return {
        keyPackages: []
    };
}
const ValidateInboxIdKeyPackagesRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.keyPackages)ValidateInboxIdKeyPackagesRequest_KeyPackage.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidateInboxIdKeyPackagesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyPackages.push(ValidateInboxIdKeyPackagesRequest_KeyPackage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            keyPackages: Array.isArray(object === null || object === void 0 ? void 0 : object.keyPackages) ? object.keyPackages.map((e)=>ValidateInboxIdKeyPackagesRequest_KeyPackage.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.keyPackages) obj.keyPackages = message.keyPackages.map((e)=>e ? ValidateInboxIdKeyPackagesRequest_KeyPackage.toJSON(e) : undefined);
        else obj.keyPackages = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseValidateInboxIdKeyPackagesRequest();
        message.keyPackages = ((_a = object.keyPackages) === null || _a === void 0 ? void 0 : _a.map((e)=>ValidateInboxIdKeyPackagesRequest_KeyPackage.fromPartial(e))) || [];
        return message;
    }
};
function createBaseValidateInboxIdKeyPackagesRequest_KeyPackage() {
    return {
        keyPackageBytesTlsSerialized: new Uint8Array(),
        isInboxIdCredential: false
    };
}
const ValidateInboxIdKeyPackagesRequest_KeyPackage = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.keyPackageBytesTlsSerialized.length !== 0) writer.uint32(10).bytes(message.keyPackageBytesTlsSerialized);
        if (message.isInboxIdCredential === true) writer.uint32(16).bool(message.isInboxIdCredential);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidateInboxIdKeyPackagesRequest_KeyPackage();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyPackageBytesTlsSerialized = reader.bytes();
                    break;
                case 2:
                    message.isInboxIdCredential = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            keyPackageBytesTlsSerialized: isSet(object.keyPackageBytesTlsSerialized) ? bytesFromBase64(object.keyPackageBytesTlsSerialized) : new Uint8Array(),
            isInboxIdCredential: isSet(object.isInboxIdCredential) ? Boolean(object.isInboxIdCredential) : false
        };
    },
    toJSON (message) {
        const obj = {};
        message.keyPackageBytesTlsSerialized !== undefined && (obj.keyPackageBytesTlsSerialized = base64FromBytes(message.keyPackageBytesTlsSerialized !== undefined ? message.keyPackageBytesTlsSerialized : new Uint8Array()));
        message.isInboxIdCredential !== undefined && (obj.isInboxIdCredential = message.isInboxIdCredential);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseValidateInboxIdKeyPackagesRequest_KeyPackage();
        message.keyPackageBytesTlsSerialized = (_a = object.keyPackageBytesTlsSerialized) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.isInboxIdCredential = (_b = object.isInboxIdCredential) !== null && _b !== void 0 ? _b : false;
        return message;
    }
};
function createBaseValidateInboxIdKeyPackagesResponse() {
    return {
        responses: []
    };
}
const ValidateInboxIdKeyPackagesResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.responses)ValidateInboxIdKeyPackagesResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidateInboxIdKeyPackagesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.responses.push(ValidateInboxIdKeyPackagesResponse_Response.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses) ? object.responses.map((e)=>ValidateInboxIdKeyPackagesResponse_Response.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.responses) obj.responses = message.responses.map((e)=>e ? ValidateInboxIdKeyPackagesResponse_Response.toJSON(e) : undefined);
        else obj.responses = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseValidateInboxIdKeyPackagesResponse();
        message.responses = ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e)=>ValidateInboxIdKeyPackagesResponse_Response.fromPartial(e))) || [];
        return message;
    }
};
function createBaseValidateInboxIdKeyPackagesResponse_Response() {
    return {
        isOk: false,
        errorMessage: "",
        credential: undefined,
        installationPublicKey: new Uint8Array(),
        expiration: (0, _longDefault.default).UZERO
    };
}
const ValidateInboxIdKeyPackagesResponse_Response = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.isOk === true) writer.uint32(8).bool(message.isOk);
        if (message.errorMessage !== "") writer.uint32(18).string(message.errorMessage);
        if (message.credential !== undefined) (0, _credentialPb.MlsCredential).encode(message.credential, writer.uint32(26).fork()).ldelim();
        if (message.installationPublicKey.length !== 0) writer.uint32(34).bytes(message.installationPublicKey);
        if (!message.expiration.isZero()) writer.uint32(40).uint64(message.expiration);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidateInboxIdKeyPackagesResponse_Response();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.isOk = reader.bool();
                    break;
                case 2:
                    message.errorMessage = reader.string();
                    break;
                case 3:
                    message.credential = (0, _credentialPb.MlsCredential).decode(reader, reader.uint32());
                    break;
                case 4:
                    message.installationPublicKey = reader.bytes();
                    break;
                case 5:
                    message.expiration = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            isOk: isSet(object.isOk) ? Boolean(object.isOk) : false,
            errorMessage: isSet(object.errorMessage) ? String(object.errorMessage) : "",
            credential: isSet(object.credential) ? (0, _credentialPb.MlsCredential).fromJSON(object.credential) : undefined,
            installationPublicKey: isSet(object.installationPublicKey) ? bytesFromBase64(object.installationPublicKey) : new Uint8Array(),
            expiration: isSet(object.expiration) ? (0, _longDefault.default).fromValue(object.expiration) : (0, _longDefault.default).UZERO
        };
    },
    toJSON (message) {
        const obj = {};
        message.isOk !== undefined && (obj.isOk = message.isOk);
        message.errorMessage !== undefined && (obj.errorMessage = message.errorMessage);
        message.credential !== undefined && (obj.credential = message.credential ? (0, _credentialPb.MlsCredential).toJSON(message.credential) : undefined);
        message.installationPublicKey !== undefined && (obj.installationPublicKey = base64FromBytes(message.installationPublicKey !== undefined ? message.installationPublicKey : new Uint8Array()));
        message.expiration !== undefined && (obj.expiration = (message.expiration || (0, _longDefault.default).UZERO).toString());
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseValidateInboxIdKeyPackagesResponse_Response();
        message.isOk = (_a = object.isOk) !== null && _a !== void 0 ? _a : false;
        message.errorMessage = (_b = object.errorMessage) !== null && _b !== void 0 ? _b : "";
        message.credential = object.credential !== undefined && object.credential !== null ? (0, _credentialPb.MlsCredential).fromPartial(object.credential) : undefined;
        message.installationPublicKey = (_c = object.installationPublicKey) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.expiration = object.expiration !== undefined && object.expiration !== null ? (0, _longDefault.default).fromValue(object.expiration) : (0, _longDefault.default).UZERO;
        return message;
    }
};
function createBaseValidateKeyPackagesRequest() {
    return {
        keyPackages: []
    };
}
const ValidateKeyPackagesRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.keyPackages)ValidateKeyPackagesRequest_KeyPackage.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidateKeyPackagesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyPackages.push(ValidateKeyPackagesRequest_KeyPackage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            keyPackages: Array.isArray(object === null || object === void 0 ? void 0 : object.keyPackages) ? object.keyPackages.map((e)=>ValidateKeyPackagesRequest_KeyPackage.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.keyPackages) obj.keyPackages = message.keyPackages.map((e)=>e ? ValidateKeyPackagesRequest_KeyPackage.toJSON(e) : undefined);
        else obj.keyPackages = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseValidateKeyPackagesRequest();
        message.keyPackages = ((_a = object.keyPackages) === null || _a === void 0 ? void 0 : _a.map((e)=>ValidateKeyPackagesRequest_KeyPackage.fromPartial(e))) || [];
        return message;
    }
};
function createBaseValidateKeyPackagesRequest_KeyPackage() {
    return {
        keyPackageBytesTlsSerialized: new Uint8Array(),
        isInboxIdCredential: false
    };
}
const ValidateKeyPackagesRequest_KeyPackage = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.keyPackageBytesTlsSerialized.length !== 0) writer.uint32(10).bytes(message.keyPackageBytesTlsSerialized);
        if (message.isInboxIdCredential === true) writer.uint32(16).bool(message.isInboxIdCredential);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidateKeyPackagesRequest_KeyPackage();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.keyPackageBytesTlsSerialized = reader.bytes();
                    break;
                case 2:
                    message.isInboxIdCredential = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            keyPackageBytesTlsSerialized: isSet(object.keyPackageBytesTlsSerialized) ? bytesFromBase64(object.keyPackageBytesTlsSerialized) : new Uint8Array(),
            isInboxIdCredential: isSet(object.isInboxIdCredential) ? Boolean(object.isInboxIdCredential) : false
        };
    },
    toJSON (message) {
        const obj = {};
        message.keyPackageBytesTlsSerialized !== undefined && (obj.keyPackageBytesTlsSerialized = base64FromBytes(message.keyPackageBytesTlsSerialized !== undefined ? message.keyPackageBytesTlsSerialized : new Uint8Array()));
        message.isInboxIdCredential !== undefined && (obj.isInboxIdCredential = message.isInboxIdCredential);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseValidateKeyPackagesRequest_KeyPackage();
        message.keyPackageBytesTlsSerialized = (_a = object.keyPackageBytesTlsSerialized) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.isInboxIdCredential = (_b = object.isInboxIdCredential) !== null && _b !== void 0 ? _b : false;
        return message;
    }
};
function createBaseValidateKeyPackagesResponse() {
    return {
        responses: []
    };
}
const ValidateKeyPackagesResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.responses)ValidateKeyPackagesResponse_ValidationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidateKeyPackagesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.responses.push(ValidateKeyPackagesResponse_ValidationResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses) ? object.responses.map((e)=>ValidateKeyPackagesResponse_ValidationResponse.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.responses) obj.responses = message.responses.map((e)=>e ? ValidateKeyPackagesResponse_ValidationResponse.toJSON(e) : undefined);
        else obj.responses = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseValidateKeyPackagesResponse();
        message.responses = ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e)=>ValidateKeyPackagesResponse_ValidationResponse.fromPartial(e))) || [];
        return message;
    }
};
function createBaseValidateKeyPackagesResponse_ValidationResponse() {
    return {
        isOk: false,
        errorMessage: "",
        installationId: new Uint8Array(),
        accountAddress: "",
        credentialIdentityBytes: new Uint8Array(),
        expiration: (0, _longDefault.default).UZERO
    };
}
const ValidateKeyPackagesResponse_ValidationResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.isOk === true) writer.uint32(8).bool(message.isOk);
        if (message.errorMessage !== "") writer.uint32(18).string(message.errorMessage);
        if (message.installationId.length !== 0) writer.uint32(26).bytes(message.installationId);
        if (message.accountAddress !== "") writer.uint32(34).string(message.accountAddress);
        if (message.credentialIdentityBytes.length !== 0) writer.uint32(42).bytes(message.credentialIdentityBytes);
        if (!message.expiration.isZero()) writer.uint32(48).uint64(message.expiration);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidateKeyPackagesResponse_ValidationResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.isOk = reader.bool();
                    break;
                case 2:
                    message.errorMessage = reader.string();
                    break;
                case 3:
                    message.installationId = reader.bytes();
                    break;
                case 4:
                    message.accountAddress = reader.string();
                    break;
                case 5:
                    message.credentialIdentityBytes = reader.bytes();
                    break;
                case 6:
                    message.expiration = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            isOk: isSet(object.isOk) ? Boolean(object.isOk) : false,
            errorMessage: isSet(object.errorMessage) ? String(object.errorMessage) : "",
            installationId: isSet(object.installationId) ? bytesFromBase64(object.installationId) : new Uint8Array(),
            accountAddress: isSet(object.accountAddress) ? String(object.accountAddress) : "",
            credentialIdentityBytes: isSet(object.credentialIdentityBytes) ? bytesFromBase64(object.credentialIdentityBytes) : new Uint8Array(),
            expiration: isSet(object.expiration) ? (0, _longDefault.default).fromValue(object.expiration) : (0, _longDefault.default).UZERO
        };
    },
    toJSON (message) {
        const obj = {};
        message.isOk !== undefined && (obj.isOk = message.isOk);
        message.errorMessage !== undefined && (obj.errorMessage = message.errorMessage);
        message.installationId !== undefined && (obj.installationId = base64FromBytes(message.installationId !== undefined ? message.installationId : new Uint8Array()));
        message.accountAddress !== undefined && (obj.accountAddress = message.accountAddress);
        message.credentialIdentityBytes !== undefined && (obj.credentialIdentityBytes = base64FromBytes(message.credentialIdentityBytes !== undefined ? message.credentialIdentityBytes : new Uint8Array()));
        message.expiration !== undefined && (obj.expiration = (message.expiration || (0, _longDefault.default).UZERO).toString());
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseValidateKeyPackagesResponse_ValidationResponse();
        message.isOk = (_a = object.isOk) !== null && _a !== void 0 ? _a : false;
        message.errorMessage = (_b = object.errorMessage) !== null && _b !== void 0 ? _b : "";
        message.installationId = (_c = object.installationId) !== null && _c !== void 0 ? _c : new Uint8Array();
        message.accountAddress = (_d = object.accountAddress) !== null && _d !== void 0 ? _d : "";
        message.credentialIdentityBytes = (_e = object.credentialIdentityBytes) !== null && _e !== void 0 ? _e : new Uint8Array();
        message.expiration = object.expiration !== undefined && object.expiration !== null ? (0, _longDefault.default).fromValue(object.expiration) : (0, _longDefault.default).UZERO;
        return message;
    }
};
function createBaseValidateGroupMessagesRequest() {
    return {
        groupMessages: []
    };
}
const ValidateGroupMessagesRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.groupMessages)ValidateGroupMessagesRequest_GroupMessage.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidateGroupMessagesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.groupMessages.push(ValidateGroupMessagesRequest_GroupMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            groupMessages: Array.isArray(object === null || object === void 0 ? void 0 : object.groupMessages) ? object.groupMessages.map((e)=>ValidateGroupMessagesRequest_GroupMessage.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.groupMessages) obj.groupMessages = message.groupMessages.map((e)=>e ? ValidateGroupMessagesRequest_GroupMessage.toJSON(e) : undefined);
        else obj.groupMessages = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseValidateGroupMessagesRequest();
        message.groupMessages = ((_a = object.groupMessages) === null || _a === void 0 ? void 0 : _a.map((e)=>ValidateGroupMessagesRequest_GroupMessage.fromPartial(e))) || [];
        return message;
    }
};
function createBaseValidateGroupMessagesRequest_GroupMessage() {
    return {
        groupMessageBytesTlsSerialized: new Uint8Array()
    };
}
const ValidateGroupMessagesRequest_GroupMessage = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.groupMessageBytesTlsSerialized.length !== 0) writer.uint32(10).bytes(message.groupMessageBytesTlsSerialized);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidateGroupMessagesRequest_GroupMessage();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.groupMessageBytesTlsSerialized = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            groupMessageBytesTlsSerialized: isSet(object.groupMessageBytesTlsSerialized) ? bytesFromBase64(object.groupMessageBytesTlsSerialized) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.groupMessageBytesTlsSerialized !== undefined && (obj.groupMessageBytesTlsSerialized = base64FromBytes(message.groupMessageBytesTlsSerialized !== undefined ? message.groupMessageBytesTlsSerialized : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseValidateGroupMessagesRequest_GroupMessage();
        message.groupMessageBytesTlsSerialized = (_a = object.groupMessageBytesTlsSerialized) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseValidateGroupMessagesResponse() {
    return {
        responses: []
    };
}
const ValidateGroupMessagesResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.responses)ValidateGroupMessagesResponse_ValidationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidateGroupMessagesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.responses.push(ValidateGroupMessagesResponse_ValidationResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses) ? object.responses.map((e)=>ValidateGroupMessagesResponse_ValidationResponse.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.responses) obj.responses = message.responses.map((e)=>e ? ValidateGroupMessagesResponse_ValidationResponse.toJSON(e) : undefined);
        else obj.responses = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseValidateGroupMessagesResponse();
        message.responses = ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e)=>ValidateGroupMessagesResponse_ValidationResponse.fromPartial(e))) || [];
        return message;
    }
};
function createBaseValidateGroupMessagesResponse_ValidationResponse() {
    return {
        isOk: false,
        errorMessage: "",
        groupId: ""
    };
}
const ValidateGroupMessagesResponse_ValidationResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.isOk === true) writer.uint32(8).bool(message.isOk);
        if (message.errorMessage !== "") writer.uint32(18).string(message.errorMessage);
        if (message.groupId !== "") writer.uint32(26).string(message.groupId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidateGroupMessagesResponse_ValidationResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.isOk = reader.bool();
                    break;
                case 2:
                    message.errorMessage = reader.string();
                    break;
                case 3:
                    message.groupId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            isOk: isSet(object.isOk) ? Boolean(object.isOk) : false,
            errorMessage: isSet(object.errorMessage) ? String(object.errorMessage) : "",
            groupId: isSet(object.groupId) ? String(object.groupId) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.isOk !== undefined && (obj.isOk = message.isOk);
        message.errorMessage !== undefined && (obj.errorMessage = message.errorMessage);
        message.groupId !== undefined && (obj.groupId = message.groupId);
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseValidateGroupMessagesResponse_ValidationResponse();
        message.isOk = (_a = object.isOk) !== null && _a !== void 0 ? _a : false;
        message.errorMessage = (_b = object.errorMessage) !== null && _b !== void 0 ? _b : "";
        message.groupId = (_c = object.groupId) !== null && _c !== void 0 ? _c : "";
        return message;
    }
};
function createBaseGetAssociationStateRequest() {
    return {
        oldUpdates: [],
        newUpdates: []
    };
}
const GetAssociationStateRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.oldUpdates)(0, _associationPb.IdentityUpdate).encode(v, writer.uint32(10).fork()).ldelim();
        for (const v of message.newUpdates)(0, _associationPb.IdentityUpdate).encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAssociationStateRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.oldUpdates.push((0, _associationPb.IdentityUpdate).decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.newUpdates.push((0, _associationPb.IdentityUpdate).decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            oldUpdates: Array.isArray(object === null || object === void 0 ? void 0 : object.oldUpdates) ? object.oldUpdates.map((e)=>(0, _associationPb.IdentityUpdate).fromJSON(e)) : [],
            newUpdates: Array.isArray(object === null || object === void 0 ? void 0 : object.newUpdates) ? object.newUpdates.map((e)=>(0, _associationPb.IdentityUpdate).fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.oldUpdates) obj.oldUpdates = message.oldUpdates.map((e)=>e ? (0, _associationPb.IdentityUpdate).toJSON(e) : undefined);
        else obj.oldUpdates = [];
        if (message.newUpdates) obj.newUpdates = message.newUpdates.map((e)=>e ? (0, _associationPb.IdentityUpdate).toJSON(e) : undefined);
        else obj.newUpdates = [];
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseGetAssociationStateRequest();
        message.oldUpdates = ((_a = object.oldUpdates) === null || _a === void 0 ? void 0 : _a.map((e)=>(0, _associationPb.IdentityUpdate).fromPartial(e))) || [];
        message.newUpdates = ((_b = object.newUpdates) === null || _b === void 0 ? void 0 : _b.map((e)=>(0, _associationPb.IdentityUpdate).fromPartial(e))) || [];
        return message;
    }
};
function createBaseGetAssociationStateResponse() {
    return {
        associationState: undefined,
        stateDiff: undefined
    };
}
const GetAssociationStateResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.associationState !== undefined) (0, _associationPb.AssociationState).encode(message.associationState, writer.uint32(10).fork()).ldelim();
        if (message.stateDiff !== undefined) (0, _associationPb.AssociationStateDiff).encode(message.stateDiff, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetAssociationStateResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.associationState = (0, _associationPb.AssociationState).decode(reader, reader.uint32());
                    break;
                case 2:
                    message.stateDiff = (0, _associationPb.AssociationStateDiff).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            associationState: isSet(object.associationState) ? (0, _associationPb.AssociationState).fromJSON(object.associationState) : undefined,
            stateDiff: isSet(object.stateDiff) ? (0, _associationPb.AssociationStateDiff).fromJSON(object.stateDiff) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.associationState !== undefined && (obj.associationState = message.associationState ? (0, _associationPb.AssociationState).toJSON(message.associationState) : undefined);
        message.stateDiff !== undefined && (obj.stateDiff = message.stateDiff ? (0, _associationPb.AssociationStateDiff).toJSON(message.stateDiff) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGetAssociationStateResponse();
        message.associationState = object.associationState !== undefined && object.associationState !== null ? (0, _associationPb.AssociationState).fromPartial(object.associationState) : undefined;
        message.stateDiff = object.stateDiff !== undefined && object.stateDiff !== null ? (0, _associationPb.AssociationStateDiff).fromPartial(object.stateDiff) : undefined;
        return message;
    }
};
class ValidationApiClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.ValidateGroupMessages = this.ValidateGroupMessages.bind(this);
        this.GetAssociationState = this.GetAssociationState.bind(this);
        this.ValidateInboxIdKeyPackages = this.ValidateInboxIdKeyPackages.bind(this);
        this.VerifySmartContractWalletSignatures = this.VerifySmartContractWalletSignatures.bind(this);
    }
    ValidateGroupMessages(request) {
        const data = ValidateGroupMessagesRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.mls_validation.v1.ValidationApi", "ValidateGroupMessages", data);
        return promise.then((data)=>ValidateGroupMessagesResponse.decode(new (0, _minimalDefault.default).Reader(data)));
    }
    GetAssociationState(request) {
        const data = GetAssociationStateRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.mls_validation.v1.ValidationApi", "GetAssociationState", data);
        return promise.then((data)=>GetAssociationStateResponse.decode(new (0, _minimalDefault.default).Reader(data)));
    }
    ValidateInboxIdKeyPackages(request) {
        const data = ValidateKeyPackagesRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.mls_validation.v1.ValidationApi", "ValidateInboxIdKeyPackages", data);
        return promise.then((data)=>ValidateInboxIdKeyPackagesResponse.decode(new (0, _minimalDefault.default).Reader(data)));
    }
    VerifySmartContractWalletSignatures(request) {
        const data = (0, _identityPb.VerifySmartContractWalletSignaturesRequest).encode(request).finish();
        const promise = this.rpc.request("xmtp.mls_validation.v1.ValidationApi", "VerifySmartContractWalletSignatures", data);
        return promise.then((data)=>(0, _identityPb.VerifySmartContractWalletSignaturesResponse).decode(new (0, _minimalDefault.default).Reader(data)));
    }
}
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","../../identity/credential.pb":"6yjJ9","../../identity/associations/association.pb":"lXnXi","../../identity/api/v1/identity.pb":"7BLy0","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6yjJ9":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "MlsCredential", ()=>MlsCredential);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
const protobufPackage = "xmtp.identity";
function createBaseMlsCredential() {
    return {
        inboxId: ""
    };
}
const MlsCredential = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.inboxId !== "") writer.uint32(10).string(message.inboxId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMlsCredential();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.inboxId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseMlsCredential();
        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lXnXi":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "MemberIdentifier", ()=>MemberIdentifier);
parcelHelpers.export(exports, "Member", ()=>Member);
parcelHelpers.export(exports, "CreateInbox", ()=>CreateInbox);
parcelHelpers.export(exports, "AddAssociation", ()=>AddAssociation);
parcelHelpers.export(exports, "RevokeAssociation", ()=>RevokeAssociation);
parcelHelpers.export(exports, "ChangeRecoveryAddress", ()=>ChangeRecoveryAddress);
parcelHelpers.export(exports, "IdentityAction", ()=>IdentityAction);
parcelHelpers.export(exports, "IdentityUpdate", ()=>IdentityUpdate);
parcelHelpers.export(exports, "MemberMap", ()=>MemberMap);
parcelHelpers.export(exports, "AssociationState", ()=>AssociationState);
parcelHelpers.export(exports, "AssociationStateDiff", ()=>AssociationStateDiff);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _signaturePb = require("./signature.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.identity.associations";
function createBaseMemberIdentifier() {
    return {
        address: undefined,
        installationPublicKey: undefined
    };
}
const MemberIdentifier = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.address !== undefined) writer.uint32(10).string(message.address);
        if (message.installationPublicKey !== undefined) writer.uint32(18).bytes(message.installationPublicKey);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMemberIdentifier();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.installationPublicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            address: isSet(object.address) ? String(object.address) : undefined,
            installationPublicKey: isSet(object.installationPublicKey) ? bytesFromBase64(object.installationPublicKey) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.installationPublicKey !== undefined && (obj.installationPublicKey = message.installationPublicKey !== undefined ? base64FromBytes(message.installationPublicKey) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseMemberIdentifier();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : undefined;
        message.installationPublicKey = (_b = object.installationPublicKey) !== null && _b !== void 0 ? _b : undefined;
        return message;
    }
};
function createBaseMember() {
    return {
        identifier: undefined,
        addedByEntity: undefined,
        clientTimestampNs: undefined,
        addedOnChainId: undefined
    };
}
const Member = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.identifier !== undefined) MemberIdentifier.encode(message.identifier, writer.uint32(10).fork()).ldelim();
        if (message.addedByEntity !== undefined) MemberIdentifier.encode(message.addedByEntity, writer.uint32(18).fork()).ldelim();
        if (message.clientTimestampNs !== undefined) writer.uint32(24).uint64(message.clientTimestampNs);
        if (message.addedOnChainId !== undefined) writer.uint32(32).uint64(message.addedOnChainId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMember();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.identifier = MemberIdentifier.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.addedByEntity = MemberIdentifier.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.clientTimestampNs = reader.uint64();
                    break;
                case 4:
                    message.addedOnChainId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            identifier: isSet(object.identifier) ? MemberIdentifier.fromJSON(object.identifier) : undefined,
            addedByEntity: isSet(object.addedByEntity) ? MemberIdentifier.fromJSON(object.addedByEntity) : undefined,
            clientTimestampNs: isSet(object.clientTimestampNs) ? (0, _longDefault.default).fromValue(object.clientTimestampNs) : undefined,
            addedOnChainId: isSet(object.addedOnChainId) ? (0, _longDefault.default).fromValue(object.addedOnChainId) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.identifier !== undefined && (obj.identifier = message.identifier ? MemberIdentifier.toJSON(message.identifier) : undefined);
        message.addedByEntity !== undefined && (obj.addedByEntity = message.addedByEntity ? MemberIdentifier.toJSON(message.addedByEntity) : undefined);
        message.clientTimestampNs !== undefined && (obj.clientTimestampNs = (message.clientTimestampNs || undefined).toString());
        message.addedOnChainId !== undefined && (obj.addedOnChainId = (message.addedOnChainId || undefined).toString());
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMember();
        message.identifier = object.identifier !== undefined && object.identifier !== null ? MemberIdentifier.fromPartial(object.identifier) : undefined;
        message.addedByEntity = object.addedByEntity !== undefined && object.addedByEntity !== null ? MemberIdentifier.fromPartial(object.addedByEntity) : undefined;
        message.clientTimestampNs = object.clientTimestampNs !== undefined && object.clientTimestampNs !== null ? (0, _longDefault.default).fromValue(object.clientTimestampNs) : undefined;
        message.addedOnChainId = object.addedOnChainId !== undefined && object.addedOnChainId !== null ? (0, _longDefault.default).fromValue(object.addedOnChainId) : undefined;
        return message;
    }
};
function createBaseCreateInbox() {
    return {
        initialAddress: "",
        nonce: (0, _longDefault.default).UZERO,
        initialAddressSignature: undefined
    };
}
const CreateInbox = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.initialAddress !== "") writer.uint32(10).string(message.initialAddress);
        if (!message.nonce.isZero()) writer.uint32(16).uint64(message.nonce);
        if (message.initialAddressSignature !== undefined) (0, _signaturePb.Signature).encode(message.initialAddressSignature, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateInbox();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.initialAddress = reader.string();
                    break;
                case 2:
                    message.nonce = reader.uint64();
                    break;
                case 3:
                    message.initialAddressSignature = (0, _signaturePb.Signature).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            initialAddress: isSet(object.initialAddress) ? String(object.initialAddress) : "",
            nonce: isSet(object.nonce) ? (0, _longDefault.default).fromValue(object.nonce) : (0, _longDefault.default).UZERO,
            initialAddressSignature: isSet(object.initialAddressSignature) ? (0, _signaturePb.Signature).fromJSON(object.initialAddressSignature) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.initialAddress !== undefined && (obj.initialAddress = message.initialAddress);
        message.nonce !== undefined && (obj.nonce = (message.nonce || (0, _longDefault.default).UZERO).toString());
        message.initialAddressSignature !== undefined && (obj.initialAddressSignature = message.initialAddressSignature ? (0, _signaturePb.Signature).toJSON(message.initialAddressSignature) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseCreateInbox();
        message.initialAddress = (_a = object.initialAddress) !== null && _a !== void 0 ? _a : "";
        message.nonce = object.nonce !== undefined && object.nonce !== null ? (0, _longDefault.default).fromValue(object.nonce) : (0, _longDefault.default).UZERO;
        message.initialAddressSignature = object.initialAddressSignature !== undefined && object.initialAddressSignature !== null ? (0, _signaturePb.Signature).fromPartial(object.initialAddressSignature) : undefined;
        return message;
    }
};
function createBaseAddAssociation() {
    return {
        newMemberIdentifier: undefined,
        existingMemberSignature: undefined,
        newMemberSignature: undefined
    };
}
const AddAssociation = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.newMemberIdentifier !== undefined) MemberIdentifier.encode(message.newMemberIdentifier, writer.uint32(10).fork()).ldelim();
        if (message.existingMemberSignature !== undefined) (0, _signaturePb.Signature).encode(message.existingMemberSignature, writer.uint32(18).fork()).ldelim();
        if (message.newMemberSignature !== undefined) (0, _signaturePb.Signature).encode(message.newMemberSignature, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddAssociation();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.newMemberIdentifier = MemberIdentifier.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.existingMemberSignature = (0, _signaturePb.Signature).decode(reader, reader.uint32());
                    break;
                case 3:
                    message.newMemberSignature = (0, _signaturePb.Signature).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            newMemberIdentifier: isSet(object.newMemberIdentifier) ? MemberIdentifier.fromJSON(object.newMemberIdentifier) : undefined,
            existingMemberSignature: isSet(object.existingMemberSignature) ? (0, _signaturePb.Signature).fromJSON(object.existingMemberSignature) : undefined,
            newMemberSignature: isSet(object.newMemberSignature) ? (0, _signaturePb.Signature).fromJSON(object.newMemberSignature) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.newMemberIdentifier !== undefined && (obj.newMemberIdentifier = message.newMemberIdentifier ? MemberIdentifier.toJSON(message.newMemberIdentifier) : undefined);
        message.existingMemberSignature !== undefined && (obj.existingMemberSignature = message.existingMemberSignature ? (0, _signaturePb.Signature).toJSON(message.existingMemberSignature) : undefined);
        message.newMemberSignature !== undefined && (obj.newMemberSignature = message.newMemberSignature ? (0, _signaturePb.Signature).toJSON(message.newMemberSignature) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseAddAssociation();
        message.newMemberIdentifier = object.newMemberIdentifier !== undefined && object.newMemberIdentifier !== null ? MemberIdentifier.fromPartial(object.newMemberIdentifier) : undefined;
        message.existingMemberSignature = object.existingMemberSignature !== undefined && object.existingMemberSignature !== null ? (0, _signaturePb.Signature).fromPartial(object.existingMemberSignature) : undefined;
        message.newMemberSignature = object.newMemberSignature !== undefined && object.newMemberSignature !== null ? (0, _signaturePb.Signature).fromPartial(object.newMemberSignature) : undefined;
        return message;
    }
};
function createBaseRevokeAssociation() {
    return {
        memberToRevoke: undefined,
        recoveryAddressSignature: undefined
    };
}
const RevokeAssociation = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.memberToRevoke !== undefined) MemberIdentifier.encode(message.memberToRevoke, writer.uint32(10).fork()).ldelim();
        if (message.recoveryAddressSignature !== undefined) (0, _signaturePb.Signature).encode(message.recoveryAddressSignature, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRevokeAssociation();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.memberToRevoke = MemberIdentifier.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.recoveryAddressSignature = (0, _signaturePb.Signature).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            memberToRevoke: isSet(object.memberToRevoke) ? MemberIdentifier.fromJSON(object.memberToRevoke) : undefined,
            recoveryAddressSignature: isSet(object.recoveryAddressSignature) ? (0, _signaturePb.Signature).fromJSON(object.recoveryAddressSignature) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.memberToRevoke !== undefined && (obj.memberToRevoke = message.memberToRevoke ? MemberIdentifier.toJSON(message.memberToRevoke) : undefined);
        message.recoveryAddressSignature !== undefined && (obj.recoveryAddressSignature = message.recoveryAddressSignature ? (0, _signaturePb.Signature).toJSON(message.recoveryAddressSignature) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseRevokeAssociation();
        message.memberToRevoke = object.memberToRevoke !== undefined && object.memberToRevoke !== null ? MemberIdentifier.fromPartial(object.memberToRevoke) : undefined;
        message.recoveryAddressSignature = object.recoveryAddressSignature !== undefined && object.recoveryAddressSignature !== null ? (0, _signaturePb.Signature).fromPartial(object.recoveryAddressSignature) : undefined;
        return message;
    }
};
function createBaseChangeRecoveryAddress() {
    return {
        newRecoveryAddress: "",
        existingRecoveryAddressSignature: undefined
    };
}
const ChangeRecoveryAddress = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.newRecoveryAddress !== "") writer.uint32(10).string(message.newRecoveryAddress);
        if (message.existingRecoveryAddressSignature !== undefined) (0, _signaturePb.Signature).encode(message.existingRecoveryAddressSignature, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChangeRecoveryAddress();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.newRecoveryAddress = reader.string();
                    break;
                case 2:
                    message.existingRecoveryAddressSignature = (0, _signaturePb.Signature).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            newRecoveryAddress: isSet(object.newRecoveryAddress) ? String(object.newRecoveryAddress) : "",
            existingRecoveryAddressSignature: isSet(object.existingRecoveryAddressSignature) ? (0, _signaturePb.Signature).fromJSON(object.existingRecoveryAddressSignature) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.newRecoveryAddress !== undefined && (obj.newRecoveryAddress = message.newRecoveryAddress);
        message.existingRecoveryAddressSignature !== undefined && (obj.existingRecoveryAddressSignature = message.existingRecoveryAddressSignature ? (0, _signaturePb.Signature).toJSON(message.existingRecoveryAddressSignature) : undefined);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseChangeRecoveryAddress();
        message.newRecoveryAddress = (_a = object.newRecoveryAddress) !== null && _a !== void 0 ? _a : "";
        message.existingRecoveryAddressSignature = object.existingRecoveryAddressSignature !== undefined && object.existingRecoveryAddressSignature !== null ? (0, _signaturePb.Signature).fromPartial(object.existingRecoveryAddressSignature) : undefined;
        return message;
    }
};
function createBaseIdentityAction() {
    return {
        createInbox: undefined,
        add: undefined,
        revoke: undefined,
        changeRecoveryAddress: undefined
    };
}
const IdentityAction = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.createInbox !== undefined) CreateInbox.encode(message.createInbox, writer.uint32(10).fork()).ldelim();
        if (message.add !== undefined) AddAssociation.encode(message.add, writer.uint32(18).fork()).ldelim();
        if (message.revoke !== undefined) RevokeAssociation.encode(message.revoke, writer.uint32(26).fork()).ldelim();
        if (message.changeRecoveryAddress !== undefined) ChangeRecoveryAddress.encode(message.changeRecoveryAddress, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIdentityAction();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.createInbox = CreateInbox.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.add = AddAssociation.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.revoke = RevokeAssociation.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.changeRecoveryAddress = ChangeRecoveryAddress.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            createInbox: isSet(object.createInbox) ? CreateInbox.fromJSON(object.createInbox) : undefined,
            add: isSet(object.add) ? AddAssociation.fromJSON(object.add) : undefined,
            revoke: isSet(object.revoke) ? RevokeAssociation.fromJSON(object.revoke) : undefined,
            changeRecoveryAddress: isSet(object.changeRecoveryAddress) ? ChangeRecoveryAddress.fromJSON(object.changeRecoveryAddress) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.createInbox !== undefined && (obj.createInbox = message.createInbox ? CreateInbox.toJSON(message.createInbox) : undefined);
        message.add !== undefined && (obj.add = message.add ? AddAssociation.toJSON(message.add) : undefined);
        message.revoke !== undefined && (obj.revoke = message.revoke ? RevokeAssociation.toJSON(message.revoke) : undefined);
        message.changeRecoveryAddress !== undefined && (obj.changeRecoveryAddress = message.changeRecoveryAddress ? ChangeRecoveryAddress.toJSON(message.changeRecoveryAddress) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseIdentityAction();
        message.createInbox = object.createInbox !== undefined && object.createInbox !== null ? CreateInbox.fromPartial(object.createInbox) : undefined;
        message.add = object.add !== undefined && object.add !== null ? AddAssociation.fromPartial(object.add) : undefined;
        message.revoke = object.revoke !== undefined && object.revoke !== null ? RevokeAssociation.fromPartial(object.revoke) : undefined;
        message.changeRecoveryAddress = object.changeRecoveryAddress !== undefined && object.changeRecoveryAddress !== null ? ChangeRecoveryAddress.fromPartial(object.changeRecoveryAddress) : undefined;
        return message;
    }
};
function createBaseIdentityUpdate() {
    return {
        actions: [],
        clientTimestampNs: (0, _longDefault.default).UZERO,
        inboxId: ""
    };
}
const IdentityUpdate = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.actions)IdentityAction.encode(v, writer.uint32(10).fork()).ldelim();
        if (!message.clientTimestampNs.isZero()) writer.uint32(16).uint64(message.clientTimestampNs);
        if (message.inboxId !== "") writer.uint32(26).string(message.inboxId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIdentityUpdate();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.actions.push(IdentityAction.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.clientTimestampNs = reader.uint64();
                    break;
                case 3:
                    message.inboxId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            actions: Array.isArray(object === null || object === void 0 ? void 0 : object.actions) ? object.actions.map((e)=>IdentityAction.fromJSON(e)) : [],
            clientTimestampNs: isSet(object.clientTimestampNs) ? (0, _longDefault.default).fromValue(object.clientTimestampNs) : (0, _longDefault.default).UZERO,
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.actions) obj.actions = message.actions.map((e)=>e ? IdentityAction.toJSON(e) : undefined);
        else obj.actions = [];
        message.clientTimestampNs !== undefined && (obj.clientTimestampNs = (message.clientTimestampNs || (0, _longDefault.default).UZERO).toString());
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseIdentityUpdate();
        message.actions = ((_a = object.actions) === null || _a === void 0 ? void 0 : _a.map((e)=>IdentityAction.fromPartial(e))) || [];
        message.clientTimestampNs = object.clientTimestampNs !== undefined && object.clientTimestampNs !== null ? (0, _longDefault.default).fromValue(object.clientTimestampNs) : (0, _longDefault.default).UZERO;
        message.inboxId = (_b = object.inboxId) !== null && _b !== void 0 ? _b : "";
        return message;
    }
};
function createBaseMemberMap() {
    return {
        key: undefined,
        value: undefined
    };
}
const MemberMap = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.key !== undefined) MemberIdentifier.encode(message.key, writer.uint32(10).fork()).ldelim();
        if (message.value !== undefined) Member.encode(message.value, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMemberMap();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.key = MemberIdentifier.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.value = Member.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            key: isSet(object.key) ? MemberIdentifier.fromJSON(object.key) : undefined,
            value: isSet(object.value) ? Member.fromJSON(object.value) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.key !== undefined && (obj.key = message.key ? MemberIdentifier.toJSON(message.key) : undefined);
        message.value !== undefined && (obj.value = message.value ? Member.toJSON(message.value) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseMemberMap();
        message.key = object.key !== undefined && object.key !== null ? MemberIdentifier.fromPartial(object.key) : undefined;
        message.value = object.value !== undefined && object.value !== null ? Member.fromPartial(object.value) : undefined;
        return message;
    }
};
function createBaseAssociationState() {
    return {
        inboxId: "",
        members: [],
        recoveryAddress: "",
        seenSignatures: []
    };
}
const AssociationState = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.inboxId !== "") writer.uint32(10).string(message.inboxId);
        for (const v of message.members)MemberMap.encode(v, writer.uint32(18).fork()).ldelim();
        if (message.recoveryAddress !== "") writer.uint32(26).string(message.recoveryAddress);
        for (const v of message.seenSignatures)writer.uint32(34).bytes(v);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAssociationState();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.inboxId = reader.string();
                    break;
                case 2:
                    message.members.push(MemberMap.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.recoveryAddress = reader.string();
                    break;
                case 4:
                    message.seenSignatures.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : "",
            members: Array.isArray(object === null || object === void 0 ? void 0 : object.members) ? object.members.map((e)=>MemberMap.fromJSON(e)) : [],
            recoveryAddress: isSet(object.recoveryAddress) ? String(object.recoveryAddress) : "",
            seenSignatures: Array.isArray(object === null || object === void 0 ? void 0 : object.seenSignatures) ? object.seenSignatures.map((e)=>bytesFromBase64(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        if (message.members) obj.members = message.members.map((e)=>e ? MemberMap.toJSON(e) : undefined);
        else obj.members = [];
        message.recoveryAddress !== undefined && (obj.recoveryAddress = message.recoveryAddress);
        if (message.seenSignatures) obj.seenSignatures = message.seenSignatures.map((e)=>base64FromBytes(e !== undefined ? e : new Uint8Array()));
        else obj.seenSignatures = [];
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c, _d;
        const message = createBaseAssociationState();
        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : "";
        message.members = ((_b = object.members) === null || _b === void 0 ? void 0 : _b.map((e)=>MemberMap.fromPartial(e))) || [];
        message.recoveryAddress = (_c = object.recoveryAddress) !== null && _c !== void 0 ? _c : "";
        message.seenSignatures = ((_d = object.seenSignatures) === null || _d === void 0 ? void 0 : _d.map((e)=>e)) || [];
        return message;
    }
};
function createBaseAssociationStateDiff() {
    return {
        newMembers: [],
        removedMembers: []
    };
}
const AssociationStateDiff = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.newMembers)MemberIdentifier.encode(v, writer.uint32(10).fork()).ldelim();
        for (const v of message.removedMembers)MemberIdentifier.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAssociationStateDiff();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.newMembers.push(MemberIdentifier.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.removedMembers.push(MemberIdentifier.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            newMembers: Array.isArray(object === null || object === void 0 ? void 0 : object.newMembers) ? object.newMembers.map((e)=>MemberIdentifier.fromJSON(e)) : [],
            removedMembers: Array.isArray(object === null || object === void 0 ? void 0 : object.removedMembers) ? object.removedMembers.map((e)=>MemberIdentifier.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.newMembers) obj.newMembers = message.newMembers.map((e)=>e ? MemberIdentifier.toJSON(e) : undefined);
        else obj.newMembers = [];
        if (message.removedMembers) obj.removedMembers = message.removedMembers.map((e)=>e ? MemberIdentifier.toJSON(e) : undefined);
        else obj.removedMembers = [];
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseAssociationStateDiff();
        message.newMembers = ((_a = object.newMembers) === null || _a === void 0 ? void 0 : _a.map((e)=>MemberIdentifier.fromPartial(e))) || [];
        message.removedMembers = ((_b = object.removedMembers) === null || _b === void 0 ? void 0 : _b.map((e)=>MemberIdentifier.fromPartial(e))) || [];
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","./signature.pb":"8V0Ww","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8V0Ww":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "RecoverableEcdsaSignature", ()=>RecoverableEcdsaSignature);
parcelHelpers.export(exports, "RecoverableEd25519Signature", ()=>RecoverableEd25519Signature);
parcelHelpers.export(exports, "SmartContractWalletSignature", ()=>SmartContractWalletSignature);
parcelHelpers.export(exports, "LegacyDelegatedSignature", ()=>LegacyDelegatedSignature);
parcelHelpers.export(exports, "Signature", ()=>Signature);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _publicKeyPb = require("../../message_contents/public_key.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.identity.associations";
function createBaseRecoverableEcdsaSignature() {
    return {
        bytes: new Uint8Array()
    };
}
const RecoverableEcdsaSignature = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.bytes.length !== 0) writer.uint32(10).bytes(message.bytes);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecoverableEcdsaSignature();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.bytes = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.bytes !== undefined && (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseRecoverableEcdsaSignature();
        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        return message;
    }
};
function createBaseRecoverableEd25519Signature() {
    return {
        bytes: new Uint8Array(),
        publicKey: new Uint8Array()
    };
}
const RecoverableEd25519Signature = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.bytes.length !== 0) writer.uint32(10).bytes(message.bytes);
        if (message.publicKey.length !== 0) writer.uint32(18).bytes(message.publicKey);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecoverableEd25519Signature();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.bytes = reader.bytes();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : new Uint8Array(),
            publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.bytes !== undefined && (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));
        message.publicKey !== undefined && (obj.publicKey = base64FromBytes(message.publicKey !== undefined ? message.publicKey : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseRecoverableEd25519Signature();
        message.bytes = (_a = object.bytes) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.publicKey = (_b = object.publicKey) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    }
};
function createBaseSmartContractWalletSignature() {
    return {
        accountId: "",
        blockNumber: (0, _longDefault.default).UZERO,
        signature: new Uint8Array()
    };
}
const SmartContractWalletSignature = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.accountId !== "") writer.uint32(10).string(message.accountId);
        if (!message.blockNumber.isZero()) writer.uint32(16).uint64(message.blockNumber);
        if (message.signature.length !== 0) writer.uint32(26).bytes(message.signature);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSmartContractWalletSignature();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.accountId = reader.string();
                    break;
                case 2:
                    message.blockNumber = reader.uint64();
                    break;
                case 3:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            accountId: isSet(object.accountId) ? String(object.accountId) : "",
            blockNumber: isSet(object.blockNumber) ? (0, _longDefault.default).fromValue(object.blockNumber) : (0, _longDefault.default).UZERO,
            signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.accountId !== undefined && (obj.accountId = message.accountId);
        message.blockNumber !== undefined && (obj.blockNumber = (message.blockNumber || (0, _longDefault.default).UZERO).toString());
        message.signature !== undefined && (obj.signature = base64FromBytes(message.signature !== undefined ? message.signature : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseSmartContractWalletSignature();
        message.accountId = (_a = object.accountId) !== null && _a !== void 0 ? _a : "";
        message.blockNumber = object.blockNumber !== undefined && object.blockNumber !== null ? (0, _longDefault.default).fromValue(object.blockNumber) : (0, _longDefault.default).UZERO;
        message.signature = (_b = object.signature) !== null && _b !== void 0 ? _b : new Uint8Array();
        return message;
    }
};
function createBaseLegacyDelegatedSignature() {
    return {
        delegatedKey: undefined,
        signature: undefined
    };
}
const LegacyDelegatedSignature = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.delegatedKey !== undefined) (0, _publicKeyPb.SignedPublicKey).encode(message.delegatedKey, writer.uint32(10).fork()).ldelim();
        if (message.signature !== undefined) RecoverableEcdsaSignature.encode(message.signature, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLegacyDelegatedSignature();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.delegatedKey = (0, _publicKeyPb.SignedPublicKey).decode(reader, reader.uint32());
                    break;
                case 2:
                    message.signature = RecoverableEcdsaSignature.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            delegatedKey: isSet(object.delegatedKey) ? (0, _publicKeyPb.SignedPublicKey).fromJSON(object.delegatedKey) : undefined,
            signature: isSet(object.signature) ? RecoverableEcdsaSignature.fromJSON(object.signature) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.delegatedKey !== undefined && (obj.delegatedKey = message.delegatedKey ? (0, _publicKeyPb.SignedPublicKey).toJSON(message.delegatedKey) : undefined);
        message.signature !== undefined && (obj.signature = message.signature ? RecoverableEcdsaSignature.toJSON(message.signature) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseLegacyDelegatedSignature();
        message.delegatedKey = object.delegatedKey !== undefined && object.delegatedKey !== null ? (0, _publicKeyPb.SignedPublicKey).fromPartial(object.delegatedKey) : undefined;
        message.signature = object.signature !== undefined && object.signature !== null ? RecoverableEcdsaSignature.fromPartial(object.signature) : undefined;
        return message;
    }
};
function createBaseSignature() {
    return {
        erc191: undefined,
        erc6492: undefined,
        installationKey: undefined,
        delegatedErc191: undefined
    };
}
const Signature = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.erc191 !== undefined) RecoverableEcdsaSignature.encode(message.erc191, writer.uint32(10).fork()).ldelim();
        if (message.erc6492 !== undefined) SmartContractWalletSignature.encode(message.erc6492, writer.uint32(18).fork()).ldelim();
        if (message.installationKey !== undefined) RecoverableEd25519Signature.encode(message.installationKey, writer.uint32(26).fork()).ldelim();
        if (message.delegatedErc191 !== undefined) LegacyDelegatedSignature.encode(message.delegatedErc191, writer.uint32(34).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignature();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.erc191 = RecoverableEcdsaSignature.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.erc6492 = SmartContractWalletSignature.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.installationKey = RecoverableEd25519Signature.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.delegatedErc191 = LegacyDelegatedSignature.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            erc191: isSet(object.erc191) ? RecoverableEcdsaSignature.fromJSON(object.erc191) : undefined,
            erc6492: isSet(object.erc6492) ? SmartContractWalletSignature.fromJSON(object.erc6492) : undefined,
            installationKey: isSet(object.installationKey) ? RecoverableEd25519Signature.fromJSON(object.installationKey) : undefined,
            delegatedErc191: isSet(object.delegatedErc191) ? LegacyDelegatedSignature.fromJSON(object.delegatedErc191) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.erc191 !== undefined && (obj.erc191 = message.erc191 ? RecoverableEcdsaSignature.toJSON(message.erc191) : undefined);
        message.erc6492 !== undefined && (obj.erc6492 = message.erc6492 ? SmartContractWalletSignature.toJSON(message.erc6492) : undefined);
        message.installationKey !== undefined && (obj.installationKey = message.installationKey ? RecoverableEd25519Signature.toJSON(message.installationKey) : undefined);
        message.delegatedErc191 !== undefined && (obj.delegatedErc191 = message.delegatedErc191 ? LegacyDelegatedSignature.toJSON(message.delegatedErc191) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseSignature();
        message.erc191 = object.erc191 !== undefined && object.erc191 !== null ? RecoverableEcdsaSignature.fromPartial(object.erc191) : undefined;
        message.erc6492 = object.erc6492 !== undefined && object.erc6492 !== null ? SmartContractWalletSignature.fromPartial(object.erc6492) : undefined;
        message.installationKey = object.installationKey !== undefined && object.installationKey !== null ? RecoverableEd25519Signature.fromPartial(object.installationKey) : undefined;
        message.delegatedErc191 = object.delegatedErc191 !== undefined && object.delegatedErc191 !== null ? LegacyDelegatedSignature.fromPartial(object.delegatedErc191) : undefined;
        return message;
    }
};
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","../../message_contents/public_key.pb":"6Dba7","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7BLy0":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "protobufPackage", ()=>protobufPackage);
parcelHelpers.export(exports, "VerifySmartContractWalletSignaturesRequest", ()=>VerifySmartContractWalletSignaturesRequest);
parcelHelpers.export(exports, "VerifySmartContractWalletSignatureRequestSignature", ()=>VerifySmartContractWalletSignatureRequestSignature);
parcelHelpers.export(exports, "VerifySmartContractWalletSignaturesResponse", ()=>VerifySmartContractWalletSignaturesResponse);
parcelHelpers.export(exports, "VerifySmartContractWalletSignaturesResponse_ValidationResponse", ()=>VerifySmartContractWalletSignaturesResponse_ValidationResponse);
parcelHelpers.export(exports, "PublishIdentityUpdateRequest", ()=>PublishIdentityUpdateRequest);
parcelHelpers.export(exports, "PublishIdentityUpdateResponse", ()=>PublishIdentityUpdateResponse);
parcelHelpers.export(exports, "GetIdentityUpdatesRequest", ()=>GetIdentityUpdatesRequest);
parcelHelpers.export(exports, "GetIdentityUpdatesRequest_Request", ()=>GetIdentityUpdatesRequest_Request);
parcelHelpers.export(exports, "GetIdentityUpdatesResponse", ()=>GetIdentityUpdatesResponse);
parcelHelpers.export(exports, "GetIdentityUpdatesResponse_IdentityUpdateLog", ()=>GetIdentityUpdatesResponse_IdentityUpdateLog);
parcelHelpers.export(exports, "GetIdentityUpdatesResponse_Response", ()=>GetIdentityUpdatesResponse_Response);
parcelHelpers.export(exports, "GetInboxIdsRequest", ()=>GetInboxIdsRequest);
parcelHelpers.export(exports, "GetInboxIdsRequest_Request", ()=>GetInboxIdsRequest_Request);
parcelHelpers.export(exports, "GetInboxIdsResponse", ()=>GetInboxIdsResponse);
parcelHelpers.export(exports, "GetInboxIdsResponse_Response", ()=>GetInboxIdsResponse_Response);
parcelHelpers.export(exports, "IdentityApiClientImpl", ()=>IdentityApiClientImpl);
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
var _associationPb = require("../../associations/association.pb");
var _minimal = require("protobufjs/minimal");
var _minimalDefault = parcelHelpers.interopDefault(_minimal);
var global = arguments[3];
const protobufPackage = "xmtp.identity.api.v1";
function createBaseVerifySmartContractWalletSignaturesRequest() {
    return {
        signatures: []
    };
}
const VerifySmartContractWalletSignaturesRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.signatures)VerifySmartContractWalletSignatureRequestSignature.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifySmartContractWalletSignaturesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.signatures.push(VerifySmartContractWalletSignatureRequestSignature.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures) ? object.signatures.map((e)=>VerifySmartContractWalletSignatureRequestSignature.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.signatures) obj.signatures = message.signatures.map((e)=>e ? VerifySmartContractWalletSignatureRequestSignature.toJSON(e) : undefined);
        else obj.signatures = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseVerifySmartContractWalletSignaturesRequest();
        message.signatures = ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map((e)=>VerifySmartContractWalletSignatureRequestSignature.fromPartial(e))) || [];
        return message;
    }
};
function createBaseVerifySmartContractWalletSignatureRequestSignature() {
    return {
        accountId: "",
        blockNumber: undefined,
        signature: new Uint8Array(),
        hash: new Uint8Array()
    };
}
const VerifySmartContractWalletSignatureRequestSignature = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.accountId !== "") writer.uint32(10).string(message.accountId);
        if (message.blockNumber !== undefined) writer.uint32(16).uint64(message.blockNumber);
        if (message.signature.length !== 0) writer.uint32(26).bytes(message.signature);
        if (message.hash.length !== 0) writer.uint32(34).bytes(message.hash);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifySmartContractWalletSignatureRequestSignature();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.accountId = reader.string();
                    break;
                case 2:
                    message.blockNumber = reader.uint64();
                    break;
                case 3:
                    message.signature = reader.bytes();
                    break;
                case 4:
                    message.hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            accountId: isSet(object.accountId) ? String(object.accountId) : "",
            blockNumber: isSet(object.blockNumber) ? (0, _longDefault.default).fromValue(object.blockNumber) : undefined,
            signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(),
            hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array()
        };
    },
    toJSON (message) {
        const obj = {};
        message.accountId !== undefined && (obj.accountId = message.accountId);
        message.blockNumber !== undefined && (obj.blockNumber = (message.blockNumber || undefined).toString());
        message.signature !== undefined && (obj.signature = base64FromBytes(message.signature !== undefined ? message.signature : new Uint8Array()));
        message.hash !== undefined && (obj.hash = base64FromBytes(message.hash !== undefined ? message.hash : new Uint8Array()));
        return obj;
    },
    fromPartial (object) {
        var _a, _b, _c;
        const message = createBaseVerifySmartContractWalletSignatureRequestSignature();
        message.accountId = (_a = object.accountId) !== null && _a !== void 0 ? _a : "";
        message.blockNumber = object.blockNumber !== undefined && object.blockNumber !== null ? (0, _longDefault.default).fromValue(object.blockNumber) : undefined;
        message.signature = (_b = object.signature) !== null && _b !== void 0 ? _b : new Uint8Array();
        message.hash = (_c = object.hash) !== null && _c !== void 0 ? _c : new Uint8Array();
        return message;
    }
};
function createBaseVerifySmartContractWalletSignaturesResponse() {
    return {
        responses: []
    };
}
const VerifySmartContractWalletSignaturesResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.responses)VerifySmartContractWalletSignaturesResponse_ValidationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifySmartContractWalletSignaturesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.responses.push(VerifySmartContractWalletSignaturesResponse_ValidationResponse.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses) ? object.responses.map((e)=>VerifySmartContractWalletSignaturesResponse_ValidationResponse.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.responses) obj.responses = message.responses.map((e)=>e ? VerifySmartContractWalletSignaturesResponse_ValidationResponse.toJSON(e) : undefined);
        else obj.responses = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseVerifySmartContractWalletSignaturesResponse();
        message.responses = ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e)=>VerifySmartContractWalletSignaturesResponse_ValidationResponse.fromPartial(e))) || [];
        return message;
    }
};
function createBaseVerifySmartContractWalletSignaturesResponse_ValidationResponse() {
    return {
        isValid: false,
        blockNumber: undefined,
        error: undefined
    };
}
const VerifySmartContractWalletSignaturesResponse_ValidationResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.isValid === true) writer.uint32(8).bool(message.isValid);
        if (message.blockNumber !== undefined) writer.uint32(16).uint64(message.blockNumber);
        if (message.error !== undefined) writer.uint32(26).string(message.error);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVerifySmartContractWalletSignaturesResponse_ValidationResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.isValid = reader.bool();
                    break;
                case 2:
                    message.blockNumber = reader.uint64();
                    break;
                case 3:
                    message.error = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            isValid: isSet(object.isValid) ? Boolean(object.isValid) : false,
            blockNumber: isSet(object.blockNumber) ? (0, _longDefault.default).fromValue(object.blockNumber) : undefined,
            error: isSet(object.error) ? String(object.error) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.isValid !== undefined && (obj.isValid = message.isValid);
        message.blockNumber !== undefined && (obj.blockNumber = (message.blockNumber || undefined).toString());
        message.error !== undefined && (obj.error = message.error);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseVerifySmartContractWalletSignaturesResponse_ValidationResponse();
        message.isValid = (_a = object.isValid) !== null && _a !== void 0 ? _a : false;
        message.blockNumber = object.blockNumber !== undefined && object.blockNumber !== null ? (0, _longDefault.default).fromValue(object.blockNumber) : undefined;
        message.error = (_b = object.error) !== null && _b !== void 0 ? _b : undefined;
        return message;
    }
};
function createBasePublishIdentityUpdateRequest() {
    return {
        identityUpdate: undefined
    };
}
const PublishIdentityUpdateRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.identityUpdate !== undefined) (0, _associationPb.IdentityUpdate).encode(message.identityUpdate, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePublishIdentityUpdateRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.identityUpdate = (0, _associationPb.IdentityUpdate).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            identityUpdate: isSet(object.identityUpdate) ? (0, _associationPb.IdentityUpdate).fromJSON(object.identityUpdate) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.identityUpdate !== undefined && (obj.identityUpdate = message.identityUpdate ? (0, _associationPb.IdentityUpdate).toJSON(message.identityUpdate) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBasePublishIdentityUpdateRequest();
        message.identityUpdate = object.identityUpdate !== undefined && object.identityUpdate !== null ? (0, _associationPb.IdentityUpdate).fromPartial(object.identityUpdate) : undefined;
        return message;
    }
};
function createBasePublishIdentityUpdateResponse() {
    return {};
}
const PublishIdentityUpdateResponse = {
    encode (_, writer = (0, _minimalDefault.default).Writer.create()) {
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePublishIdentityUpdateResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            tag;
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON (_) {
        return {};
    },
    toJSON (_) {
        const obj = {};
        return obj;
    },
    fromPartial (_) {
        const message = createBasePublishIdentityUpdateResponse();
        return message;
    }
};
function createBaseGetIdentityUpdatesRequest() {
    return {
        requests: []
    };
}
const GetIdentityUpdatesRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.requests)GetIdentityUpdatesRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.requests.push(GetIdentityUpdatesRequest_Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests) ? object.requests.map((e)=>GetIdentityUpdatesRequest_Request.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.requests) obj.requests = message.requests.map((e)=>e ? GetIdentityUpdatesRequest_Request.toJSON(e) : undefined);
        else obj.requests = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetIdentityUpdatesRequest();
        message.requests = ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e)=>GetIdentityUpdatesRequest_Request.fromPartial(e))) || [];
        return message;
    }
};
function createBaseGetIdentityUpdatesRequest_Request() {
    return {
        inboxId: "",
        sequenceId: (0, _longDefault.default).UZERO
    };
}
const GetIdentityUpdatesRequest_Request = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.inboxId !== "") writer.uint32(10).string(message.inboxId);
        if (!message.sequenceId.isZero()) writer.uint32(16).uint64(message.sequenceId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesRequest_Request();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.inboxId = reader.string();
                    break;
                case 2:
                    message.sequenceId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : "",
            sequenceId: isSet(object.sequenceId) ? (0, _longDefault.default).fromValue(object.sequenceId) : (0, _longDefault.default).UZERO
        };
    },
    toJSON (message) {
        const obj = {};
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        message.sequenceId !== undefined && (obj.sequenceId = (message.sequenceId || (0, _longDefault.default).UZERO).toString());
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetIdentityUpdatesRequest_Request();
        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : "";
        message.sequenceId = object.sequenceId !== undefined && object.sequenceId !== null ? (0, _longDefault.default).fromValue(object.sequenceId) : (0, _longDefault.default).UZERO;
        return message;
    }
};
function createBaseGetIdentityUpdatesResponse() {
    return {
        responses: []
    };
}
const GetIdentityUpdatesResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.responses)GetIdentityUpdatesResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.responses.push(GetIdentityUpdatesResponse_Response.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses) ? object.responses.map((e)=>GetIdentityUpdatesResponse_Response.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.responses) obj.responses = message.responses.map((e)=>e ? GetIdentityUpdatesResponse_Response.toJSON(e) : undefined);
        else obj.responses = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetIdentityUpdatesResponse();
        message.responses = ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e)=>GetIdentityUpdatesResponse_Response.fromPartial(e))) || [];
        return message;
    }
};
function createBaseGetIdentityUpdatesResponse_IdentityUpdateLog() {
    return {
        sequenceId: (0, _longDefault.default).UZERO,
        serverTimestampNs: (0, _longDefault.default).UZERO,
        update: undefined
    };
}
const GetIdentityUpdatesResponse_IdentityUpdateLog = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (!message.sequenceId.isZero()) writer.uint32(8).uint64(message.sequenceId);
        if (!message.serverTimestampNs.isZero()) writer.uint32(16).uint64(message.serverTimestampNs);
        if (message.update !== undefined) (0, _associationPb.IdentityUpdate).encode(message.update, writer.uint32(26).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesResponse_IdentityUpdateLog();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.sequenceId = reader.uint64();
                    break;
                case 2:
                    message.serverTimestampNs = reader.uint64();
                    break;
                case 3:
                    message.update = (0, _associationPb.IdentityUpdate).decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            sequenceId: isSet(object.sequenceId) ? (0, _longDefault.default).fromValue(object.sequenceId) : (0, _longDefault.default).UZERO,
            serverTimestampNs: isSet(object.serverTimestampNs) ? (0, _longDefault.default).fromValue(object.serverTimestampNs) : (0, _longDefault.default).UZERO,
            update: isSet(object.update) ? (0, _associationPb.IdentityUpdate).fromJSON(object.update) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.sequenceId !== undefined && (obj.sequenceId = (message.sequenceId || (0, _longDefault.default).UZERO).toString());
        message.serverTimestampNs !== undefined && (obj.serverTimestampNs = (message.serverTimestampNs || (0, _longDefault.default).UZERO).toString());
        message.update !== undefined && (obj.update = message.update ? (0, _associationPb.IdentityUpdate).toJSON(message.update) : undefined);
        return obj;
    },
    fromPartial (object) {
        const message = createBaseGetIdentityUpdatesResponse_IdentityUpdateLog();
        message.sequenceId = object.sequenceId !== undefined && object.sequenceId !== null ? (0, _longDefault.default).fromValue(object.sequenceId) : (0, _longDefault.default).UZERO;
        message.serverTimestampNs = object.serverTimestampNs !== undefined && object.serverTimestampNs !== null ? (0, _longDefault.default).fromValue(object.serverTimestampNs) : (0, _longDefault.default).UZERO;
        message.update = object.update !== undefined && object.update !== null ? (0, _associationPb.IdentityUpdate).fromPartial(object.update) : undefined;
        return message;
    }
};
function createBaseGetIdentityUpdatesResponse_Response() {
    return {
        inboxId: "",
        updates: []
    };
}
const GetIdentityUpdatesResponse_Response = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.inboxId !== "") writer.uint32(10).string(message.inboxId);
        for (const v of message.updates)GetIdentityUpdatesResponse_IdentityUpdateLog.encode(v, writer.uint32(18).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetIdentityUpdatesResponse_Response();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.inboxId = reader.string();
                    break;
                case 2:
                    message.updates.push(GetIdentityUpdatesResponse_IdentityUpdateLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : "",
            updates: Array.isArray(object === null || object === void 0 ? void 0 : object.updates) ? object.updates.map((e)=>GetIdentityUpdatesResponse_IdentityUpdateLog.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        if (message.updates) obj.updates = message.updates.map((e)=>e ? GetIdentityUpdatesResponse_IdentityUpdateLog.toJSON(e) : undefined);
        else obj.updates = [];
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseGetIdentityUpdatesResponse_Response();
        message.inboxId = (_a = object.inboxId) !== null && _a !== void 0 ? _a : "";
        message.updates = ((_b = object.updates) === null || _b === void 0 ? void 0 : _b.map((e)=>GetIdentityUpdatesResponse_IdentityUpdateLog.fromPartial(e))) || [];
        return message;
    }
};
function createBaseGetInboxIdsRequest() {
    return {
        requests: []
    };
}
const GetInboxIdsRequest = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.requests)GetInboxIdsRequest_Request.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetInboxIdsRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.requests.push(GetInboxIdsRequest_Request.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            requests: Array.isArray(object === null || object === void 0 ? void 0 : object.requests) ? object.requests.map((e)=>GetInboxIdsRequest_Request.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.requests) obj.requests = message.requests.map((e)=>e ? GetInboxIdsRequest_Request.toJSON(e) : undefined);
        else obj.requests = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetInboxIdsRequest();
        message.requests = ((_a = object.requests) === null || _a === void 0 ? void 0 : _a.map((e)=>GetInboxIdsRequest_Request.fromPartial(e))) || [];
        return message;
    }
};
function createBaseGetInboxIdsRequest_Request() {
    return {
        address: ""
    };
}
const GetInboxIdsRequest_Request = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetInboxIdsRequest_Request();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            address: isSet(object.address) ? String(object.address) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetInboxIdsRequest_Request();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        return message;
    }
};
function createBaseGetInboxIdsResponse() {
    return {
        responses: []
    };
}
const GetInboxIdsResponse = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        for (const v of message.responses)GetInboxIdsResponse_Response.encode(v, writer.uint32(10).fork()).ldelim();
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetInboxIdsResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.responses.push(GetInboxIdsResponse_Response.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            responses: Array.isArray(object === null || object === void 0 ? void 0 : object.responses) ? object.responses.map((e)=>GetInboxIdsResponse_Response.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.responses) obj.responses = message.responses.map((e)=>e ? GetInboxIdsResponse_Response.toJSON(e) : undefined);
        else obj.responses = [];
        return obj;
    },
    fromPartial (object) {
        var _a;
        const message = createBaseGetInboxIdsResponse();
        message.responses = ((_a = object.responses) === null || _a === void 0 ? void 0 : _a.map((e)=>GetInboxIdsResponse_Response.fromPartial(e))) || [];
        return message;
    }
};
function createBaseGetInboxIdsResponse_Response() {
    return {
        address: "",
        inboxId: undefined
    };
}
const GetInboxIdsResponse_Response = {
    encode (message, writer = (0, _minimalDefault.default).Writer.create()) {
        if (message.address !== "") writer.uint32(10).string(message.address);
        if (message.inboxId !== undefined) writer.uint32(18).string(message.inboxId);
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof (0, _minimalDefault.default).Reader ? input : new (0, _minimalDefault.default).Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetInboxIdsResponse_Response();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    message.inboxId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON (object) {
        return {
            address: isSet(object.address) ? String(object.address) : "",
            inboxId: isSet(object.inboxId) ? String(object.inboxId) : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        message.address !== undefined && (obj.address = message.address);
        message.inboxId !== undefined && (obj.inboxId = message.inboxId);
        return obj;
    },
    fromPartial (object) {
        var _a, _b;
        const message = createBaseGetInboxIdsResponse_Response();
        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : "";
        message.inboxId = (_b = object.inboxId) !== null && _b !== void 0 ? _b : undefined;
        return message;
    }
};
class IdentityApiClientImpl {
    constructor(rpc){
        this.rpc = rpc;
        this.PublishIdentityUpdate = this.PublishIdentityUpdate.bind(this);
        this.GetIdentityUpdates = this.GetIdentityUpdates.bind(this);
        this.GetInboxIds = this.GetInboxIds.bind(this);
        this.VerifySmartContractWalletSignatures = this.VerifySmartContractWalletSignatures.bind(this);
    }
    PublishIdentityUpdate(request) {
        const data = PublishIdentityUpdateRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.identity.api.v1.IdentityApi", "PublishIdentityUpdate", data);
        return promise.then((data)=>PublishIdentityUpdateResponse.decode(new (0, _minimalDefault.default).Reader(data)));
    }
    GetIdentityUpdates(request) {
        const data = GetIdentityUpdatesRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.identity.api.v1.IdentityApi", "GetIdentityUpdates", data);
        return promise.then((data)=>GetIdentityUpdatesResponse.decode(new (0, _minimalDefault.default).Reader(data)));
    }
    GetInboxIds(request) {
        const data = GetInboxIdsRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.identity.api.v1.IdentityApi", "GetInboxIds", data);
        return promise.then((data)=>GetInboxIdsResponse.decode(new (0, _minimalDefault.default).Reader(data)));
    }
    VerifySmartContractWalletSignatures(request) {
        const data = VerifySmartContractWalletSignaturesRequest.encode(request).finish();
        const promise = this.rpc.request("xmtp.identity.api.v1.IdentityApi", "VerifySmartContractWalletSignatures", data);
        return promise.then((data)=>VerifySmartContractWalletSignaturesResponse.decode(new (0, _minimalDefault.default).Reader(data)));
    }
}
var globalThis = (()=>{
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for(let i = 0; i < bin.length; ++i)arr[i] = bin.charCodeAt(i);
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) return globalThis.Buffer.from(arr).toString("base64");
    else {
        const bin = [];
        arr.forEach((byte)=>{
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if ((0, _minimalDefault.default).util.Long !== (0, _longDefault.default)) {
    (0, _minimalDefault.default).util.Long = (0, _longDefault.default);
    (0, _minimalDefault.default).configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}

},{"long":"3JDQT","../../associations/association.pb":"lXnXi","protobufjs/minimal":"kgguT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"78Gvp":[function(require,module,exports) {
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CURVE", ()=>CURVE);
parcelHelpers.export(exports, "Point", ()=>Point);
parcelHelpers.export(exports, "Signature", ()=>Signature);
parcelHelpers.export(exports, "getPublicKey", ()=>getPublicKey);
parcelHelpers.export(exports, "recoverPublicKey", ()=>recoverPublicKey);
parcelHelpers.export(exports, "getSharedSecret", ()=>getSharedSecret);
parcelHelpers.export(exports, "sign", ()=>sign);
parcelHelpers.export(exports, "signSync", ()=>signSync);
parcelHelpers.export(exports, "verify", ()=>verify);
parcelHelpers.export(exports, "schnorr", ()=>schnorr);
parcelHelpers.export(exports, "utils", ()=>utils);
var _crypto = require("crypto");
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _3n = BigInt(3);
const _8n = BigInt(8);
const CURVE = Object.freeze({
    a: _0n,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: _1n,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
});
const divNearest = (a, b)=>(a + b / _2n) / b;
const endo = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar (k) {
        const { n } = CURVE;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod(k - c1 * a1 - c2 * a2, n);
        let k2 = mod(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg) k1 = n - k1;
        if (k2neg) k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
        return {
            k1neg,
            k1,
            k2neg,
            k2
        };
    }
};
const fieldLen = 32;
const groupLen = 32;
const hashLen = 32;
const compressedLen = fieldLen + 1;
const uncompressedLen = 2 * fieldLen + 1;
function weierstrass(x) {
    const { a, b } = CURVE;
    const x2 = mod(x * x);
    const x3 = mod(x2 * x);
    return mod(x3 + a * x + b);
}
const USE_ENDOMORPHISM = CURVE.a === _0n;
class ShaError extends Error {
    constructor(message){
        super(message);
    }
}
function assertJacPoint(other) {
    if (!(other instanceof JacobianPoint)) throw new TypeError("JacobianPoint expected");
}
class JacobianPoint {
    constructor(x, y, z){
        this.x = x;
        this.y = y;
        this.z = z;
    }
    static fromAffine(p) {
        if (!(p instanceof Point)) throw new TypeError("JacobianPoint#fromAffine: expected Point");
        if (p.equals(Point.ZERO)) return JacobianPoint.ZERO;
        return new JacobianPoint(p.x, p.y, _1n);
    }
    static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p)=>p.z));
        return points.map((p, i)=>p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
    }
    equals(other) {
        assertJacPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const Z1Z1 = mod(Z1 * Z1);
        const Z2Z2 = mod(Z2 * Z2);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        return U1 === U2 && S1 === S2;
    }
    negate() {
        return new JacobianPoint(this.x, mod(-this.y), this.z);
    }
    double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const A = mod(X1 * X1);
        const B = mod(Y1 * Y1);
        const C = mod(B * B);
        const x1b = X1 + B;
        const D = mod(_2n * (mod(x1b * x1b) - A - C));
        const E = mod(_3n * A);
        const F = mod(E * E);
        const X3 = mod(F - _2n * D);
        const Y3 = mod(E * (D - X3) - _8n * C);
        const Z3 = mod(_2n * Y1 * Z1);
        return new JacobianPoint(X3, Y3, Z3);
    }
    add(other) {
        assertJacPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        if (X2 === _0n || Y2 === _0n) return this;
        if (X1 === _0n || Y1 === _0n) return other;
        const Z1Z1 = mod(Z1 * Z1);
        const Z2Z2 = mod(Z2 * Z2);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        const H = mod(U2 - U1);
        const r = mod(S2 - S1);
        if (H === _0n) {
            if (r === _0n) return this.double();
            else return JacobianPoint.ZERO;
        }
        const HH = mod(H * H);
        const HHH = mod(H * HH);
        const V = mod(U1 * HH);
        const X3 = mod(r * r - HHH - _2n * V);
        const Y3 = mod(r * (V - X3) - S1 * HHH);
        const Z3 = mod(Z1 * Z2 * H);
        return new JacobianPoint(X3, Y3, Z3);
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiplyUnsafe(scalar) {
        const P0 = JacobianPoint.ZERO;
        if (typeof scalar === "bigint" && scalar === _0n) return P0;
        let n = normalizeScalar(scalar);
        if (n === _1n) return this;
        if (!USE_ENDOMORPHISM) {
            let p = P0;
            let d = this;
            while(n > _0n){
                if (n & _1n) p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        }
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let k1p = P0;
        let k2p = P0;
        let d = this;
        while(k1 > _0n || k2 > _0n){
            if (k1 & _1n) k1p = k1p.add(d);
            if (k2 & _1n) k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
        }
        if (k1neg) k1p = k1p.negate();
        if (k2neg) k2p = k2p.negate();
        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
        return k1p.add(k2p);
    }
    precomputeWindow(W) {
        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
        const points = [];
        let p = this;
        let base = p;
        for(let window = 0; window < windows; window++){
            base = p;
            points.push(base);
            for(let i = 1; i < 2 ** (W - 1); i++){
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;
        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W) throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
            precomputes = this.precomputeWindow(W);
            if (affinePoint && W !== 1) {
                precomputes = JacobianPoint.normalizeZ(precomputes);
                pointPrecomputes.set(affinePoint, precomputes);
            }
        }
        let p = JacobianPoint.ZERO;
        let f = JacobianPoint.BASE;
        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for(let window = 0; window < windows; window++){
            const offset = window * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            else p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
        return {
            p,
            f
        };
    }
    multiply(scalar, affinePoint) {
        let n = normalizeScalar(scalar);
        let point;
        let fake;
        if (USE_ENDOMORPHISM) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
            k1p = constTimeNegate(k1neg, k1p);
            k2p = constTimeNegate(k2neg, k2p);
            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
        } else {
            const { p, f } = this.wNAF(n, affinePoint);
            point = p;
            fake = f;
        }
        return JacobianPoint.normalizeZ([
            point,
            fake
        ])[0];
    }
    toAffine(invZ) {
        const { x, y, z } = this;
        const is0 = this.equals(JacobianPoint.ZERO);
        if (invZ == null) invZ = is0 ? _8n : invert(z);
        const iz1 = invZ;
        const iz2 = mod(iz1 * iz1);
        const iz3 = mod(iz2 * iz1);
        const ax = mod(x * iz2);
        const ay = mod(y * iz3);
        const zz = mod(z * iz1);
        if (is0) return Point.ZERO;
        if (zz !== _1n) throw new Error("invZ was invalid");
        return new Point(ax, ay);
    }
}
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
function constTimeNegate(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
const pointPrecomputes = new WeakMap();
class Point {
    constructor(x, y){
        this.x = x;
        this.y = y;
    }
    _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
    }
    hasEvenY() {
        return this.y % _2n === _0n;
    }
    static fromCompressedHex(bytes) {
        const isShort = bytes.length === 32;
        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
        if (!isValidFieldElement(x)) throw new Error("Point is not on curve");
        const y2 = weierstrass(x);
        let y = sqrtMod(y2);
        const isYOdd = (y & _1n) === _1n;
        if (isShort) {
            if (isYOdd) y = mod(-y);
        } else {
            const isFirstByteOdd = (bytes[0] & 1) === 1;
            if (isFirstByteOdd !== isYOdd) y = mod(-y);
        }
        const point = new Point(x, y);
        point.assertValidity();
        return point;
    }
    static fromUncompressedHex(bytes) {
        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));
        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));
        const point = new Point(x, y);
        point.assertValidity();
        return point;
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex);
        const len = bytes.length;
        const header = bytes[0];
        if (len === fieldLen) return this.fromCompressedHex(bytes);
        if (len === compressedLen && (header === 0x02 || header === 0x03)) return this.fromCompressedHex(bytes);
        if (len === uncompressedLen && header === 0x04) return this.fromUncompressedHex(bytes);
        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
    }
    static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normalizePrivateKey(privateKey));
    }
    static fromSignature(msgHash, signature, recovery) {
        const { r, s } = normalizeSignature(signature);
        if (![
            0,
            1,
            2,
            3
        ].includes(recovery)) throw new Error("Cannot recover: invalid recovery bit");
        const h = truncateHash(ensureBytes(msgHash));
        const { n } = CURVE;
        const radj = recovery === 2 || recovery === 3 ? r + n : r;
        const rinv = invert(radj, n);
        const u1 = mod(-h * rinv, n);
        const u2 = mod(s * rinv, n);
        const prefix = recovery & 1 ? "03" : "02";
        const R = Point.fromHex(prefix + numTo32bStr(radj));
        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q) throw new Error("Cannot recover signature: point at infinify");
        Q.assertValidity();
        return Q;
    }
    toRawBytes(isCompressed = false) {
        return hexToBytes(this.toHex(isCompressed));
    }
    toHex(isCompressed = false) {
        const x = numTo32bStr(this.x);
        if (isCompressed) {
            const prefix = this.hasEvenY() ? "02" : "03";
            return `${prefix}${x}`;
        } else return `04${x}${numTo32bStr(this.y)}`;
    }
    toHexX() {
        return this.toHex(true).slice(2);
    }
    toRawX() {
        return this.toRawBytes(true).slice(1);
    }
    assertValidity() {
        const msg = "Point is not on elliptic curve";
        const { x, y } = this;
        if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);
        const left = mod(y * y);
        const right = weierstrass(x);
        if (mod(left - right) !== _0n) throw new Error(msg);
    }
    equals(other) {
        return this.x === other.x && this.y === other.y;
    }
    negate() {
        return new Point(this.x, mod(-this.y));
    }
    double() {
        return JacobianPoint.fromAffine(this).double().toAffine();
    }
    add(other) {
        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiply(scalar) {
        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
    multiplyAndAddUnsafe(Q, a, b) {
        const P = JacobianPoint.fromAffine(this);
        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
        const sum = aP.add(bQ);
        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
    }
}
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _0n);
function sliceDER(s) {
    return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
}
function parseDERInt(data) {
    if (data.length < 2 || data[0] !== 0x02) throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len) throw new Error(`Invalid signature integer: wrong length`);
    if (res[0] === 0x00 && res[1] <= 0x7f) throw new Error("Invalid signature integer: trailing length");
    return {
        data: bytesToNumber(res),
        left: data.subarray(len + 2)
    };
}
function parseDERSignature(data) {
    if (data.length < 2 || data[0] != 0x30) throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
    if (data[1] !== data.length - 2) throw new Error("Invalid signature: incorrect length");
    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
    if (rBytesLeft.length) throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
    return {
        r,
        s
    };
}
class Signature {
    constructor(r, s){
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromCompact(hex) {
        const arr = hex instanceof Uint8Array;
        const name = "Signature.fromCompact";
        if (typeof hex !== "string" && !arr) throw new TypeError(`${name}: Expected string or Uint8Array`);
        const str = arr ? bytesToHex(hex) : hex;
        if (str.length !== 128) throw new Error(`${name}: Expected 64-byte hex`);
        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
    }
    static fromDER(hex) {
        const arr = hex instanceof Uint8Array;
        if (typeof hex !== "string" && !arr) throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
        return new Signature(r, s);
    }
    static fromHex(hex) {
        return this.fromDER(hex);
    }
    assertValidity() {
        const { r, s } = this;
        if (!isWithinCurveOrder(r)) throw new Error("Invalid Signature: r must be 0 < r < n");
        if (!isWithinCurveOrder(s)) throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
        const HALF = CURVE.n >> _1n;
        return this.s > HALF;
    }
    normalizeS() {
        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;
    }
    toDERRawBytes() {
        return hexToBytes(this.toDERHex());
    }
    toDERHex() {
        const sHex = sliceDER(numberToHexUnpadded(this.s));
        const rHex = sliceDER(numberToHexUnpadded(this.r));
        const sHexL = sHex.length / 2;
        const rHexL = rHex.length / 2;
        const sLen = numberToHexUnpadded(sHexL);
        const rLen = numberToHexUnpadded(rHexL);
        const length = numberToHexUnpadded(rHexL + sHexL + 4);
        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
    }
    toRawBytes() {
        return this.toDERRawBytes();
    }
    toHex() {
        return this.toDERHex();
    }
    toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
}
function concatBytes(...arrays) {
    if (!arrays.every((b)=>b instanceof Uint8Array)) throw new Error("Uint8Array list expected");
    if (arrays.length === 1) return arrays[0];
    const length = arrays.reduce((a, arr)=>a + arr.length, 0);
    const result = new Uint8Array(length);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
const hexes = Array.from({
    length: 256
}, (v, i)=>i.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array)) throw new Error("Expected Uint8Array");
    let hex = "";
    for(let i = 0; i < uint8a.length; i++)hex += hexes[uint8a[i]];
    return hex;
}
const POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function numTo32bStr(num) {
    if (typeof num !== "bigint") throw new Error("Expected bigint");
    if (!(_0n <= num && num < POW_2_256)) throw new Error("Expected number 0 <= n < 2^256");
    return num.toString(16).padStart(64, "0");
}
function numTo32b(num) {
    const b = hexToBytes(numTo32bStr(num));
    if (b.length !== 32) throw new Error("Error: expected 32 bytes");
    return b;
}
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== "string") throw new TypeError("hexToNumber: expected string, got " + typeof hex);
    return BigInt(`0x${hex}`);
}
function hexToBytes(hex) {
    if (typeof hex !== "string") throw new TypeError("hexToBytes: expected string, got " + typeof hex);
    if (hex.length % 2) throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
    const array = new Uint8Array(hex.length / 2);
    for(let i = 0; i < array.length; i++){
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0) throw new Error("Invalid byte sequence");
        array[i] = byte;
    }
    return array;
}
function bytesToNumber(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function ensureBytes(hex) {
    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
}
function normalizeScalar(num) {
    if (typeof num === "number" && Number.isSafeInteger(num) && num > 0) return BigInt(num);
    if (typeof num === "bigint" && isWithinCurveOrder(num)) return num;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod(a, b = CURVE.P) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
function pow2(x, power) {
    const { P } = CURVE;
    let res = x;
    while(power-- > _0n){
        res *= res;
        res %= P;
    }
    return res;
}
function sqrtMod(x) {
    const { P } = CURVE;
    const _6n = BigInt(6);
    const _11n = BigInt(11);
    const _22n = BigInt(22);
    const _23n = BigInt(23);
    const _44n = BigInt(44);
    const _88n = BigInt(88);
    const b2 = x * x * x % P;
    const b3 = b2 * b2 * x % P;
    const b6 = pow2(b3, _3n) * b3 % P;
    const b9 = pow2(b6, _3n) * b3 % P;
    const b11 = pow2(b9, _2n) * b2 % P;
    const b22 = pow2(b11, _11n) * b11 % P;
    const b44 = pow2(b22, _22n) * b22 % P;
    const b88 = pow2(b44, _44n) * b44 % P;
    const b176 = pow2(b88, _88n) * b88 % P;
    const b220 = pow2(b176, _44n) * b44 % P;
    const b223 = pow2(b220, _3n) * b3 % P;
    const t1 = pow2(b223, _23n) * b22 % P;
    const t2 = pow2(t1, _6n) * b2 % P;
    const rt = pow2(t2, _2n);
    const xc = rt * rt % P;
    if (xc !== x) throw new Error("Cannot find square root");
    return rt;
}
function invert(number, modulo = CURVE.P) {
    if (number === _0n || modulo <= _0n) throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while(a !== _0n){
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n) throw new Error("invert: does not exist");
    return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
    const scratch = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i)=>{
        if (num === _0n) return acc;
        scratch[i] = acc;
        return mod(acc * num, p);
    }, _1n);
    const inverted = invert(lastMultiplied, p);
    nums.reduceRight((acc, num, i)=>{
        if (num === _0n) return acc;
        scratch[i] = mod(acc * scratch[i], p);
        return mod(acc * num, p);
    }, inverted);
    return scratch;
}
function bits2int_2(bytes) {
    const delta = bytes.length * 8 - groupLen * 8;
    const num = bytesToNumber(bytes);
    return delta > 0 ? num >> BigInt(delta) : num;
}
function truncateHash(hash, truncateOnly = false) {
    const h = bits2int_2(hash);
    if (truncateOnly) return h;
    const { n } = CURVE;
    return h >= n ? h - n : h;
}
let _sha256Sync;
let _hmacSha256Sync;
class HmacDrbg {
    constructor(hashLen, qByteLen){
        this.hashLen = hashLen;
        this.qByteLen = qByteLen;
        if (typeof hashLen !== "number" || hashLen < 2) throw new Error("hashLen must be a number");
        if (typeof qByteLen !== "number" || qByteLen < 2) throw new Error("qByteLen must be a number");
        this.v = new Uint8Array(hashLen).fill(1);
        this.k = new Uint8Array(hashLen).fill(0);
        this.counter = 0;
    }
    hmac(...values) {
        return utils.hmacSha256(this.k, ...values);
    }
    hmacSync(...values) {
        return _hmacSha256Sync(this.k, ...values);
    }
    checkSync() {
        if (typeof _hmacSha256Sync !== "function") throw new ShaError("hmacSha256Sync needs to be set");
    }
    incr() {
        if (this.counter >= 1000) throw new Error("Tried 1,000 k values for sign(), all were invalid");
        this.counter += 1;
    }
    async reseed(seed = new Uint8Array()) {
        this.k = await this.hmac(this.v, Uint8Array.from([
            0x00
        ]), seed);
        this.v = await this.hmac(this.v);
        if (seed.length === 0) return;
        this.k = await this.hmac(this.v, Uint8Array.from([
            0x01
        ]), seed);
        this.v = await this.hmac(this.v);
    }
    reseedSync(seed = new Uint8Array()) {
        this.checkSync();
        this.k = this.hmacSync(this.v, Uint8Array.from([
            0x00
        ]), seed);
        this.v = this.hmacSync(this.v);
        if (seed.length === 0) return;
        this.k = this.hmacSync(this.v, Uint8Array.from([
            0x01
        ]), seed);
        this.v = this.hmacSync(this.v);
    }
    async generate() {
        this.incr();
        let len = 0;
        const out = [];
        while(len < this.qByteLen){
            this.v = await this.hmac(this.v);
            const sl = this.v.slice();
            out.push(sl);
            len += this.v.length;
        }
        return concatBytes(...out);
    }
    generateSync() {
        this.checkSync();
        this.incr();
        let len = 0;
        const out = [];
        while(len < this.qByteLen){
            this.v = this.hmacSync(this.v);
            const sl = this.v.slice();
            out.push(sl);
            len += this.v.length;
        }
        return concatBytes(...out);
    }
}
function isWithinCurveOrder(num) {
    return _0n < num && num < CURVE.n;
}
function isValidFieldElement(num) {
    return _0n < num && num < CURVE.P;
}
function kmdToSig(kBytes, m, d, lowS = true) {
    const { n } = CURVE;
    const k = truncateHash(kBytes, true);
    if (!isWithinCurveOrder(k)) return;
    const kinv = invert(k, n);
    const q = Point.BASE.multiply(k);
    const r = mod(q.x, n);
    if (r === _0n) return;
    const s = mod(kinv * mod(m + d * r, n), n);
    if (s === _0n) return;
    let sig = new Signature(r, s);
    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
    if (lowS && sig.hasHighS()) {
        sig = sig.normalizeS();
        recovery ^= 1;
    }
    return {
        sig,
        recovery
    };
}
function normalizePrivateKey(key) {
    let num;
    if (typeof key === "bigint") num = key;
    else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) num = BigInt(key);
    else if (typeof key === "string") {
        if (key.length !== 2 * groupLen) throw new Error("Expected 32 bytes of private key");
        num = hexToNumber(key);
    } else if (key instanceof Uint8Array) {
        if (key.length !== groupLen) throw new Error("Expected 32 bytes of private key");
        num = bytesToNumber(key);
    } else throw new TypeError("Expected valid private key");
    if (!isWithinCurveOrder(num)) throw new Error("Expected private key: 0 < key < n");
    return num;
}
function normalizePublicKey(publicKey) {
    if (publicKey instanceof Point) {
        publicKey.assertValidity();
        return publicKey;
    } else return Point.fromHex(publicKey);
}
function normalizeSignature(signature) {
    if (signature instanceof Signature) {
        signature.assertValidity();
        return signature;
    }
    try {
        return Signature.fromDER(signature);
    } catch (error) {
        return Signature.fromCompact(signature);
    }
}
function getPublicKey(privateKey, isCompressed = false) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
}
function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr) return len === compressedLen || len === uncompressedLen;
    if (str) return len === compressedLen * 2 || len === uncompressedLen * 2;
    if (item instanceof Point) return true;
    return false;
}
function getSharedSecret(privateA, publicB, isCompressed = false) {
    if (isProbPub(privateA)) throw new TypeError("getSharedSecret: first arg must be private key");
    if (!isProbPub(publicB)) throw new TypeError("getSharedSecret: second arg must be public key");
    const b = normalizePublicKey(publicB);
    b.assertValidity();
    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
}
function bits2int(bytes) {
    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;
    return bytesToNumber(slice);
}
function bits2octets(bytes) {
    const z1 = bits2int(bytes);
    const z2 = mod(z1, CURVE.n);
    return int2octets(z2 < _0n ? z1 : z2);
}
function int2octets(num) {
    return numTo32b(num);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
    if (msgHash == null) throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
    const h1 = ensureBytes(msgHash);
    const d = normalizePrivateKey(privateKey);
    const seedArgs = [
        int2octets(d),
        bits2octets(h1)
    ];
    if (extraEntropy != null) {
        if (extraEntropy === true) extraEntropy = utils.randomBytes(fieldLen);
        const e = ensureBytes(extraEntropy);
        if (e.length !== fieldLen) throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
        seedArgs.push(e);
    }
    const seed = concatBytes(...seedArgs);
    const m = bits2int(h1);
    return {
        seed,
        m,
        d
    };
}
function finalizeSig(recSig, opts) {
    const { sig, recovery } = recSig;
    const { der, recovered } = Object.assign({
        canonical: true,
        der: true
    }, opts);
    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
    return recovered ? [
        hashed,
        recovery
    ] : hashed;
}
async function sign(msgHash, privKey, opts = {}) {
    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
    const drbg = new HmacDrbg(hashLen, groupLen);
    await drbg.reseed(seed);
    let sig;
    while(!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))await drbg.reseed();
    return finalizeSig(sig, opts);
}
function signSync(msgHash, privKey, opts = {}) {
    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
    const drbg = new HmacDrbg(hashLen, groupLen);
    drbg.reseedSync(seed);
    let sig;
    while(!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))drbg.reseedSync();
    return finalizeSig(sig, opts);
}
const vopts = {
    strict: true
};
function verify(signature, msgHash, publicKey, opts = vopts) {
    let sig;
    try {
        sig = normalizeSignature(signature);
        msgHash = ensureBytes(msgHash);
    } catch (error) {
        return false;
    }
    const { r, s } = sig;
    if (opts.strict && sig.hasHighS()) return false;
    const h = truncateHash(msgHash);
    let P;
    try {
        P = normalizePublicKey(publicKey);
    } catch (error) {
        return false;
    }
    const { n } = CURVE;
    const sinv = invert(s, n);
    const u1 = mod(h * sinv, n);
    const u2 = mod(r * sinv, n);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
    if (!R) return false;
    const v = mod(R.x, n);
    return v === r;
}
function schnorrChallengeFinalize(ch) {
    return mod(bytesToNumber(ch), CURVE.n);
}
class SchnorrSignature {
    constructor(r, s){
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex);
        if (bytes.length !== 64) throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);
        const r = bytesToNumber(bytes.subarray(0, 32));
        const s = bytesToNumber(bytes.subarray(32, 64));
        return new SchnorrSignature(r, s);
    }
    assertValidity() {
        const { r, s } = this;
        if (!isValidFieldElement(r) || !isWithinCurveOrder(s)) throw new Error("Invalid signature");
    }
    toHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
    toRawBytes() {
        return hexToBytes(this.toHex());
    }
}
function schnorrGetPublicKey(privateKey) {
    return Point.fromPrivateKey(privateKey).toRawX();
}
class InternalSchnorrSignature {
    constructor(message, privateKey, auxRand = utils.randomBytes()){
        if (message == null) throw new TypeError(`sign: Expected valid message, not "${message}"`);
        this.m = ensureBytes(message);
        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));
        this.px = x;
        this.d = scalar;
        this.rand = ensureBytes(auxRand);
        if (this.rand.length !== 32) throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(priv) {
        const point = Point.fromPrivateKey(priv);
        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;
        return {
            point,
            scalar,
            x: point.toRawX()
        };
    }
    initNonce(d, t0h) {
        return numTo32b(d ^ bytesToNumber(t0h));
    }
    finalizeNonce(k0h) {
        const k0 = mod(bytesToNumber(k0h), CURVE.n);
        if (k0 === _0n) throw new Error("sign: Creation of signature failed. k is zero");
        const { point: R, x: rx, scalar: k } = this.getScalar(k0);
        return {
            R,
            rx,
            k
        };
    }
    finalizeSig(R, k, e, d) {
        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();
    }
    error() {
        throw new Error("sign: Invalid signature produced");
    }
    async calc() {
        const { m, d, px, rand } = this;
        const tag = utils.taggedHash;
        const t = this.initNonce(d, await tag(TAGS.aux, rand));
        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));
        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));
        const sig = this.finalizeSig(R, k, e, d);
        if (!await schnorrVerify(sig, m, px)) this.error();
        return sig;
    }
    calcSync() {
        const { m, d, px, rand } = this;
        const tag = utils.taggedHashSync;
        const t = this.initNonce(d, tag(TAGS.aux, rand));
        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));
        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));
        const sig = this.finalizeSig(R, k, e, d);
        if (!schnorrVerifySync(sig, m, px)) this.error();
        return sig;
    }
}
async function schnorrSign(msg, privKey, auxRand) {
    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();
}
function schnorrSignSync(msg, privKey, auxRand) {
    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();
}
function initSchnorrVerify(signature, message, publicKey) {
    const raw = signature instanceof SchnorrSignature;
    const sig = raw ? signature : SchnorrSignature.fromHex(signature);
    if (raw) sig.assertValidity();
    return {
        ...sig,
        m: ensureBytes(message),
        P: normalizePublicKey(publicKey)
    };
}
function finalizeSchnorrVerify(r, P, s, e) {
    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));
    if (!R || !R.hasEvenY() || R.x !== r) return false;
    return true;
}
async function schnorrVerify(signature, message, publicKey) {
    try {
        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
        const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));
        return finalizeSchnorrVerify(r, P, s, e);
    } catch (error) {
        return false;
    }
}
function schnorrVerifySync(signature, message, publicKey) {
    try {
        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
        const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));
        return finalizeSchnorrVerify(r, P, s, e);
    } catch (error) {
        if (error instanceof ShaError) throw error;
        return false;
    }
}
const schnorr = {
    Signature: SchnorrSignature,
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    signSync: schnorrSignSync,
    verifySync: schnorrVerifySync
};
Point.BASE._setWindowSize(8);
const crypto = {
    node: _crypto,
    web: typeof self === "object" && "crypto" in self ? self.crypto : undefined
};
const TAGS = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
};
const TAGGED_HASH_PREFIXES = {};
const utils = {
    bytesToHex,
    hexToBytes,
    concatBytes,
    mod,
    invert,
    isValidPrivateKey (privateKey) {
        try {
            normalizePrivateKey(privateKey);
            return true;
        } catch (error) {
            return false;
        }
    },
    _bigintTo32Bytes: numTo32b,
    _normalizePrivateKey: normalizePrivateKey,
    hashToPrivateKey: (hash)=>{
        hash = ensureBytes(hash);
        const minLen = groupLen + 8;
        if (hash.length < minLen || hash.length > 1024) throw new Error(`Expected valid bytes of private key as per FIPS 186`);
        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;
        return numTo32b(num);
    },
    randomBytes: (bytesLength = 32)=>{
        if (crypto.web) return crypto.web.getRandomValues(new Uint8Array(bytesLength));
        else if (crypto.node) {
            const { randomBytes } = crypto.node;
            return Uint8Array.from(randomBytes(bytesLength));
        } else throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: ()=>utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),
    precompute (windowSize = 8, point = Point.BASE) {
        const cached = point === Point.BASE ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_3n);
        return cached;
    },
    sha256: async (...messages)=>{
        if (crypto.web) {
            const buffer = await crypto.web.subtle.digest("SHA-256", concatBytes(...messages));
            return new Uint8Array(buffer);
        } else if (crypto.node) {
            const { createHash } = crypto.node;
            const hash = createHash("sha256");
            messages.forEach((m)=>hash.update(m));
            return Uint8Array.from(hash.digest());
        } else throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (key, ...messages)=>{
        if (crypto.web) {
            const ckey = await crypto.web.subtle.importKey("raw", key, {
                name: "HMAC",
                hash: {
                    name: "SHA-256"
                }
            }, false, [
                "sign"
            ]);
            const message = concatBytes(...messages);
            const buffer = await crypto.web.subtle.sign("HMAC", ckey, message);
            return new Uint8Array(buffer);
        } else if (crypto.node) {
            const { createHmac } = crypto.node;
            const hash = createHmac("sha256", key);
            messages.forEach((m)=>hash.update(m));
            return Uint8Array.from(hash.digest());
        } else throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: undefined,
    hmacSha256Sync: undefined,
    taggedHash: async (tag, ...messages)=>{
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === undefined) {
            const tagH = await utils.sha256(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return utils.sha256(tagP, ...messages);
    },
    taggedHashSync: (tag, ...messages)=>{
        if (typeof _sha256Sync !== "function") throw new ShaError("sha256Sync is undefined, you need to set it");
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === undefined) {
            const tagH = _sha256Sync(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return _sha256Sync(tagP, ...messages);
    },
    _JacobianPoint: JacobianPoint
};
Object.defineProperties(utils, {
    sha256Sync: {
        configurable: false,
        get () {
            return _sha256Sync;
        },
        set (val) {
            if (!_sha256Sync) _sha256Sync = val;
        }
    },
    hmacSha256Sync: {
        configurable: false,
        get () {
            return _hmacSha256Sync;
        },
        set (val) {
            if (!_hmacSha256Sync) _hmacSha256Sync = val;
        }
    }
});

},{"crypto":"jhUEF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jhUEF":[function(require,module,exports) {
"use strict";

},{}],"7gLEX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CircularReferenceError", ()=>(0, _abitype.CircularReferenceError));
parcelHelpers.export(exports, "InvalidAbiParameterError", ()=>(0, _abitype.InvalidAbiParameterError));
parcelHelpers.export(exports, "InvalidAbiParametersError", ()=>(0, _abitype.InvalidAbiParametersError));
parcelHelpers.export(exports, "InvalidAbiItemError", ()=>(0, _abitype.InvalidAbiItemError));
parcelHelpers.export(exports, "InvalidAbiTypeParameterError", ()=>(0, _abitype.InvalidAbiTypeParameterError));
parcelHelpers.export(exports, "InvalidFunctionModifierError", ()=>(0, _abitype.InvalidFunctionModifierError));
parcelHelpers.export(exports, "InvalidModifierError", ()=>(0, _abitype.InvalidModifierError));
parcelHelpers.export(exports, "InvalidParameterError", ()=>(0, _abitype.InvalidParameterError));
parcelHelpers.export(exports, "InvalidParenthesisError", ()=>(0, _abitype.InvalidParenthesisError));
parcelHelpers.export(exports, "InvalidSignatureError", ()=>(0, _abitype.InvalidSignatureError));
parcelHelpers.export(exports, "InvalidStructSignatureError", ()=>(0, _abitype.InvalidStructSignatureError));
parcelHelpers.export(exports, "SolidityProtectedKeywordError", ()=>(0, _abitype.SolidityProtectedKeywordError));
parcelHelpers.export(exports, "UnknownTypeError", ()=>(0, _abitype.UnknownTypeError));
parcelHelpers.export(exports, "UnknownSignatureError", ()=>(0, _abitype.UnknownSignatureError));
parcelHelpers.export(exports, "parseAbi", ()=>(0, _abitype.parseAbi));
parcelHelpers.export(exports, "parseAbiItem", ()=>(0, _abitype.parseAbiItem));
parcelHelpers.export(exports, "parseAbiParameter", ()=>(0, _abitype.parseAbiParameter));
parcelHelpers.export(exports, "parseAbiParameters", ()=>(0, _abitype.parseAbiParameters));
parcelHelpers.export(exports, "getContract", ()=>(0, _getContractJs.getContract));
parcelHelpers.export(exports, "createClient", ()=>(0, _createClientJs.createClient));
parcelHelpers.export(exports, "custom", ()=>(0, _customJs.custom));
parcelHelpers.export(exports, "fallback", ()=>(0, _fallbackJs.fallback));
parcelHelpers.export(exports, "http", ()=>(0, _httpJs.http));
parcelHelpers.export(exports, "createPublicClient", ()=>(0, _createPublicClientJs.createPublicClient));
parcelHelpers.export(exports, "createTestClient", ()=>(0, _createTestClientJs.createTestClient));
parcelHelpers.export(exports, "publicActions", ()=>(0, _publicJs.publicActions));
parcelHelpers.export(exports, "testActions", ()=>(0, _testJs.testActions));
parcelHelpers.export(exports, "walletActions", ()=>(0, _walletJs.walletActions));
parcelHelpers.export(exports, "createTransport", ()=>(0, _createTransportJs.createTransport));
parcelHelpers.export(exports, "createWalletClient", ()=>(0, _createWalletClientJs.createWalletClient));
parcelHelpers.export(exports, "webSocket", ()=>(0, _webSocketJs.webSocket));
parcelHelpers.export(exports, "multicall3Abi", ()=>(0, _abisJs.multicall3Abi));
parcelHelpers.export(exports, "erc20Abi", ()=>(0, _abisJs.erc20Abi));
parcelHelpers.export(exports, "erc20Abi_bytes32", ()=>(0, _abisJs.erc20Abi_bytes32));
parcelHelpers.export(exports, "erc721Abi", ()=>(0, _abisJs.erc721Abi));
parcelHelpers.export(exports, "erc4626Abi", ()=>(0, _abisJs.erc4626Abi));
parcelHelpers.export(exports, "zeroAddress", ()=>(0, _addressJs.zeroAddress));
parcelHelpers.export(exports, "etherUnits", ()=>(0, _unitJs.etherUnits));
parcelHelpers.export(exports, "gweiUnits", ()=>(0, _unitJs.gweiUnits));
parcelHelpers.export(exports, "weiUnits", ()=>(0, _unitJs.weiUnits));
parcelHelpers.export(exports, "maxInt8", ()=>(0, _numberJs.maxInt8));
parcelHelpers.export(exports, "maxInt16", ()=>(0, _numberJs.maxInt16));
parcelHelpers.export(exports, "maxInt24", ()=>(0, _numberJs.maxInt24));
parcelHelpers.export(exports, "maxInt32", ()=>(0, _numberJs.maxInt32));
parcelHelpers.export(exports, "maxInt40", ()=>(0, _numberJs.maxInt40));
parcelHelpers.export(exports, "maxInt48", ()=>(0, _numberJs.maxInt48));
parcelHelpers.export(exports, "maxInt56", ()=>(0, _numberJs.maxInt56));
parcelHelpers.export(exports, "maxInt64", ()=>(0, _numberJs.maxInt64));
parcelHelpers.export(exports, "maxInt72", ()=>(0, _numberJs.maxInt72));
parcelHelpers.export(exports, "maxInt80", ()=>(0, _numberJs.maxInt80));
parcelHelpers.export(exports, "maxInt88", ()=>(0, _numberJs.maxInt88));
parcelHelpers.export(exports, "maxInt96", ()=>(0, _numberJs.maxInt96));
parcelHelpers.export(exports, "maxInt104", ()=>(0, _numberJs.maxInt104));
parcelHelpers.export(exports, "maxInt112", ()=>(0, _numberJs.maxInt112));
parcelHelpers.export(exports, "maxInt120", ()=>(0, _numberJs.maxInt120));
parcelHelpers.export(exports, "maxInt128", ()=>(0, _numberJs.maxInt128));
parcelHelpers.export(exports, "maxInt136", ()=>(0, _numberJs.maxInt136));
parcelHelpers.export(exports, "maxInt144", ()=>(0, _numberJs.maxInt144));
parcelHelpers.export(exports, "maxInt152", ()=>(0, _numberJs.maxInt152));
parcelHelpers.export(exports, "maxInt160", ()=>(0, _numberJs.maxInt160));
parcelHelpers.export(exports, "maxInt168", ()=>(0, _numberJs.maxInt168));
parcelHelpers.export(exports, "maxInt176", ()=>(0, _numberJs.maxInt176));
parcelHelpers.export(exports, "maxInt184", ()=>(0, _numberJs.maxInt184));
parcelHelpers.export(exports, "maxInt192", ()=>(0, _numberJs.maxInt192));
parcelHelpers.export(exports, "maxInt200", ()=>(0, _numberJs.maxInt200));
parcelHelpers.export(exports, "maxInt208", ()=>(0, _numberJs.maxInt208));
parcelHelpers.export(exports, "maxInt216", ()=>(0, _numberJs.maxInt216));
parcelHelpers.export(exports, "maxInt224", ()=>(0, _numberJs.maxInt224));
parcelHelpers.export(exports, "maxInt232", ()=>(0, _numberJs.maxInt232));
parcelHelpers.export(exports, "maxInt240", ()=>(0, _numberJs.maxInt240));
parcelHelpers.export(exports, "maxInt248", ()=>(0, _numberJs.maxInt248));
parcelHelpers.export(exports, "maxInt256", ()=>(0, _numberJs.maxInt256));
parcelHelpers.export(exports, "maxUint8", ()=>(0, _numberJs.maxUint8));
parcelHelpers.export(exports, "maxUint16", ()=>(0, _numberJs.maxUint16));
parcelHelpers.export(exports, "maxUint24", ()=>(0, _numberJs.maxUint24));
parcelHelpers.export(exports, "maxUint32", ()=>(0, _numberJs.maxUint32));
parcelHelpers.export(exports, "maxUint40", ()=>(0, _numberJs.maxUint40));
parcelHelpers.export(exports, "maxUint48", ()=>(0, _numberJs.maxUint48));
parcelHelpers.export(exports, "maxUint56", ()=>(0, _numberJs.maxUint56));
parcelHelpers.export(exports, "maxUint64", ()=>(0, _numberJs.maxUint64));
parcelHelpers.export(exports, "maxUint72", ()=>(0, _numberJs.maxUint72));
parcelHelpers.export(exports, "maxUint80", ()=>(0, _numberJs.maxUint80));
parcelHelpers.export(exports, "maxUint88", ()=>(0, _numberJs.maxUint88));
parcelHelpers.export(exports, "maxUint96", ()=>(0, _numberJs.maxUint96));
parcelHelpers.export(exports, "maxUint104", ()=>(0, _numberJs.maxUint104));
parcelHelpers.export(exports, "maxUint112", ()=>(0, _numberJs.maxUint112));
parcelHelpers.export(exports, "maxUint120", ()=>(0, _numberJs.maxUint120));
parcelHelpers.export(exports, "maxUint128", ()=>(0, _numberJs.maxUint128));
parcelHelpers.export(exports, "maxUint136", ()=>(0, _numberJs.maxUint136));
parcelHelpers.export(exports, "maxUint144", ()=>(0, _numberJs.maxUint144));
parcelHelpers.export(exports, "maxUint152", ()=>(0, _numberJs.maxUint152));
parcelHelpers.export(exports, "maxUint160", ()=>(0, _numberJs.maxUint160));
parcelHelpers.export(exports, "maxUint168", ()=>(0, _numberJs.maxUint168));
parcelHelpers.export(exports, "maxUint176", ()=>(0, _numberJs.maxUint176));
parcelHelpers.export(exports, "maxUint184", ()=>(0, _numberJs.maxUint184));
parcelHelpers.export(exports, "maxUint192", ()=>(0, _numberJs.maxUint192));
parcelHelpers.export(exports, "maxUint200", ()=>(0, _numberJs.maxUint200));
parcelHelpers.export(exports, "maxUint208", ()=>(0, _numberJs.maxUint208));
parcelHelpers.export(exports, "maxUint216", ()=>(0, _numberJs.maxUint216));
parcelHelpers.export(exports, "maxUint224", ()=>(0, _numberJs.maxUint224));
parcelHelpers.export(exports, "maxUint232", ()=>(0, _numberJs.maxUint232));
parcelHelpers.export(exports, "maxUint240", ()=>(0, _numberJs.maxUint240));
parcelHelpers.export(exports, "maxUint248", ()=>(0, _numberJs.maxUint248));
parcelHelpers.export(exports, "maxUint256", ()=>(0, _numberJs.maxUint256));
parcelHelpers.export(exports, "minInt8", ()=>(0, _numberJs.minInt8));
parcelHelpers.export(exports, "minInt16", ()=>(0, _numberJs.minInt16));
parcelHelpers.export(exports, "minInt24", ()=>(0, _numberJs.minInt24));
parcelHelpers.export(exports, "minInt32", ()=>(0, _numberJs.minInt32));
parcelHelpers.export(exports, "minInt40", ()=>(0, _numberJs.minInt40));
parcelHelpers.export(exports, "minInt48", ()=>(0, _numberJs.minInt48));
parcelHelpers.export(exports, "minInt56", ()=>(0, _numberJs.minInt56));
parcelHelpers.export(exports, "minInt64", ()=>(0, _numberJs.minInt64));
parcelHelpers.export(exports, "minInt72", ()=>(0, _numberJs.minInt72));
parcelHelpers.export(exports, "minInt80", ()=>(0, _numberJs.minInt80));
parcelHelpers.export(exports, "minInt88", ()=>(0, _numberJs.minInt88));
parcelHelpers.export(exports, "minInt96", ()=>(0, _numberJs.minInt96));
parcelHelpers.export(exports, "minInt104", ()=>(0, _numberJs.minInt104));
parcelHelpers.export(exports, "minInt112", ()=>(0, _numberJs.minInt112));
parcelHelpers.export(exports, "minInt120", ()=>(0, _numberJs.minInt120));
parcelHelpers.export(exports, "minInt128", ()=>(0, _numberJs.minInt128));
parcelHelpers.export(exports, "minInt136", ()=>(0, _numberJs.minInt136));
parcelHelpers.export(exports, "minInt144", ()=>(0, _numberJs.minInt144));
parcelHelpers.export(exports, "minInt152", ()=>(0, _numberJs.minInt152));
parcelHelpers.export(exports, "minInt160", ()=>(0, _numberJs.minInt160));
parcelHelpers.export(exports, "minInt168", ()=>(0, _numberJs.minInt168));
parcelHelpers.export(exports, "minInt176", ()=>(0, _numberJs.minInt176));
parcelHelpers.export(exports, "minInt184", ()=>(0, _numberJs.minInt184));
parcelHelpers.export(exports, "minInt192", ()=>(0, _numberJs.minInt192));
parcelHelpers.export(exports, "minInt200", ()=>(0, _numberJs.minInt200));
parcelHelpers.export(exports, "minInt208", ()=>(0, _numberJs.minInt208));
parcelHelpers.export(exports, "minInt216", ()=>(0, _numberJs.minInt216));
parcelHelpers.export(exports, "minInt224", ()=>(0, _numberJs.minInt224));
parcelHelpers.export(exports, "minInt232", ()=>(0, _numberJs.minInt232));
parcelHelpers.export(exports, "minInt240", ()=>(0, _numberJs.minInt240));
parcelHelpers.export(exports, "minInt248", ()=>(0, _numberJs.minInt248));
parcelHelpers.export(exports, "minInt256", ()=>(0, _numberJs.minInt256));
parcelHelpers.export(exports, "zeroHash", ()=>(0, _bytesJs.zeroHash));
parcelHelpers.export(exports, "presignMessagePrefix", ()=>(0, _stringsJs.presignMessagePrefix));
parcelHelpers.export(exports, "AbiConstructorNotFoundError", ()=>(0, _abiJs.AbiConstructorNotFoundError));
parcelHelpers.export(exports, "AbiConstructorParamsNotFoundError", ()=>(0, _abiJs.AbiConstructorParamsNotFoundError));
parcelHelpers.export(exports, "AbiDecodingDataSizeInvalidError", ()=>(0, _abiJs.AbiDecodingDataSizeInvalidError));
parcelHelpers.export(exports, "AbiDecodingDataSizeTooSmallError", ()=>(0, _abiJs.AbiDecodingDataSizeTooSmallError));
parcelHelpers.export(exports, "AbiDecodingZeroDataError", ()=>(0, _abiJs.AbiDecodingZeroDataError));
parcelHelpers.export(exports, "AbiEncodingArrayLengthMismatchError", ()=>(0, _abiJs.AbiEncodingArrayLengthMismatchError));
parcelHelpers.export(exports, "AbiEncodingLengthMismatchError", ()=>(0, _abiJs.AbiEncodingLengthMismatchError));
parcelHelpers.export(exports, "AbiEncodingBytesSizeMismatchError", ()=>(0, _abiJs.AbiEncodingBytesSizeMismatchError));
parcelHelpers.export(exports, "AbiErrorInputsNotFoundError", ()=>(0, _abiJs.AbiErrorInputsNotFoundError));
parcelHelpers.export(exports, "AbiErrorNotFoundError", ()=>(0, _abiJs.AbiErrorNotFoundError));
parcelHelpers.export(exports, "AbiErrorSignatureNotFoundError", ()=>(0, _abiJs.AbiErrorSignatureNotFoundError));
parcelHelpers.export(exports, "AbiEventNotFoundError", ()=>(0, _abiJs.AbiEventNotFoundError));
parcelHelpers.export(exports, "AbiEventSignatureEmptyTopicsError", ()=>(0, _abiJs.AbiEventSignatureEmptyTopicsError));
parcelHelpers.export(exports, "AbiEventSignatureNotFoundError", ()=>(0, _abiJs.AbiEventSignatureNotFoundError));
parcelHelpers.export(exports, "AbiFunctionNotFoundError", ()=>(0, _abiJs.AbiFunctionNotFoundError));
parcelHelpers.export(exports, "AbiFunctionOutputsNotFoundError", ()=>(0, _abiJs.AbiFunctionOutputsNotFoundError));
parcelHelpers.export(exports, "AbiFunctionSignatureNotFoundError", ()=>(0, _abiJs.AbiFunctionSignatureNotFoundError));
parcelHelpers.export(exports, "BytesSizeMismatchError", ()=>(0, _abiJs.BytesSizeMismatchError));
parcelHelpers.export(exports, "DecodeLogDataMismatch", ()=>(0, _abiJs.DecodeLogDataMismatch));
parcelHelpers.export(exports, "DecodeLogTopicsMismatch", ()=>(0, _abiJs.DecodeLogTopicsMismatch));
parcelHelpers.export(exports, "InvalidAbiDecodingTypeError", ()=>(0, _abiJs.InvalidAbiDecodingTypeError));
parcelHelpers.export(exports, "InvalidAbiEncodingTypeError", ()=>(0, _abiJs.InvalidAbiEncodingTypeError));
parcelHelpers.export(exports, "InvalidArrayError", ()=>(0, _abiJs.InvalidArrayError));
parcelHelpers.export(exports, "InvalidDefinitionTypeError", ()=>(0, _abiJs.InvalidDefinitionTypeError));
parcelHelpers.export(exports, "UnsupportedPackedAbiType", ()=>(0, _abiJs.UnsupportedPackedAbiType));
parcelHelpers.export(exports, "BaseError", ()=>(0, _baseJs.BaseError));
parcelHelpers.export(exports, "BlockNotFoundError", ()=>(0, _blockJs.BlockNotFoundError));
parcelHelpers.export(exports, "CallExecutionError", ()=>(0, _contractJs.CallExecutionError));
parcelHelpers.export(exports, "ContractFunctionExecutionError", ()=>(0, _contractJs.ContractFunctionExecutionError));
parcelHelpers.export(exports, "ContractFunctionRevertedError", ()=>(0, _contractJs.ContractFunctionRevertedError));
parcelHelpers.export(exports, "ContractFunctionZeroDataError", ()=>(0, _contractJs.ContractFunctionZeroDataError));
parcelHelpers.export(exports, "RawContractError", ()=>(0, _contractJs.RawContractError));
parcelHelpers.export(exports, "BaseFeeScalarError", ()=>(0, _feeJs.BaseFeeScalarError));
parcelHelpers.export(exports, "Eip1559FeesNotSupportedError", ()=>(0, _feeJs.Eip1559FeesNotSupportedError));
parcelHelpers.export(exports, "MaxFeePerGasTooLowError", ()=>(0, _feeJs.MaxFeePerGasTooLowError));
parcelHelpers.export(exports, "ChainDisconnectedError", ()=>(0, _rpcJs.ChainDisconnectedError));
parcelHelpers.export(exports, "InternalRpcError", ()=>(0, _rpcJs.InternalRpcError));
parcelHelpers.export(exports, "InvalidInputRpcError", ()=>(0, _rpcJs.InvalidInputRpcError));
parcelHelpers.export(exports, "InvalidParamsRpcError", ()=>(0, _rpcJs.InvalidParamsRpcError));
parcelHelpers.export(exports, "InvalidRequestRpcError", ()=>(0, _rpcJs.InvalidRequestRpcError));
parcelHelpers.export(exports, "JsonRpcVersionUnsupportedError", ()=>(0, _rpcJs.JsonRpcVersionUnsupportedError));
parcelHelpers.export(exports, "LimitExceededRpcError", ()=>(0, _rpcJs.LimitExceededRpcError));
parcelHelpers.export(exports, "MethodNotFoundRpcError", ()=>(0, _rpcJs.MethodNotFoundRpcError));
parcelHelpers.export(exports, "MethodNotSupportedRpcError", ()=>(0, _rpcJs.MethodNotSupportedRpcError));
parcelHelpers.export(exports, "ParseRpcError", ()=>(0, _rpcJs.ParseRpcError));
parcelHelpers.export(exports, "ProviderDisconnectedError", ()=>(0, _rpcJs.ProviderDisconnectedError));
parcelHelpers.export(exports, "ProviderRpcError", ()=>(0, _rpcJs.ProviderRpcError));
parcelHelpers.export(exports, "ResourceNotFoundRpcError", ()=>(0, _rpcJs.ResourceNotFoundRpcError));
parcelHelpers.export(exports, "ResourceUnavailableRpcError", ()=>(0, _rpcJs.ResourceUnavailableRpcError));
parcelHelpers.export(exports, "RpcError", ()=>(0, _rpcJs.RpcError));
parcelHelpers.export(exports, "SwitchChainError", ()=>(0, _rpcJs.SwitchChainError));
parcelHelpers.export(exports, "TransactionRejectedRpcError", ()=>(0, _rpcJs.TransactionRejectedRpcError));
parcelHelpers.export(exports, "UnauthorizedProviderError", ()=>(0, _rpcJs.UnauthorizedProviderError));
parcelHelpers.export(exports, "UnknownRpcError", ()=>(0, _rpcJs.UnknownRpcError));
parcelHelpers.export(exports, "UnsupportedProviderMethodError", ()=>(0, _rpcJs.UnsupportedProviderMethodError));
parcelHelpers.export(exports, "UserRejectedRequestError", ()=>(0, _rpcJs.UserRejectedRequestError));
parcelHelpers.export(exports, "ChainDoesNotSupportContract", ()=>(0, _chainJs.ChainDoesNotSupportContract));
parcelHelpers.export(exports, "ChainMismatchError", ()=>(0, _chainJs.ChainMismatchError));
parcelHelpers.export(exports, "ChainNotFoundError", ()=>(0, _chainJs.ChainNotFoundError));
parcelHelpers.export(exports, "ClientChainNotConfiguredError", ()=>(0, _chainJs.ClientChainNotConfiguredError));
parcelHelpers.export(exports, "InvalidChainIdError", ()=>(0, _chainJs.InvalidChainIdError));
parcelHelpers.export(exports, "InvalidBytesBooleanError", ()=>(0, _encodingJs.InvalidBytesBooleanError));
parcelHelpers.export(exports, "IntegerOutOfRangeError", ()=>(0, _encodingJs.IntegerOutOfRangeError));
parcelHelpers.export(exports, "InvalidHexBooleanError", ()=>(0, _encodingJs.InvalidHexBooleanError));
parcelHelpers.export(exports, "InvalidHexValueError", ()=>(0, _encodingJs.InvalidHexValueError));
parcelHelpers.export(exports, "SizeOverflowError", ()=>(0, _encodingJs.SizeOverflowError));
parcelHelpers.export(exports, "EnsAvatarUriResolutionError", ()=>(0, _ensJs.EnsAvatarUriResolutionError));
parcelHelpers.export(exports, "EnsAvatarInvalidNftUriError", ()=>(0, _ensJs.EnsAvatarInvalidNftUriError));
parcelHelpers.export(exports, "EnsAvatarUnsupportedNamespaceError", ()=>(0, _ensJs.EnsAvatarUnsupportedNamespaceError));
parcelHelpers.export(exports, "EstimateGasExecutionError", ()=>(0, _estimateGasJs.EstimateGasExecutionError));
parcelHelpers.export(exports, "ExecutionRevertedError", ()=>(0, _nodeJs.ExecutionRevertedError));
parcelHelpers.export(exports, "FeeCapTooHighError", ()=>(0, _nodeJs.FeeCapTooHighError));
parcelHelpers.export(exports, "FeeCapTooLowError", ()=>(0, _nodeJs.FeeCapTooLowError));
parcelHelpers.export(exports, "InsufficientFundsError", ()=>(0, _nodeJs.InsufficientFundsError));
parcelHelpers.export(exports, "IntrinsicGasTooHighError", ()=>(0, _nodeJs.IntrinsicGasTooHighError));
parcelHelpers.export(exports, "IntrinsicGasTooLowError", ()=>(0, _nodeJs.IntrinsicGasTooLowError));
parcelHelpers.export(exports, "NonceMaxValueError", ()=>(0, _nodeJs.NonceMaxValueError));
parcelHelpers.export(exports, "NonceTooHighError", ()=>(0, _nodeJs.NonceTooHighError));
parcelHelpers.export(exports, "NonceTooLowError", ()=>(0, _nodeJs.NonceTooLowError));
parcelHelpers.export(exports, "TipAboveFeeCapError", ()=>(0, _nodeJs.TipAboveFeeCapError));
parcelHelpers.export(exports, "TransactionTypeNotSupportedError", ()=>(0, _nodeJs.TransactionTypeNotSupportedError));
parcelHelpers.export(exports, "UnknownNodeError", ()=>(0, _nodeJs.UnknownNodeError));
parcelHelpers.export(exports, "FilterTypeNotSupportedError", ()=>(0, _logJs.FilterTypeNotSupportedError));
parcelHelpers.export(exports, "HttpRequestError", ()=>(0, _requestJs.HttpRequestError));
parcelHelpers.export(exports, "RpcRequestError", ()=>(0, _requestJs.RpcRequestError));
parcelHelpers.export(exports, "TimeoutError", ()=>(0, _requestJs.TimeoutError));
parcelHelpers.export(exports, "WebSocketRequestError", ()=>(0, _requestJs.WebSocketRequestError));
parcelHelpers.export(exports, "InvalidAddressError", ()=>(0, _addressJs1.InvalidAddressError));
parcelHelpers.export(exports, "FeeConflictError", ()=>(0, _transactionJs.FeeConflictError));
parcelHelpers.export(exports, "InvalidLegacyVError", ()=>(0, _transactionJs.InvalidLegacyVError));
parcelHelpers.export(exports, "InvalidSerializableTransactionError", ()=>(0, _transactionJs.InvalidSerializableTransactionError));
parcelHelpers.export(exports, "InvalidSerializedTransactionError", ()=>(0, _transactionJs.InvalidSerializedTransactionError));
parcelHelpers.export(exports, "InvalidSerializedTransactionTypeError", ()=>(0, _transactionJs.InvalidSerializedTransactionTypeError));
parcelHelpers.export(exports, "InvalidStorageKeySizeError", ()=>(0, _transactionJs.InvalidStorageKeySizeError));
parcelHelpers.export(exports, "TransactionExecutionError", ()=>(0, _transactionJs.TransactionExecutionError));
parcelHelpers.export(exports, "TransactionNotFoundError", ()=>(0, _transactionJs.TransactionNotFoundError));
parcelHelpers.export(exports, "TransactionReceiptNotFoundError", ()=>(0, _transactionJs.TransactionReceiptNotFoundError));
parcelHelpers.export(exports, "WaitForTransactionReceiptTimeoutError", ()=>(0, _transactionJs.WaitForTransactionReceiptTimeoutError));
parcelHelpers.export(exports, "SizeExceedsPaddingSizeError", ()=>(0, _dataJs.SizeExceedsPaddingSizeError));
parcelHelpers.export(exports, "SliceOffsetOutOfBoundsError", ()=>(0, _dataJs.SliceOffsetOutOfBoundsError));
parcelHelpers.export(exports, "UrlRequiredError", ()=>(0, _transportJs.UrlRequiredError));
parcelHelpers.export(exports, "AccountStateConflictError", ()=>(0, _stateOverrideJs.AccountStateConflictError));
parcelHelpers.export(exports, "StateAssignmentConflictError", ()=>(0, _stateOverrideJs.StateAssignmentConflictError));
parcelHelpers.export(exports, "labelhash", ()=>(0, _labelhashJs.labelhash));
parcelHelpers.export(exports, "namehash", ()=>(0, _namehashJs.namehash));
parcelHelpers.export(exports, "defineBlock", ()=>(0, _blockJs1.defineBlock));
parcelHelpers.export(exports, "formatBlock", ()=>(0, _blockJs1.formatBlock));
parcelHelpers.export(exports, "formatLog", ()=>(0, _logJs1.formatLog));
parcelHelpers.export(exports, "decodeAbiParameters", ()=>(0, _decodeAbiParametersJs.decodeAbiParameters));
parcelHelpers.export(exports, "decodeDeployData", ()=>(0, _decodeDeployDataJs.decodeDeployData));
parcelHelpers.export(exports, "decodeErrorResult", ()=>(0, _decodeErrorResultJs.decodeErrorResult));
parcelHelpers.export(exports, "decodeEventLog", ()=>(0, _decodeEventLogJs.decodeEventLog));
parcelHelpers.export(exports, "decodeFunctionData", ()=>(0, _decodeFunctionDataJs.decodeFunctionData));
parcelHelpers.export(exports, "decodeFunctionResult", ()=>(0, _decodeFunctionResultJs.decodeFunctionResult));
parcelHelpers.export(exports, "encodeAbiParameters", ()=>(0, _encodeAbiParametersJs.encodeAbiParameters));
parcelHelpers.export(exports, "encodeDeployData", ()=>(0, _encodeDeployDataJs.encodeDeployData));
parcelHelpers.export(exports, "encodeErrorResult", ()=>(0, _encodeErrorResultJs.encodeErrorResult));
parcelHelpers.export(exports, "encodeEventTopics", ()=>(0, _encodeEventTopicsJs.encodeEventTopics));
parcelHelpers.export(exports, "encodeFunctionData", ()=>(0, _encodeFunctionDataJs.encodeFunctionData));
parcelHelpers.export(exports, "encodeFunctionResult", ()=>(0, _encodeFunctionResultJs.encodeFunctionResult));
parcelHelpers.export(exports, "parseEventLogs", ()=>(0, _parseEventLogsJs.parseEventLogs));
parcelHelpers.export(exports, "defineTransaction", ()=>(0, _transactionJs1.defineTransaction));
parcelHelpers.export(exports, "formatTransaction", ()=>(0, _transactionJs1.formatTransaction));
parcelHelpers.export(exports, "transactionType", ()=>(0, _transactionJs1.transactionType));
parcelHelpers.export(exports, "defineTransactionReceipt", ()=>(0, _transactionReceiptJs.defineTransactionReceipt));
parcelHelpers.export(exports, "formatTransactionReceipt", ()=>(0, _transactionReceiptJs.formatTransactionReceipt));
parcelHelpers.export(exports, "defineTransactionRequest", ()=>(0, _transactionRequestJs.defineTransactionRequest));
parcelHelpers.export(exports, "formatTransactionRequest", ()=>(0, _transactionRequestJs.formatTransactionRequest));
parcelHelpers.export(exports, "rpcTransactionType", ()=>(0, _transactionRequestJs.rpcTransactionType));
parcelHelpers.export(exports, "getAbiItem", ()=>(0, _getAbiItemJs.getAbiItem));
parcelHelpers.export(exports, "getContractAddress", ()=>(0, _getContractAddressJs.getContractAddress));
parcelHelpers.export(exports, "getCreate2Address", ()=>(0, _getContractAddressJs.getCreate2Address));
parcelHelpers.export(exports, "getCreateAddress", ()=>(0, _getContractAddressJs.getCreateAddress));
parcelHelpers.export(exports, "getSerializedTransactionType", ()=>(0, _getSerializedTransactionTypeJs.getSerializedTransactionType));
parcelHelpers.export(exports, "getTransactionType", ()=>(0, _getTransactionTypeJs.getTransactionType));
parcelHelpers.export(exports, "hashDomain", ()=>(0, _hashTypedDataJs.hashDomain));
parcelHelpers.export(exports, "hashTypedData", ()=>(0, _hashTypedDataJs.hashTypedData));
parcelHelpers.export(exports, "compactSignatureToSignature", ()=>(0, _compactSignatureToSignatureJs.compactSignatureToSignature));
parcelHelpers.export(exports, "hexToCompactSignature", ()=>(0, _hexToCompactSignatureJs.hexToCompactSignature));
parcelHelpers.export(exports, "hexToSignature", ()=>(0, _hexToSignatureJs.hexToSignature));
parcelHelpers.export(exports, "recoverAddress", ()=>(0, _recoverAddressJs.recoverAddress));
parcelHelpers.export(exports, "recoverMessageAddress", ()=>(0, _recoverMessageAddressJs.recoverMessageAddress));
parcelHelpers.export(exports, "recoverPublicKey", ()=>(0, _recoverPublicKeyJs.recoverPublicKey));
parcelHelpers.export(exports, "recoverTypedDataAddress", ()=>(0, _recoverTypedDataAddressJs.recoverTypedDataAddress));
parcelHelpers.export(exports, "signatureToCompactSignature", ()=>(0, _signatureToCompactSignatureJs.signatureToCompactSignature));
parcelHelpers.export(exports, "compactSignatureToHex", ()=>(0, _compactSignatureToHexJs.compactSignatureToHex));
parcelHelpers.export(exports, "signatureToHex", ()=>(0, _signatureToHexJs.signatureToHex));
parcelHelpers.export(exports, "bytesToRlp", ()=>(0, _toRlpJs.bytesToRlp));
parcelHelpers.export(exports, "hexToRlp", ()=>(0, _toRlpJs.hexToRlp));
parcelHelpers.export(exports, "toRlp", ()=>(0, _toRlpJs.toRlp));
parcelHelpers.export(exports, "verifyMessage", ()=>(0, _verifyMessageJs.verifyMessage));
parcelHelpers.export(exports, "verifyTypedData", ()=>(0, _verifyTypedDataJs.verifyTypedData));
parcelHelpers.export(exports, "assertRequest", ()=>(0, _assertRequestJs.assertRequest));
parcelHelpers.export(exports, "assertTransactionEIP1559", ()=>(0, _assertTransactionJs.assertTransactionEIP1559));
parcelHelpers.export(exports, "assertTransactionEIP2930", ()=>(0, _assertTransactionJs.assertTransactionEIP2930));
parcelHelpers.export(exports, "assertTransactionLegacy", ()=>(0, _assertTransactionJs.assertTransactionLegacy));
parcelHelpers.export(exports, "boolToBytes", ()=>(0, _toBytesJs.boolToBytes));
parcelHelpers.export(exports, "hexToBytes", ()=>(0, _toBytesJs.hexToBytes));
parcelHelpers.export(exports, "numberToBytes", ()=>(0, _toBytesJs.numberToBytes));
parcelHelpers.export(exports, "stringToBytes", ()=>(0, _toBytesJs.stringToBytes));
parcelHelpers.export(exports, "toBytes", ()=>(0, _toBytesJs.toBytes));
parcelHelpers.export(exports, "boolToHex", ()=>(0, _toHexJs.boolToHex));
parcelHelpers.export(exports, "bytesToHex", ()=>(0, _toHexJs.bytesToHex));
parcelHelpers.export(exports, "numberToHex", ()=>(0, _toHexJs.numberToHex));
parcelHelpers.export(exports, "stringToHex", ()=>(0, _toHexJs.stringToHex));
parcelHelpers.export(exports, "toHex", ()=>(0, _toHexJs.toHex));
parcelHelpers.export(exports, "bytesToBigInt", ()=>(0, _fromBytesJs.bytesToBigInt));
parcelHelpers.export(exports, "bytesToBool", ()=>(0, _fromBytesJs.bytesToBool));
parcelHelpers.export(exports, "bytesToNumber", ()=>(0, _fromBytesJs.bytesToNumber));
parcelHelpers.export(exports, "bytesToString", ()=>(0, _fromBytesJs.bytesToString));
parcelHelpers.export(exports, "fromBytes", ()=>(0, _fromBytesJs.fromBytes));
parcelHelpers.export(exports, "ccipFetch", ()=>(0, _ccipJs.ccipFetch));
parcelHelpers.export(exports, "offchainLookup", ()=>(0, _ccipJs.offchainLookup));
parcelHelpers.export(exports, "offchainLookupAbiItem", ()=>(0, _ccipJs.offchainLookupAbiItem));
parcelHelpers.export(exports, "offchainLookupSignature", ()=>(0, _ccipJs.offchainLookupSignature));
parcelHelpers.export(exports, "concat", ()=>(0, _concatJs.concat));
parcelHelpers.export(exports, "concatBytes", ()=>(0, _concatJs.concatBytes));
parcelHelpers.export(exports, "concatHex", ()=>(0, _concatJs.concatHex));
parcelHelpers.export(exports, "assertCurrentChain", ()=>(0, _assertCurrentChainJs.assertCurrentChain));
parcelHelpers.export(exports, "defineChain", ()=>(0, _defineChainJs.defineChain));
parcelHelpers.export(exports, "extractChain", ()=>(0, _extractChainJs.extractChain));
parcelHelpers.export(exports, "getChainContractAddress", ()=>(0, _getChainContractAddressJs.getChainContractAddress));
parcelHelpers.export(exports, "encodePacked", ()=>(0, _encodePackedJs.encodePacked));
parcelHelpers.export(exports, "withRetry", ()=>(0, _withRetryJs.withRetry));
parcelHelpers.export(exports, "withTimeout", ()=>(0, _withTimeoutJs.withTimeout));
parcelHelpers.export(exports, "formatEther", ()=>(0, _formatEtherJs.formatEther));
parcelHelpers.export(exports, "formatGwei", ()=>(0, _formatGweiJs.formatGwei));
parcelHelpers.export(exports, "formatUnits", ()=>(0, _formatUnitsJs.formatUnits));
parcelHelpers.export(exports, "fromHex", ()=>(0, _fromHexJs.fromHex));
parcelHelpers.export(exports, "hexToBigInt", ()=>(0, _fromHexJs.hexToBigInt));
parcelHelpers.export(exports, "hexToBool", ()=>(0, _fromHexJs.hexToBool));
parcelHelpers.export(exports, "hexToNumber", ()=>(0, _fromHexJs.hexToNumber));
parcelHelpers.export(exports, "hexToString", ()=>(0, _fromHexJs.hexToString));
parcelHelpers.export(exports, "fromRlp", ()=>(0, _fromRlpJs.fromRlp));
parcelHelpers.export(exports, "checksumAddress", ()=>(0, _getAddressJs.checksumAddress));
parcelHelpers.export(exports, "getAddress", ()=>(0, _getAddressJs.getAddress));
parcelHelpers.export(exports, "getContractError", ()=>(0, _getContractErrorJs.getContractError));
parcelHelpers.export(exports, "toEventSelector", ()=>(0, _toEventSelectorJs.toEventSelector));
parcelHelpers.export(exports, "getEventSelector", ()=>(0, _toEventSelectorJs.toEventSelector));
parcelHelpers.export(exports, "toFunctionSelector", ()=>(0, _toFunctionSelectorJs.toFunctionSelector));
parcelHelpers.export(exports, "getFunctionSelector", ()=>(0, _toFunctionSelectorJs.toFunctionSelector));
parcelHelpers.export(exports, "toEventSignature", ()=>(0, _toEventSignatureJs.toEventSignature));
parcelHelpers.export(exports, "getEventSignature", ()=>(0, _toEventSignatureJs.toEventSignature));
parcelHelpers.export(exports, "toFunctionSignature", ()=>(0, _toFunctionSignatureJs.toFunctionSignature));
parcelHelpers.export(exports, "getFunctionSignature", ()=>(0, _toFunctionSignatureJs.toFunctionSignature));
parcelHelpers.export(exports, "toEventHash", ()=>(0, _toEventHashJs.toEventHash));
parcelHelpers.export(exports, "toFunctionHash", ()=>(0, _toFunctionHashJs.toFunctionHash));
parcelHelpers.export(exports, "hashMessage", ()=>(0, _hashMessageJs.hashMessage));
parcelHelpers.export(exports, "isAddress", ()=>(0, _isAddressJs.isAddress));
parcelHelpers.export(exports, "isAddressEqual", ()=>(0, _isAddressEqualJs.isAddressEqual));
parcelHelpers.export(exports, "isBytes", ()=>(0, _isBytesJs.isBytes));
parcelHelpers.export(exports, "isHash", ()=>(0, _isHashJs.isHash));
parcelHelpers.export(exports, "isHex", ()=>(0, _isHexJs.isHex));
parcelHelpers.export(exports, "keccak256", ()=>(0, _keccak256Js.keccak256));
parcelHelpers.export(exports, "sha256", ()=>(0, _sha256Js.sha256));
parcelHelpers.export(exports, "ripemd160", ()=>(0, _ripemd160Js.ripemd160));
parcelHelpers.export(exports, "pad", ()=>(0, _padJs.pad));
parcelHelpers.export(exports, "padBytes", ()=>(0, _padJs.padBytes));
parcelHelpers.export(exports, "padHex", ()=>(0, _padJs.padHex));
parcelHelpers.export(exports, "parseEther", ()=>(0, _parseEtherJs.parseEther));
parcelHelpers.export(exports, "parseGwei", ()=>(0, _parseGweiJs.parseGwei));
parcelHelpers.export(exports, "parseTransaction", ()=>(0, _parseTransactionJs.parseTransaction));
parcelHelpers.export(exports, "parseUnits", ()=>(0, _parseUnitsJs.parseUnits));
parcelHelpers.export(exports, "serializeAccessList", ()=>(0, _serializeAccessListJs.serializeAccessList));
parcelHelpers.export(exports, "serializeTransaction", ()=>(0, _serializeTransactionJs.serializeTransaction));
parcelHelpers.export(exports, "size", ()=>(0, _sizeJs.size));
parcelHelpers.export(exports, "slice", ()=>(0, _sliceJs.slice));
parcelHelpers.export(exports, "sliceBytes", ()=>(0, _sliceJs.sliceBytes));
parcelHelpers.export(exports, "sliceHex", ()=>(0, _sliceJs.sliceHex));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJs.stringify));
parcelHelpers.export(exports, "trim", ()=>(0, _trimJs.trim));
parcelHelpers.export(exports, "validateTypedData", ()=>(0, _typedDataJs.validateTypedData));
parcelHelpers.export(exports, "domainSeparator", ()=>(0, _typedDataJs.domainSeparator));
parcelHelpers.export(exports, "getTypesForEIP712Domain", ()=>(0, _typedDataJs.getTypesForEIP712Domain));
var _abitype = require("abitype");
var _getContractJs = require("./actions/getContract.js");
var _getContractEventsJs = require("./actions/public/getContractEvents.js");
var _addChainJs = require("./actions/wallet/addChain.js");
var _callJs = require("./actions/public/call.js");
var _createClientJs = require("./clients/createClient.js");
var _customJs = require("./clients/transports/custom.js");
var _fallbackJs = require("./clients/transports/fallback.js");
var _httpJs = require("./clients/transports/http.js");
var _createPublicClientJs = require("./clients/createPublicClient.js");
var _createTestClientJs = require("./clients/createTestClient.js");
var _publicJs = require("./clients/decorators/public.js");
var _testJs = require("./clients/decorators/test.js");
var _walletJs = require("./clients/decorators/wallet.js");
var _createTransportJs = require("./clients/transports/createTransport.js");
var _createWalletClientJs = require("./clients/createWalletClient.js");
var _webSocketJs = require("./clients/transports/webSocket.js");
var _abisJs = require("./constants/abis.js");
var _addressJs = require("./constants/address.js");
var _unitJs = require("./constants/unit.js");
var _numberJs = require("./constants/number.js");
var _bytesJs = require("./constants/bytes.js");
var _stringsJs = require("./constants/strings.js");
var _abiJs = require("./errors/abi.js");
var _baseJs = require("./errors/base.js");
var _blockJs = require("./errors/block.js");
var _contractJs = require("./errors/contract.js");
var _feeJs = require("./errors/fee.js");
var _rpcJs = require("./errors/rpc.js");
var _chainJs = require("./errors/chain.js");
var _encodingJs = require("./errors/encoding.js");
var _ensJs = require("./errors/ens.js");
var _estimateGasJs = require("./errors/estimateGas.js");
var _nodeJs = require("./errors/node.js");
var _logJs = require("./errors/log.js");
var _requestJs = require("./errors/request.js");
var _addressJs1 = require("./errors/address.js");
var _transactionJs = require("./errors/transaction.js");
var _dataJs = require("./errors/data.js");
var _transportJs = require("./errors/transport.js");
var _stateOverrideJs = require("./errors/stateOverride.js");
var _labelhashJs = require("./utils/ens/labelhash.js");
var _namehashJs = require("./utils/ens/namehash.js");
var _blockJs1 = require("./utils/formatters/block.js");
var _logJs1 = require("./utils/formatters/log.js");
var _decodeAbiParametersJs = require("./utils/abi/decodeAbiParameters.js");
var _decodeDeployDataJs = require("./utils/abi/decodeDeployData.js");
var _decodeErrorResultJs = require("./utils/abi/decodeErrorResult.js");
var _decodeEventLogJs = require("./utils/abi/decodeEventLog.js");
var _decodeFunctionDataJs = require("./utils/abi/decodeFunctionData.js");
var _decodeFunctionResultJs = require("./utils/abi/decodeFunctionResult.js");
var _encodeAbiParametersJs = require("./utils/abi/encodeAbiParameters.js");
var _encodeDeployDataJs = require("./utils/abi/encodeDeployData.js");
var _encodeErrorResultJs = require("./utils/abi/encodeErrorResult.js");
var _encodeEventTopicsJs = require("./utils/abi/encodeEventTopics.js");
var _encodeFunctionDataJs = require("./utils/abi/encodeFunctionData.js");
var _encodeFunctionResultJs = require("./utils/abi/encodeFunctionResult.js");
var _parseEventLogsJs = require("./utils/abi/parseEventLogs.js");
var _transactionJs1 = require("./utils/formatters/transaction.js");
var _transactionReceiptJs = require("./utils/formatters/transactionReceipt.js");
var _transactionRequestJs = require("./utils/formatters/transactionRequest.js");
var _getAbiItemJs = require("./utils/abi/getAbiItem.js");
var _getContractAddressJs = require("./utils/address/getContractAddress.js");
var _getSerializedTransactionTypeJs = require("./utils/transaction/getSerializedTransactionType.js");
var _getTransactionTypeJs = require("./utils/transaction/getTransactionType.js");
var _hashTypedDataJs = require("./utils/signature/hashTypedData.js");
var _compactSignatureToSignatureJs = require("./utils/signature/compactSignatureToSignature.js");
var _hexToCompactSignatureJs = require("./utils/signature/hexToCompactSignature.js");
var _hexToSignatureJs = require("./utils/signature/hexToSignature.js");
var _recoverAddressJs = require("./utils/signature/recoverAddress.js");
var _recoverMessageAddressJs = require("./utils/signature/recoverMessageAddress.js");
var _recoverPublicKeyJs = require("./utils/signature/recoverPublicKey.js");
var _recoverTypedDataAddressJs = require("./utils/signature/recoverTypedDataAddress.js");
var _signatureToCompactSignatureJs = require("./utils/signature/signatureToCompactSignature.js");
var _compactSignatureToHexJs = require("./utils/signature/compactSignatureToHex.js");
var _signatureToHexJs = require("./utils/signature/signatureToHex.js");
var _toRlpJs = require("./utils/encoding/toRlp.js");
var _verifyMessageJs = require("./utils/signature/verifyMessage.js");
var _verifyTypedDataJs = require("./utils/signature/verifyTypedData.js");
var _assertRequestJs = require("./utils/transaction/assertRequest.js");
var _assertTransactionJs = require("./utils/transaction/assertTransaction.js");
var _toBytesJs = require("./utils/encoding/toBytes.js");
var _toHexJs = require("./utils/encoding/toHex.js");
var _fromBytesJs = require("./utils/encoding/fromBytes.js");
var _ccipJs = require("./utils/ccip.js");
var _concatJs = require("./utils/data/concat.js");
var _assertCurrentChainJs = require("./utils/chain/assertCurrentChain.js");
var _defineChainJs = require("./utils/chain/defineChain.js");
var _extractChainJs = require("./utils/chain/extractChain.js");
var _getChainContractAddressJs = require("./utils/chain/getChainContractAddress.js");
var _encodePackedJs = require("./utils/abi/encodePacked.js");
var _withRetryJs = require("./utils/promise/withRetry.js");
var _withTimeoutJs = require("./utils/promise/withTimeout.js");
var _formatEtherJs = require("./utils/unit/formatEther.js");
var _formatGweiJs = require("./utils/unit/formatGwei.js");
var _formatUnitsJs = require("./utils/unit/formatUnits.js");
var _fromHexJs = require("./utils/encoding/fromHex.js");
var _fromRlpJs = require("./utils/encoding/fromRlp.js");
var _getAddressJs = require("./utils/address/getAddress.js");
var _getContractErrorJs = require("./utils/errors/getContractError.js");
var _toEventSelectorJs = require("./utils/hash/toEventSelector.js");
var _toFunctionSelectorJs = require("./utils/hash/toFunctionSelector.js");
var _toEventSignatureJs = require("./utils/hash/toEventSignature.js");
var _toFunctionSignatureJs = require("./utils/hash/toFunctionSignature.js");
var _toEventHashJs = require("./utils/hash/toEventHash.js");
var _toFunctionHashJs = require("./utils/hash/toFunctionHash.js");
var _hashMessageJs = require("./utils/signature/hashMessage.js");
var _isAddressJs = require("./utils/address/isAddress.js");
var _isAddressEqualJs = require("./utils/address/isAddressEqual.js");
var _isBytesJs = require("./utils/data/isBytes.js");
var _isHashJs = require("./utils/hash/isHash.js");
var _isHexJs = require("./utils/data/isHex.js");
var _keccak256Js = require("./utils/hash/keccak256.js");
var _sha256Js = require("./utils/hash/sha256.js");
var _ripemd160Js = require("./utils/hash/ripemd160.js");
var _padJs = require("./utils/data/pad.js");
var _parseEtherJs = require("./utils/unit/parseEther.js");
var _parseGweiJs = require("./utils/unit/parseGwei.js");
var _parseTransactionJs = require("./utils/transaction/parseTransaction.js");
var _parseUnitsJs = require("./utils/unit/parseUnits.js");
var _serializeAccessListJs = require("./utils/transaction/serializeAccessList.js");
var _serializeTransactionJs = require("./utils/transaction/serializeTransaction.js");
var _sizeJs = require("./utils/data/size.js");
var _sliceJs = require("./utils/data/slice.js");
var _stringifyJs = require("./utils/stringify.js");
var _trimJs = require("./utils/data/trim.js");
var _typedDataJs = require("./utils/typedData.js");

},{"abitype":false,"./actions/getContract.js":false,"./actions/public/getContractEvents.js":"aRmZs","./actions/wallet/addChain.js":"9zJQw","./actions/public/call.js":"lzQeB","./clients/createClient.js":false,"./clients/transports/custom.js":false,"./clients/transports/fallback.js":false,"./clients/transports/http.js":false,"./clients/createPublicClient.js":false,"./clients/createTestClient.js":false,"./clients/decorators/public.js":false,"./clients/decorators/test.js":false,"./clients/decorators/wallet.js":false,"./clients/transports/createTransport.js":false,"./clients/createWalletClient.js":false,"./clients/transports/webSocket.js":false,"./constants/abis.js":false,"./constants/address.js":false,"./constants/unit.js":false,"./constants/number.js":false,"./constants/bytes.js":false,"./constants/strings.js":false,"./errors/abi.js":"edx9G","./errors/base.js":false,"./errors/block.js":false,"./errors/contract.js":false,"./errors/fee.js":false,"./errors/rpc.js":false,"./errors/chain.js":false,"./errors/encoding.js":false,"./errors/ens.js":false,"./errors/estimateGas.js":false,"./errors/node.js":false,"./errors/log.js":false,"./errors/request.js":false,"./errors/address.js":false,"./errors/transaction.js":false,"./errors/data.js":false,"./errors/transport.js":false,"./errors/stateOverride.js":false,"./utils/ens/labelhash.js":false,"./utils/ens/namehash.js":false,"./utils/formatters/block.js":false,"./utils/formatters/log.js":false,"./utils/abi/decodeAbiParameters.js":false,"./utils/abi/decodeDeployData.js":false,"./utils/abi/decodeErrorResult.js":false,"./utils/abi/decodeEventLog.js":false,"./utils/abi/decodeFunctionData.js":false,"./utils/abi/decodeFunctionResult.js":false,"./utils/abi/encodeAbiParameters.js":false,"./utils/abi/encodeDeployData.js":false,"./utils/abi/encodeErrorResult.js":false,"./utils/abi/encodeEventTopics.js":false,"./utils/abi/encodeFunctionData.js":false,"./utils/abi/encodeFunctionResult.js":false,"./utils/abi/parseEventLogs.js":false,"./utils/formatters/transaction.js":false,"./utils/formatters/transactionReceipt.js":false,"./utils/formatters/transactionRequest.js":false,"./utils/abi/getAbiItem.js":false,"./utils/address/getContractAddress.js":false,"./utils/transaction/getSerializedTransactionType.js":false,"./utils/transaction/getTransactionType.js":false,"./utils/signature/hashTypedData.js":false,"./utils/signature/compactSignatureToSignature.js":false,"./utils/signature/hexToCompactSignature.js":false,"./utils/signature/hexToSignature.js":"8PjYO","./utils/signature/recoverAddress.js":false,"./utils/signature/recoverMessageAddress.js":false,"./utils/signature/recoverPublicKey.js":false,"./utils/signature/recoverTypedDataAddress.js":false,"./utils/signature/signatureToCompactSignature.js":false,"./utils/signature/compactSignatureToHex.js":false,"./utils/signature/signatureToHex.js":false,"./utils/encoding/toRlp.js":false,"./utils/signature/verifyMessage.js":"wNB8S","./utils/signature/verifyTypedData.js":false,"./utils/transaction/assertRequest.js":false,"./utils/transaction/assertTransaction.js":false,"./utils/encoding/toBytes.js":"jsem0","./utils/encoding/toHex.js":"9rk4U","./utils/encoding/fromBytes.js":false,"./utils/ccip.js":false,"./utils/data/concat.js":false,"./utils/chain/assertCurrentChain.js":false,"./utils/chain/defineChain.js":false,"./utils/chain/extractChain.js":false,"./utils/chain/getChainContractAddress.js":false,"./utils/abi/encodePacked.js":false,"./utils/promise/withRetry.js":false,"./utils/promise/withTimeout.js":false,"./utils/unit/formatEther.js":false,"./utils/unit/formatGwei.js":false,"./utils/unit/formatUnits.js":false,"./utils/encoding/fromHex.js":false,"./utils/encoding/fromRlp.js":false,"./utils/address/getAddress.js":"hjZaw","./utils/errors/getContractError.js":false,"./utils/hash/toEventSelector.js":false,"./utils/hash/toFunctionSelector.js":false,"./utils/hash/toEventSignature.js":false,"./utils/hash/toFunctionSignature.js":false,"./utils/hash/toEventHash.js":false,"./utils/hash/toFunctionHash.js":false,"./utils/signature/hashMessage.js":"44RYQ","./utils/address/isAddress.js":false,"./utils/address/isAddressEqual.js":false,"./utils/data/isBytes.js":false,"./utils/hash/isHash.js":false,"./utils/data/isHex.js":false,"./utils/hash/keccak256.js":"cpYiL","./utils/hash/sha256.js":false,"./utils/hash/ripemd160.js":false,"./utils/data/pad.js":false,"./utils/unit/parseEther.js":false,"./utils/unit/parseGwei.js":false,"./utils/transaction/parseTransaction.js":false,"./utils/unit/parseUnits.js":false,"./utils/transaction/serializeAccessList.js":false,"./utils/transaction/serializeTransaction.js":false,"./utils/data/size.js":false,"./utils/data/slice.js":false,"./utils/stringify.js":false,"./utils/data/trim.js":false,"./utils/typedData.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aRmZs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a list of event logs emitted by a contract.
 *
 * - Docs: https://viem.sh/docs/actions/public/getContractEvents
 * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)
 *
 * @param client - Client to use
 * @param parameters - {@link GetContractEventsParameters}
 * @returns A list of event logs. {@link GetContractEventsReturnType}
 *
 * @example
 * import { createClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getContractEvents } from 'viem/public'
 * import { wagmiAbi } from './abi'
 *
 * const client = createClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const logs = await getContractEvents(client, {
 *  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *  abi: wagmiAbi,
 *  eventName: 'Transfer'
 * })
 */ parcelHelpers.export(exports, "getContractEvents", ()=>getContractEvents);
var _getAbiItemJs = require("../../utils/abi/getAbiItem.js");
var _getActionJs = require("../../utils/getAction.js");
var _getLogsJs = require("./getLogs.js");
async function getContractEvents(client, parameters) {
    const { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
    const event = eventName ? (0, _getAbiItemJs.getAbiItem)({
        abi,
        name: eventName
    }) : undefined;
    const events = !event ? abi.filter((x)=>x.type === "event") : undefined;
    return (0, _getActionJs.getAction)(client, (0, _getLogsJs.getLogs), "getLogs")({
        address,
        args,
        blockHash,
        event,
        events,
        fromBlock,
        toBlock,
        strict
    });
}

},{"../../utils/abi/getAbiItem.js":"6yQt3","../../utils/getAction.js":"cDYfc","./getLogs.js":"l0g8m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cDYfc":[function(require,module,exports) {
/**
 * Retrieves and returns an action from the client (if exists), and falls
 * back to the tree-shakable action.
 *
 * Useful for extracting overridden actions from a client (ie. if a consumer
 * wants to override the `sendTransaction` implementation).
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getAction", ()=>getAction);
function getAction(client, action, // Some minifiers drop `Function.prototype.name`, meaning that `action.name`
// will not work. For that case, the consumer needs to pass the name explicitly.
name) {
    return (params)=>client[action.name || name]?.(params) ?? action(client, params);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l0g8m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a list of event logs matching the provided parameters.
 *
 * - Docs: https://viem.sh/docs/actions/public/getLogs
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/filters-and-logs/event-logs
 * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)
 *
 * @param client - Client to use
 * @param parameters - {@link GetLogsParameters}
 * @returns A list of event logs. {@link GetLogsReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbiItem } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getLogs } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const logs = await getLogs(client)
 */ parcelHelpers.export(exports, "getLogs", ()=>getLogs);
var _decodeEventLogJs = require("../../utils/abi/decodeEventLog.js");
var _encodeEventTopicsJs = require("../../utils/abi/encodeEventTopics.js");
var _parseEventLogsJs = require("../../utils/abi/parseEventLogs.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _logJs = require("../../utils/formatters/log.js");
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
    const strict = strict_ ?? false;
    const events = events_ ?? (event ? [
        event
    ] : undefined);
    let topics = [];
    if (events) {
        topics = [
            events.flatMap((event)=>(0, _encodeEventTopicsJs.encodeEventTopics)({
                    abi: [
                        event
                    ],
                    eventName: event.name,
                    args
                }))
        ];
        if (event) topics = topics[0];
    }
    let logs;
    if (blockHash) logs = await client.request({
        method: "eth_getLogs",
        params: [
            {
                address,
                topics,
                blockHash
            }
        ]
    });
    else logs = await client.request({
        method: "eth_getLogs",
        params: [
            {
                address,
                topics,
                fromBlock: typeof fromBlock === "bigint" ? (0, _toHexJs.numberToHex)(fromBlock) : fromBlock,
                toBlock: typeof toBlock === "bigint" ? (0, _toHexJs.numberToHex)(toBlock) : toBlock
            }
        ]
    });
    const formattedLogs = logs.map((log)=>(0, _logJs.formatLog)(log));
    if (!events) return formattedLogs;
    return (0, _parseEventLogsJs.parseEventLogs)({
        abi: events,
        logs: formattedLogs,
        strict
    });
}

},{"../../utils/abi/decodeEventLog.js":"2Rseg","../../utils/abi/encodeEventTopics.js":"lW18G","../../utils/abi/parseEventLogs.js":"bBnu7","../../utils/encoding/toHex.js":"9rk4U","../../utils/formatters/log.js":"10G5B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2Rseg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeEventLog", ()=>decodeEventLog);
var _abiJs = require("../../errors/abi.js");
var _sizeJs = require("../data/size.js");
var _toEventSelectorJs = require("../hash/toEventSelector.js");
var _cursorJs = require("../../errors/cursor.js");
var _decodeAbiParametersJs = require("./decodeAbiParameters.js");
var _formatAbiItemJs = require("./formatAbiItem.js");
const docsPath = "/docs/contract/decodeEventLog";
function decodeEventLog(parameters) {
    const { abi, data, strict: strict_, topics } = parameters;
    const strict = strict_ ?? true;
    const [signature, ...argTopics] = topics;
    if (!signature) throw new (0, _abiJs.AbiEventSignatureEmptyTopicsError)({
        docsPath
    });
    const abiItem = abi.find((x)=>x.type === "event" && signature === (0, _toEventSelectorJs.toEventSelector)((0, _formatAbiItemJs.formatAbiItem)(x)));
    if (!(abiItem && "name" in abiItem) || abiItem.type !== "event") throw new (0, _abiJs.AbiEventSignatureNotFoundError)(signature, {
        docsPath
    });
    const { name, inputs } = abiItem;
    const isUnnamed = inputs?.some((x)=>!("name" in x && x.name));
    let args = isUnnamed ? [] : {};
    // Decode topics (indexed args).
    const indexedInputs = inputs.filter((x)=>"indexed" in x && x.indexed);
    for(let i = 0; i < indexedInputs.length; i++){
        const param = indexedInputs[i];
        const topic = argTopics[i];
        if (!topic) throw new (0, _abiJs.DecodeLogTopicsMismatch)({
            abiItem,
            param: param
        });
        args[param.name || i] = decodeTopic({
            param,
            value: topic
        });
    }
    // Decode data (non-indexed args).
    const nonIndexedInputs = inputs.filter((x)=>!("indexed" in x && x.indexed));
    if (nonIndexedInputs.length > 0) {
        if (data && data !== "0x") try {
            const decodedData = (0, _decodeAbiParametersJs.decodeAbiParameters)(nonIndexedInputs, data);
            if (decodedData) {
                if (isUnnamed) args = [
                    ...args,
                    ...decodedData
                ];
                else for(let i = 0; i < nonIndexedInputs.length; i++)args[nonIndexedInputs[i].name] = decodedData[i];
            }
        } catch (err) {
            if (strict) {
                if (err instanceof (0, _abiJs.AbiDecodingDataSizeTooSmallError) || err instanceof (0, _cursorJs.PositionOutOfBoundsError)) throw new (0, _abiJs.DecodeLogDataMismatch)({
                    abiItem,
                    data: data,
                    params: nonIndexedInputs,
                    size: (0, _sizeJs.size)(data)
                });
                throw err;
            }
        }
        else if (strict) throw new (0, _abiJs.DecodeLogDataMismatch)({
            abiItem,
            data: "0x",
            params: nonIndexedInputs,
            size: 0
        });
    }
    return {
        eventName: name,
        args: Object.values(args).length > 0 ? args : undefined
    };
}
function decodeTopic({ param, value }) {
    if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/)) return value;
    const decodedArg = (0, _decodeAbiParametersJs.decodeAbiParameters)([
        param
    ], value) || [];
    return decodedArg[0];
}

},{"../../errors/abi.js":"edx9G","../data/size.js":"iGp06","../hash/toEventSelector.js":"d7pnx","../../errors/cursor.js":"guRrG","./decodeAbiParameters.js":"eOFWa","./formatAbiItem.js":"1dQtZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lW18G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeEventTopics", ()=>encodeEventTopics);
var _abiJs = require("../../errors/abi.js");
var _logJs = require("../../errors/log.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _keccak256Js = require("../hash/keccak256.js");
var _toEventSelectorJs = require("../hash/toEventSelector.js");
var _encodeAbiParametersJs = require("./encodeAbiParameters.js");
var _formatAbiItemJs = require("./formatAbiItem.js");
var _getAbiItemJs = require("./getAbiItem.js");
const docsPath = "/docs/contract/encodeEventTopics";
function encodeEventTopics(parameters) {
    const { abi, eventName, args } = parameters;
    let abiItem = abi[0];
    if (eventName) {
        const item = (0, _getAbiItemJs.getAbiItem)({
            abi,
            name: eventName
        });
        if (!item) throw new (0, _abiJs.AbiEventNotFoundError)(eventName, {
            docsPath
        });
        abiItem = item;
    }
    if (abiItem.type !== "event") throw new (0, _abiJs.AbiEventNotFoundError)(undefined, {
        docsPath
    });
    const definition = (0, _formatAbiItemJs.formatAbiItem)(abiItem);
    const signature = (0, _toEventSelectorJs.toEventSelector)(definition);
    let topics = [];
    if (args && "inputs" in abiItem) {
        const indexedInputs = abiItem.inputs?.filter((param)=>"indexed" in param && param.indexed);
        const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x)=>args[x.name]) ?? [] : [];
        if (args_.length > 0) topics = indexedInputs?.map((param, i)=>Array.isArray(args_[i]) ? args_[i].map((_, j)=>encodeArg({
                    param,
                    value: args_[i][j]
                })) : args_[i] ? encodeArg({
                param,
                value: args_[i]
            }) : null) ?? [];
    }
    return [
        signature,
        ...topics
    ];
}
function encodeArg({ param, value }) {
    if (param.type === "string" || param.type === "bytes") return (0, _keccak256Js.keccak256)((0, _toBytesJs.toBytes)(value));
    if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/)) throw new (0, _logJs.FilterTypeNotSupportedError)(param.type);
    return (0, _encodeAbiParametersJs.encodeAbiParameters)([
        param
    ], [
        value
    ]);
}

},{"../../errors/abi.js":"edx9G","../../errors/log.js":"hIiaY","../encoding/toBytes.js":"jsem0","../hash/keccak256.js":"cpYiL","../hash/toEventSelector.js":"d7pnx","./encodeAbiParameters.js":"ji1Pk","./formatAbiItem.js":"1dQtZ","./getAbiItem.js":"6yQt3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hIiaY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FilterTypeNotSupportedError", ()=>FilterTypeNotSupportedError);
var _baseJs = require("./base.js");
class FilterTypeNotSupportedError extends (0, _baseJs.BaseError) {
    constructor(type){
        super(`Filter type "${type}" is not supported.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "FilterTypeNotSupportedError"
        });
    }
}

},{"./base.js":"4yABH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bBnu7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)
 * from a set of opaque logs.
 *
 * @param parameters - {@link ParseEventLogsParameters}
 * @returns The logs. {@link ParseEventLogsReturnType}
 *
 * @example
 * import { createClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { parseEventLogs } from 'viem/op-stack'
 *
 * const client = createClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 *
 * const receipt = await getTransactionReceipt(client, {
 *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',
 * })
 *
 * const logs = parseEventLogs({ logs: receipt.logs })
 * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]
 */ parcelHelpers.export(exports, "parseEventLogs", ()=>parseEventLogs);
var _indexJs = require("../../index.js");
var _decodeEventLogJs = require("./decodeEventLog.js");
function parseEventLogs({ abi, eventName, logs, strict = true }) {
    return logs.map((log)=>{
        try {
            const event = (0, _decodeEventLogJs.decodeEventLog)({
                ...log,
                abi,
                strict
            });
            if (eventName && !eventName.includes(event.eventName)) return null;
            return {
                ...event,
                ...log
            };
        } catch (err) {
            let eventName;
            let isUnnamed;
            if (err instanceof (0, _indexJs.AbiEventSignatureNotFoundError)) return null;
            if (err instanceof (0, _indexJs.DecodeLogDataMismatch) || err instanceof (0, _indexJs.DecodeLogTopicsMismatch)) {
                // If strict mode is on, and log data/topics do not match event definition, skip.
                if (strict) return null;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x)=>!("name" in x && x.name));
            }
            // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).
            return {
                ...log,
                args: isUnnamed ? [] : {},
                eventName
            };
        }
    }).filter(Boolean);
}

},{"../../index.js":"7gLEX","./decodeEventLog.js":"2Rseg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"10G5B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatLog", ()=>formatLog);
function formatLog(log, { args, eventName } = {}) {
    return {
        ...log,
        blockHash: log.blockHash ? log.blockHash : null,
        blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
        logIndex: log.logIndex ? Number(log.logIndex) : null,
        transactionHash: log.transactionHash ? log.transactionHash : null,
        transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
        ...eventName ? {
            args,
            eventName
        } : {}
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9zJQw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Adds an EVM chain to the wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/addChain
 * - JSON-RPC Methods: [`eth_addEthereumChain`](https://eips.ethereum.org/EIPS/eip-3085)
 *
 * @param client - Client to use
 * @param parameters - {@link AddChainParameters}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { optimism } from 'viem/chains'
 * import { addChain } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   transport: custom(window.ethereum),
 * })
 * await addChain(client, { chain: optimism })
 */ parcelHelpers.export(exports, "addChain", ()=>addChain);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function addChain(client, { chain }) {
    const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
    await client.request({
        method: "wallet_addEthereumChain",
        params: [
            {
                chainId: (0, _toHexJs.numberToHex)(id),
                chainName: name,
                nativeCurrency,
                rpcUrls: rpcUrls.default.http,
                blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url })=>url) : undefined
            }
        ]
    }, {
        retryCount: 0
    });
}

},{"../../utils/encoding/toHex.js":"9rk4U","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hFaqt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "presignMessagePrefix", ()=>presignMessagePrefix);
const presignMessagePrefix = "\x19Ethereum Signed Message:\n";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8PjYO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Parses a hex formatted signature into a structured signature.
 *
 * @param signatureHex Signature in hex format.
 * @returns The structured signature.
 *
 * @example
 * hexToSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')
 * // { r: '0x...', s: '0x...', v: 28n }
 */ parcelHelpers.export(exports, "hexToSignature", ()=>hexToSignature);
var _secp256K1 = require("@noble/curves/secp256k1");
var _toHexJs = require("../../utils/encoding/toHex.js");
function hexToSignature(signatureHex) {
    const { r, s } = (0, _secp256K1.secp256k1).Signature.fromCompact(signatureHex.slice(2, 130));
    const v = BigInt(`0x${signatureHex.slice(130)}`);
    return {
        r: (0, _toHexJs.numberToHex)(r, {
            size: 32
        }),
        s: (0, _toHexJs.numberToHex)(s, {
            size: 32
        }),
        v
    };
}

},{"@noble/curves/secp256k1":"k8xYt","../../utils/encoding/toHex.js":"9rk4U","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k8xYt":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "secp256k1", ()=>secp256k1);
parcelHelpers.export(exports, "schnorr", ()=>schnorr);
parcelHelpers.export(exports, "hashToCurve", ()=>hashToCurve);
parcelHelpers.export(exports, "encodeToCurve", ()=>encodeToCurve);
var _sha256 = require("@noble/hashes/sha256");
var _utils = require("@noble/hashes/utils");
var _modularJs = require("./abstract/modular.js");
var _weierstrassJs = require("./abstract/weierstrass.js");
var _utilsJs = require("./abstract/utils.js");
var _hashToCurveJs = require("./abstract/hash-to-curve.js");
var _shortwUtilsJs = require("./_shortw_utils.js");
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
const secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b)=>(a + b / _2n) / b;
/**
 * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */ function sqrtMod(y) {
    const P = secp256k1P;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P; // x^3, 11
    const b3 = b2 * b2 * y % P; // x^7
    const b6 = (0, _modularJs.pow2)(b3, _3n, P) * b3 % P;
    const b9 = (0, _modularJs.pow2)(b6, _3n, P) * b3 % P;
    const b11 = (0, _modularJs.pow2)(b9, _2n, P) * b2 % P;
    const b22 = (0, _modularJs.pow2)(b11, _11n, P) * b11 % P;
    const b44 = (0, _modularJs.pow2)(b22, _22n, P) * b22 % P;
    const b88 = (0, _modularJs.pow2)(b44, _44n, P) * b44 % P;
    const b176 = (0, _modularJs.pow2)(b88, _88n, P) * b88 % P;
    const b220 = (0, _modularJs.pow2)(b176, _44n, P) * b44 % P;
    const b223 = (0, _modularJs.pow2)(b220, _3n, P) * b3 % P;
    const t1 = (0, _modularJs.pow2)(b223, _23n, P) * b22 % P;
    const t2 = (0, _modularJs.pow2)(t1, _6n, P) * b2 % P;
    const root = (0, _modularJs.pow2)(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y)) throw new Error("Cannot find square root");
    return root;
}
const Fp = (0, _modularJs.Field)(secp256k1P, undefined, undefined, {
    sqrt: sqrtMod
});
const secp256k1 = (0, _shortwUtilsJs.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */ endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k)=>{
            const n = secp256k1N;
            const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
            const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
            const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
            const b2 = a1;
            const POW_2_128 = BigInt("0x100000000000000000000000000000000"); // (2n**128n).toString(16)
            const c1 = divNearest(b2 * k, n);
            const c2 = divNearest(-b1 * k, n);
            let k1 = (0, _modularJs.mod)(k - c1 * a1 - c2 * a2, n);
            let k2 = (0, _modularJs.mod)(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg) k1 = n - k1;
            if (k2neg) k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) throw new Error("splitScalar: Endomorphism failed, k=" + k);
            return {
                k1neg,
                k1,
                k2neg,
                k2
            };
        }
    }
}, (0, _sha256.sha256));
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
const _0n = BigInt(0);
const fe = (x)=>typeof x === "bigint" && _0n < x && x < secp256k1P;
const ge = (x)=>typeof x === "bigint" && _0n < x && x < secp256k1N;
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        const tagH = (0, _sha256.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));
        tagP = (0, _utilsJs.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, _sha256.sha256)((0, _utilsJs.concatBytes)(tagP, ...messages));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
const pointToBytes = (point)=>point.toRawBytes(true).slice(1);
const numTo32b = (n)=>(0, _utilsJs.numberToBytesBE)(n, 32);
const modP = (x)=>(0, _modularJs.mod)(x, secp256k1P);
const modN = (x)=>(0, _modularJs.mod)(x, secp256k1N);
const Point = secp256k1.ProjectivePoint;
const GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
    let p = Point.fromPrivateKey(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside
    const scalar = p.hasEvenY() ? d_ : modN(-d_);
    return {
        scalar: scalar,
        bytes: pointToBytes(p)
    };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */ function lift_x(x) {
    if (!fe(x)) throw new Error("bad x: need 0 < x < p"); // Fail if x ‚â• p.
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.
    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and
    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    p.assertValidity();
    return p;
}
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */ function challenge(...args) {
    return modN((0, _utilsJs.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */ function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */ function schnorrSign(message, privateKey, auxRand = (0, _utils.randomBytes)(32)) {
    const m = (0, _utilsJs.ensureBytes)("message", message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder
    const a = (0, _utilsJs.ensureBytes)("auxRand", auxRand, 32); // Auxiliary random data a: a 32-byte array
    const t = numTo32b(d ^ (0, _utilsJs.bytesToNumberBE)(taggedHash("BIP0340/aux", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    const rand = taggedHash("BIP0340/nonce", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    const k_ = modN((0, _utilsJs.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n
    if (k_ === _0n) throw new Error("sign failed: k is zero"); // Fail if k' = 0.
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'‚ãÖG.
    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px)) throw new Error("sign: Invalid signature produced");
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */ function schnorrVerify(signature, message, publicKey) {
    const sig = (0, _utilsJs.ensureBytes)("signature", signature, 64);
    const m = (0, _utilsJs.ensureBytes)("message", message);
    const pub = (0, _utilsJs.ensureBytes)("publicKey", publicKey, 32);
    try {
        const P = lift_x((0, _utilsJs.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails
        const r = (0, _utilsJs.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.
        if (!fe(r)) return false;
        const s = (0, _utilsJs.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.
        if (!ge(s)) return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
        const R = GmulAdd(P, s, modN(-e)); // R = s‚ãÖG - e‚ãÖP
        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P
        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.
    } catch (error) {
        return false;
    }
}
const schnorr = /* @__PURE__ */ (()=>({
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        utils: {
            randomPrivateKey: secp256k1.utils.randomPrivateKey,
            lift_x,
            pointToBytes,
            numberToBytesBE: (0, _utilsJs.numberToBytesBE),
            bytesToNumberBE: (0, _utilsJs.bytesToNumberBE),
            taggedHash,
            mod: (0, _modularJs.mod)
        }
    }))();
const isoMap = /* @__PURE__ */ (()=>(0, _hashToCurveJs.isogenyMap)(Fp, [
        // xNum
        [
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
            "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
            "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
            "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
        ],
        // xDen
        [
            "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
            "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
            "0x0000000000000000000000000000000000000000000000000000000000000001"
        ],
        // yNum
        [
            "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
            "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
            "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
            "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
        ],
        // yDen
        [
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
            "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
            "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
            "0x0000000000000000000000000000000000000000000000000000000000000001"
        ]
    ].map((i)=>i.map((j)=>BigInt(j)))))();
const mapSWU = /* @__PURE__ */ (()=>(0, _weierstrassJs.mapToCurveSimpleSWU)(Fp, {
        A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
        B: BigInt("1771"),
        Z: Fp.create(BigInt("-11"))
    }))();
const htf = /* @__PURE__ */ (()=>(0, _hashToCurveJs.createHasher)(secp256k1.ProjectivePoint, (scalars)=>{
        const { x, y } = mapSWU(Fp.create(scalars[0]));
        return isoMap(x, y);
    }, {
        DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
        encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: "xmd",
        hash: (0, _sha256.sha256)
    }))();
const hashToCurve = /* @__PURE__ */ (()=>htf.hashToCurve)();
const encodeToCurve = /* @__PURE__ */ (()=>htf.encodeToCurve)();

},{"@noble/hashes/sha256":"bafNi","@noble/hashes/utils":"9UCl3","./abstract/modular.js":"aWzDR","./abstract/weierstrass.js":"dvVS3","./abstract/utils.js":"6xA5w","./abstract/hash-to-curve.js":"xT4Ur","./_shortw_utils.js":"e5PHG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bafNi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sha256", ()=>sha256);
parcelHelpers.export(exports, "sha224", ()=>sha224);
var _sha2Js = require("./_sha2.js");
var _utilsJs = require("./utils.js");
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Choice: a ? b : c
const Chi = (a, b, c)=>a & b ^ ~a & c;
// Majority function, true if any two inpust is true
const Maj = (a, b, c)=>a & b ^ a & c ^ b & c;
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends (0, _sha2Js.SHA2) {
    constructor(){
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
        ];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);
        for(let i = 16; i < 64; i++){
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, _utilsJs.rotr)(W15, 7) ^ (0, _utilsJs.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, _utilsJs.rotr)(W2, 17) ^ (0, _utilsJs.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for(let i = 0; i < 64; i++){
            const sigma1 = (0, _utilsJs.rotr)(E, 6) ^ (0, _utilsJs.rotr)(E, 11) ^ (0, _utilsJs.rotr)(E, 25);
            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, _utilsJs.rotr)(A, 2) ^ (0, _utilsJs.rotr)(A, 13) ^ (0, _utilsJs.rotr)(A, 22);
            const T2 = sigma0 + Maj(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor(){
        super();
        this.A = -1056596264;
        this.B = 914150663;
        this.C = 812702999;
        this.D = -150054599;
        this.E = -4191439;
        this.F = 1750603025;
        this.G = 1694076839;
        this.H = -1090891868;
        this.outputLen = 28;
    }
}
const sha256 = /* @__PURE__ */ (0, _utilsJs.wrapConstructor)(()=>new SHA256());
const sha224 = /* @__PURE__ */ (0, _utilsJs.wrapConstructor)(()=>new SHA224());

},{"./_sha2.js":"jh5lC","./utils.js":"9UCl3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jh5lC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Base SHA2 class (RFC 6234)
parcelHelpers.export(exports, "SHA2", ()=>SHA2);
var _assertJs = require("./_assert.js");
var _utilsJs = require("./utils.js");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
class SHA2 extends (0, _utilsJs.Hash) {
    constructor(blockLen, outputLen, padOffset, isLE){
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, _utilsJs.createView)(this.buffer);
    }
    update(data) {
        (0, _assertJs.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, _utilsJs.toBytes)(data);
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, _utilsJs.createView)(data);
                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, _assertJs.exists)(this);
        (0, _assertJs.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for(let i = pos; i < blockLen; i++)buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, _utilsJs.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
    }
}

},{"./_assert.js":"hpakJ","./utils.js":"9UCl3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hpakJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "number", ()=>number);
parcelHelpers.export(exports, "bool", ()=>bool);
parcelHelpers.export(exports, "bytes", ()=>bytes);
parcelHelpers.export(exports, "hash", ()=>hash);
parcelHelpers.export(exports, "exists", ()=>exists);
parcelHelpers.export(exports, "output", ()=>output);
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
    if (typeof b !== "boolean") throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array)) throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash) {
    if (typeof hash !== "function" || typeof hash.create !== "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash.outputLen);
    number(hash.blockLen);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) throw new Error(`digestInto() expects output buffer of length at least ${min}`);
}
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output
};
exports.default = assert;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9UCl3":[function(require,module,exports) {
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated, we can just drop the import.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "u8", ()=>u8);
parcelHelpers.export(exports, "u32", ()=>u32);
parcelHelpers.export(exports, "createView", ()=>createView);
parcelHelpers.export(exports, "rotr", ()=>rotr);
parcelHelpers.export(exports, "isLE", ()=>isLE);
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ parcelHelpers.export(exports, "bytesToHex", ()=>bytesToHex);
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ parcelHelpers.export(exports, "hexToBytes", ()=>hexToBytes);
parcelHelpers.export(exports, "nextTick", ()=>nextTick);
// Returns control to thread each 'tick' ms to avoid blocking
parcelHelpers.export(exports, "asyncLoop", ()=>asyncLoop);
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */ parcelHelpers.export(exports, "utf8ToBytes", ()=>utf8ToBytes);
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */ parcelHelpers.export(exports, "toBytes", ()=>toBytes);
/**
 * Copies several Uint8Arrays into one.
 */ parcelHelpers.export(exports, "concatBytes", ()=>concatBytes);
// For runtime check if class implements interface
parcelHelpers.export(exports, "Hash", ()=>Hash);
parcelHelpers.export(exports, "checkOpts", ()=>checkOpts);
parcelHelpers.export(exports, "wrapConstructor", ()=>wrapConstructor);
parcelHelpers.export(exports, "wrapConstructorWithOpts", ()=>wrapConstructorWithOpts);
parcelHelpers.export(exports, "wrapXOFConstructorWithOpts", ()=>wrapXOFConstructorWithOpts);
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */ parcelHelpers.export(exports, "randomBytes", ()=>randomBytes);
var _crypto = require("@noble/hashes/crypto");
const u8a = (a)=>a instanceof Uint8Array;
const u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
const u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word, shift)=>word << 32 - shift | word >>> shift;
const isLE = new Uint8Array(new Uint32Array([
    0x11223344
]).buffer)[0] === 0x44;
if (!isLE) throw new Error("Non little-endian hardware is not supported");
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
    if (!u8a(bytes)) throw new Error("Uint8Array expected");
    // pre-caching improves the speed 6x
    let hex = "";
    for(let i = 0; i < bytes.length; i++)hex += hexes[bytes[i]];
    return hex;
}
function hexToBytes(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    const len = hex.length;
    if (len % 2) throw new Error("padded hex string expected, got unpadded hex of length " + len);
    const array = new Uint8Array(len / 2);
    for(let i = 0; i < array.length; i++){
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0) throw new Error("Invalid byte sequence");
        array[i] = byte;
    }
    return array;
}
const nextTick = async ()=>{};
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await nextTick();
        ts += diff;
    }
}
function utf8ToBytes(str) {
    if (typeof str !== "string") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
function toBytes(data) {
    if (typeof data === "string") data = utf8ToBytes(data);
    if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
}
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a)=>{
        if (!u8a(a)) throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
const toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== "[object Object]") throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
}
function wrapConstructor(hashCons) {
    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashCons();
    return hashC;
}
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function randomBytes(bytesLength = 32) {
    if ((0, _crypto.crypto) && typeof (0, _crypto.crypto).getRandomValues === "function") return (0, _crypto.crypto).getRandomValues(new Uint8Array(bytesLength));
    throw new Error("crypto.getRandomValues must be defined");
}

},{"@noble/hashes/crypto":"2lv0W","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2lv0W":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "crypto", ()=>crypto);
const crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aWzDR":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Calculates a modulo b
parcelHelpers.export(exports, "mod", ()=>mod);
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */ // TODO: use field version && remove
parcelHelpers.export(exports, "pow", ()=>pow);
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
parcelHelpers.export(exports, "pow2", ()=>pow2);
// Inverses number over modulo
parcelHelpers.export(exports, "invert", ()=>invert);
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */ parcelHelpers.export(exports, "tonelliShanks", ()=>tonelliShanks);
parcelHelpers.export(exports, "FpSqrt", ()=>FpSqrt);
parcelHelpers.export(exports, "isNegativeLE", ()=>isNegativeLE);
parcelHelpers.export(exports, "validateField", ()=>validateField);
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */ parcelHelpers.export(exports, "FpPow", ()=>FpPow);
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */ parcelHelpers.export(exports, "FpInvertBatch", ()=>FpInvertBatch);
parcelHelpers.export(exports, "FpDiv", ()=>FpDiv);
// This function returns True whenever the value x is a square in the field F.
parcelHelpers.export(exports, "FpIsSquare", ()=>FpIsSquare);
// CURVE.n lengths
parcelHelpers.export(exports, "nLength", ()=>nLength);
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */ parcelHelpers.export(exports, "Field", ()=>Field);
parcelHelpers.export(exports, "FpSqrtOdd", ()=>FpSqrtOdd);
parcelHelpers.export(exports, "FpSqrtEven", ()=>FpSqrtEven);
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use mapKeyToField instead
 */ parcelHelpers.export(exports, "hashToPrivateScalar", ()=>hashToPrivateScalar);
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */ parcelHelpers.export(exports, "getFieldBytesLength", ()=>getFieldBytesLength);
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */ parcelHelpers.export(exports, "getMinHashLength", ()=>getMinHashLength);
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */ parcelHelpers.export(exports, "mapHashToField", ()=>mapHashToField);
var _utilsJs = require("./utils.js");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
// prettier-ignore
const _9n = BigInt(9), _16n = BigInt(16);
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
function pow(num, power, modulo) {
    if (modulo <= _0n || power < _0n) throw new Error("Expected power/modulo > 0");
    if (modulo === _1n) return _0n;
    let res = _1n;
    while(power > _0n){
        if (power & _1n) res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
    }
    return res;
}
function pow2(x, power, modulo) {
    let res = x;
    while(power-- > _0n){
        res *= res;
        res %= modulo;
    }
    return res;
}
function invert(number, modulo) {
    if (number === _0n || modulo <= _0n) throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while(a !== _0n){
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n) throw new Error("invert: does not exist");
    return mod(x, modulo);
}
function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p) ‚â° 1    if a is a square (mod p)
    // (a | p) ‚â° -1   if a is not a square (mod p)
    // (a | p) ‚â° 0    if a ‚â° 0 (mod p)
    const legendreC = (P - _1n) / _2n;
    let Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);
    // Step 2: Select a non-square z such that (z | p) ‚â° -1 and set c ‚â° zq
    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);
    // Fast-path
    if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error("Cannot find square root");
            return root;
        };
    }
    // Slow-path
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        // Step 0: Check that n is indeed a square: (n | p) should not be ‚â° -1
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error("Cannot find square root");
        let r = S;
        // TODO: will fail at Fp2/etc
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
        let x = Fp.pow(n, Q1div2); // first guess at the square root
        let b = Fp.pow(n, Q); // first guess at the fudge factor
        while(!Fp.eql(b, Fp.ONE)){
            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
            // Find m such b^(2^m)==1
            let m = 1;
            for(let t2 = Fp.sqr(b); m < r; m++){
                if (Fp.eql(t2, Fp.ONE)) break;
                t2 = Fp.sqr(t2); // t2 *= t2
            }
            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
            g = Fp.sqr(ge); // g = ge * ge
            x = Fp.mul(x, ge); // x *= ge
            b = Fp.mul(b, g); // b *= g
            r = m;
        }
        return x;
    };
}
function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P ‚â° 3 (mod 4)
    // ‚àön = n^((P+1)/4)
    if (P % _4n === _3n) {
        // Not all roots possible!
        // const ORDER =
        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
        // const NUM = 72057594037927816n;
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
            const root = Fp.pow(n, p1div4);
            // Throw if root**2 != n
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error("Cannot find square root");
            return root;
        };
    }
    // Atkin algorithm for q ‚â° 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n)) throw new Error("Cannot find square root");
            return root;
        };
    }
    // P ‚â° 9 (mod 16)
    _9n;
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
const isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;
// prettier-ignore
const FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function validateField(field) {
    const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map, val)=>{
        map[val] = "function";
        return map;
    }, initial);
    return (0, _utilsJs.validateObject)(field, opts);
}
function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n) throw new Error("Expected power > 0");
    if (power === _0n) return f.ONE;
    if (power === _1n) return num;
    let p = f.ONE;
    let d = num;
    while(power > _0n){
        if (power & _1n) p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
    }
    return p;
}
function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    const lastMultiplied = nums.reduce((acc, num, i)=>{
        if (f.is0(num)) return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    const inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i)=>{
        if (f.is0(num)) return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
    }, inverted);
    return tmp;
}
function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
}
function FpIsSquare(f) {
    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic
    return (x)=>{
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
}
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return {
        nBitLength: _nBitLength,
        nByteLength
    };
}
function Field(ORDER, bitLen, isLE = false, redef = {}) {
    if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
    if (BYTES > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, _utilsJs.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num)=>mod(num, ORDER),
        isValid: (num)=>{
            if (typeof num !== "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num)=>num === _0n,
        isOdd: (num)=>(num & _1n) === _1n,
        neg: (num)=>mod(-num, ORDER),
        eql: (lhs, rhs)=>lhs === rhs,
        sqr: (num)=>mod(num * num, ORDER),
        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),
        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),
        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),
        pow: (num, power)=>FpPow(f, num, power),
        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num)=>num * num,
        addN: (lhs, rhs)=>lhs + rhs,
        subN: (lhs, rhs)=>lhs - rhs,
        mulN: (lhs, rhs)=>lhs * rhs,
        inv: (num)=>invert(num, ORDER),
        sqrt: redef.sqrt || ((n)=>sqrtP(f, n)),
        invertBatch: (lst)=>FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c)=>c ? b : a,
        toBytes: (num)=>isLE ? (0, _utilsJs.numberToBytesLE)(num, BYTES) : (0, _utilsJs.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes)=>{
            if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, _utilsJs.bytesToNumberLE)(bytes) : (0, _utilsJs.bytesToNumberBE)(bytes);
        }
    });
    return Object.freeze(f);
}
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, _utilsJs.ensureBytes)("privateHash", hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE ? (0, _utilsJs.bytesToNumberLE)(hash) : (0, _utilsJs.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint") throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024) throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE ? (0, _utilsJs.bytesToNumberBE)(key) : (0, _utilsJs.bytesToNumberLE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, _utilsJs.numberToBytesLE)(reduced, fieldLen) : (0, _utilsJs.numberToBytesBE)(reduced, fieldLen);
}

},{"./utils.js":"6xA5w","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6xA5w":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ parcelHelpers.export(exports, "bytesToHex", ()=>bytesToHex);
parcelHelpers.export(exports, "numberToHexUnpadded", ()=>numberToHexUnpadded);
parcelHelpers.export(exports, "hexToNumber", ()=>hexToNumber);
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ parcelHelpers.export(exports, "hexToBytes", ()=>hexToBytes);
// BE: Big Endian, LE: Little Endian
parcelHelpers.export(exports, "bytesToNumberBE", ()=>bytesToNumberBE);
parcelHelpers.export(exports, "bytesToNumberLE", ()=>bytesToNumberLE);
parcelHelpers.export(exports, "numberToBytesBE", ()=>numberToBytesBE);
parcelHelpers.export(exports, "numberToBytesLE", ()=>numberToBytesLE);
// Unpadded, rarely used
parcelHelpers.export(exports, "numberToVarBytesBE", ()=>numberToVarBytesBE);
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */ parcelHelpers.export(exports, "ensureBytes", ()=>ensureBytes);
/**
 * Copies several Uint8Arrays into one.
 */ parcelHelpers.export(exports, "concatBytes", ()=>concatBytes);
parcelHelpers.export(exports, "equalBytes", ()=>equalBytes);
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */ parcelHelpers.export(exports, "utf8ToBytes", ()=>utf8ToBytes);
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */ parcelHelpers.export(exports, "bitLen", ()=>bitLen);
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */ parcelHelpers.export(exports, "bitGet", ()=>bitGet);
parcelHelpers.export(exports, "bitSet", ()=>bitSet);
parcelHelpers.export(exports, "bitMask", ()=>bitMask);
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */ parcelHelpers.export(exports, "createHmacDrbg", ()=>createHmacDrbg);
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
parcelHelpers.export(exports, "validateObject", ()=>validateObject) // validate type tests
 // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
 // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
 // // Should fail type-check
 // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
 // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
 // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
 // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
;
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const u8a = (a)=>a instanceof Uint8Array;
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
    if (!u8a(bytes)) throw new Error("Uint8Array expected");
    // pre-caching improves the speed 6x
    let hex = "";
    for(let i = 0; i < bytes.length; i++)hex += hexes[bytes[i]];
    return hex;
}
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    // Big Endian
    return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    const len = hex.length;
    if (len % 2) throw new Error("padded hex string expected, got unpadded hex of length " + len);
    const array = new Uint8Array(len / 2);
    for(let i = 0; i < array.length; i++){
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0) throw new Error("Invalid byte sequence");
        array[i] = byte;
    }
    return array;
}
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
    if (!u8a(bytes)) throw new Error("Uint8Array expected");
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") try {
        res = hexToBytes(hex);
    } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
    else if (u8a(hex)) // Uint8Array.from() instead of hash.slice() because node.js Buffer
    // is instance of Uint8Array, and its slice() creates **mutable** copy
    res = Uint8Array.from(hex);
    else throw new Error(`${title} must be hex string or Uint8Array`);
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a)=>{
        if (!u8a(a)) throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
function equalBytes(b1, b2) {
    // We don't care about timing attacks here
    if (b1.length !== b2.length) return false;
    for(let i = 0; i < b1.length; i++)if (b1[i] !== b2[i]) return false;
    return true;
}
function utf8ToBytes(str) {
    if (typeof str !== "string") throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
function bitLen(n) {
    let len;
    for(len = 0; n > _0n; n >>= _1n, len += 1);
    return len;
}
function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n;
}
const bitSet = (n, pos, value)=>{
    return n | (value ? _1n : _0n) << BigInt(pos);
};
const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;
// DRBG
const u8n = (data)=>new Uint8Array(data); // creates Uint8Array
const u8fr = (arr)=>Uint8Array.from(arr); // another shortcut
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2) throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2) throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function") throw new Error("hmacFn must be a function");
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = ()=>{
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n())=>{
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([
            0x00
        ]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0) return;
        k = h(u8fr([
            0x01
        ]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = ()=>{
        // HMAC-DRBG generate() function
        if (i++ >= 1000) throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while(len < qByteLen){
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred)=>{
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while(!(res = pred(gen())))reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val)=>typeof val === "bigint",
    function: (val)=>typeof val === "function",
    boolean: (val)=>typeof val === "boolean",
    string: (val)=>typeof val === "string",
    stringOrUint8Array: (val)=>typeof val === "string" || val instanceof Uint8Array,
    isSafeInteger: (val)=>Number.isSafeInteger(val),
    array: (val)=>Array.isArray(val),
    field: (val, object)=>object.Fp.isValid(val),
    hash: (val)=>typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional)=>{
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function") throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === undefined) return;
        if (!checkVal(val, object)) throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    };
    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);
    return object;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dvVS3":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y¬≤ = x¬≥ + ax + b
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DER", ()=>DER);
parcelHelpers.export(exports, "weierstrassPoints", ()=>weierstrassPoints);
parcelHelpers.export(exports, "weierstrass", ()=>weierstrass);
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */ parcelHelpers.export(exports, "SWUFpSqrtRatio", ()=>SWUFpSqrtRatio);
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */ parcelHelpers.export(exports, "mapToCurveSimpleSWU", ()=>mapToCurveSimpleSWU);
var _modularJs = require("./modular.js");
var _utilsJs = require("./utils.js");
var _curveJs = require("./curve.js");
function validatePointOpts(curve) {
    const opts = (0, _curveJs.validateBasic)(curve);
    _utilsJs.validateObject(opts, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const { endo, Fp, a } = opts;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({
        ...opts
    });
}
// ASN.1 DER encoding utilities
const { bytesToNumberBE: b2n, hexToBytes: h2b } = _utilsJs;
const DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
        constructor(m = ""){
            super(m);
        }
    },
    _parseInt (data) {
        const { Err: E } = DER;
        if (data.length < 2 || data[0] !== 0x02) throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len) throw new E("Invalid signature integer: wrong length");
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        if (res[0] & 128) throw new E("Invalid signature integer: negative");
        if (res[0] === 0x00 && !(res[1] & 128)) throw new E("Invalid signature integer: unnecessary leading zero");
        return {
            d: b2n(res),
            l: data.subarray(len + 2)
        }; // d is data, l is left
    },
    toSig (hex) {
        // parse DER signature
        const { Err: E } = DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array)) throw new Error("ui8a expected");
        let l = data.length;
        if (l < 2 || data[0] != 0x30) throw new E("Invalid signature tag");
        if (data[1] !== l - 2) throw new E("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
        if (rBytesLeft.length) throw new E("Invalid signature: left bytes after parsing");
        return {
            r,
            s
        };
    },
    hexFromSig (sig) {
        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
        const slice = (s)=>Number.parseInt(s[0], 16) & 8 ? "00" + s : s;
        const h = (num)=>{
            const hex = num.toString(16);
            return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    }
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{
        const a = point.toAffine();
        return _utilsJs.concatBytes(Uint8Array.from([
            0x04
        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes)=>{
        // const head = bytes[0];
        const tail = bytes.subarray(1);
        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return {
            x,
            y
        };
    });
    /**
     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula
     * @returns y¬≤
     */ function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
    }
    // Validate whether the passed curve params are valid.
    // We check if curve equation works for generator point.
    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
    // ProjectivePoint class has not been initialized yet.
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error("bad generator point: equation left != right");
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
        if (!isWithinCurveOrder(num)) throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
            if (key instanceof Uint8Array) key = _utilsJs.bytesToHex(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== "string" || !lengths.includes(key.length)) throw new Error("Invalid key");
            key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
            num = typeof key === "bigint" ? key : _utilsJs.bytesToNumberBE((0, _utilsJs.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey) num = _modularJs.mod(num, n); // disabled by default, enabled for BLS
        assertGE(num); // num in range [1..N-1]
        return num;
    }
    const pointPrecomputes = new Map();
    function assertPrjPoint(other) {
        if (!(other instanceof Point)) throw new Error("ProjectivePoint expected");
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ‚àã (x=x/z, y=y/z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */ class Point {
        constructor(px, py, pz){
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px)) throw new Error("x required");
            if (py == null || !Fp.isValid(py)) throw new Error("y required");
            if (pz == null || !Fp.isValid(pz)) throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error("invalid affine point");
            if (p instanceof Point) throw new Error("projective point not allowed");
            const is0 = (i)=>Fp.eql(i, Fp.ZERO);
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y)) return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */ static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p)=>p.pz));
            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */ static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, _utilsJs.ensureBytes)("pointHex", hex)));
            P.assertValidity();
            return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            if (this.is0()) {
                // (0, 1, 0) aka ZERO is invalid in most contexts.
                // In BLS, ZERO can be serialized, so we allow it.
                // (0, 0, 0) is wrong representation of ZERO and is always invalid.
                if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;
                throw new Error("bad point: ZERO");
            }
            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
            const { x, y } = this.toAffine();
            // Check if x, y are valid field elements
            if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error("bad point: x or y not FE");
            const left = Fp.sqr(y); // y¬≤
            const right = weierstrassEquation(x); // x¬≥ + ax + b
            if (!Fp.eql(left, right)) throw new Error("bad point: equation left != right");
            if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (Fp.isOdd) return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */ equals(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */ negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp)=>{
                const toInv = Fp.invertBatch(comp.map((p)=>p.pz));
                return comp.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);
            });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */ multiplyUnsafe(n) {
            const I = Point.ZERO;
            if (n === _0n) return I;
            assertGE(n); // Will throw on 0
            if (n === _1n) return this;
            const { endo } = CURVE;
            if (!endo) return wnaf.unsafeLadder(this, n);
            // Apply endomorphism
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let k1p = I;
            let k2p = I;
            let d = this;
            while(k1 > _0n || k2 > _0n){
                if (k1 & _1n) k1p = k1p.add(d);
                if (k2 & _1n) k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg) k1p = k1p.negate();
            if (k2neg) k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */ multiply(scalar) {
            assertGE(scalar);
            let n = scalar;
            let point, fake; // Fake point is used to const-time mult
            const { endo } = CURVE;
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
                let { p: k1p, f: f1p } = this.wNAF(k1);
                let { p: k2p, f: f2p } = this.wNAF(k2);
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            } else {
                const { p, f } = this.wNAF(n);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([
                point,
                fake
            ])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */ multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            const mul = (P, a // Select faster multiply() method
            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ‚àã (x=x/z, y=y/z)
        toAffine(iz) {
            const { px: x, py: y, pz: z } = this;
            const is0 = this.is0();
            // If invZ was 0, we return zero point. However we still want to execute
            // all operations, so we replace invZ with a random number, 1.
            if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);
            const ax = Fp.mul(x, iz);
            const ay = Fp.mul(y, iz);
            const zz = Fp.mul(z, iz);
            if (is0) return {
                x: Fp.ZERO,
                y: Fp.ZERO
            };
            if (!Fp.eql(zz, Fp.ONE)) throw new Error("invZ was invalid");
            return {
                x: ax,
                y: ay
            };
        }
        isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n) return true; // No subgroups, always torsion-free
            if (isTorsionFree) return isTorsionFree(Point, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n) return this; // Fast-path
            if (clearCofactor) return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return _utilsJs.bytesToHex(this.toRawBytes(isCompressed));
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = (0, _curveJs.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    // Validate if generator point is on curve
    return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
    };
}
function validateOpts(curve) {
    const opts = (0, _curveJs.validateBasic)(curve);
    _utilsJs.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    });
    return Object.freeze({
        lowS: true,
        ...opts
    });
}
function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
    }
    function modN(a) {
        return _modularJs.mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return _modularJs.invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes (_c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp.toBytes(a.x);
            const cat = _utilsJs.concatBytes;
            if (isCompressed) return cat(Uint8Array.from([
                point.hasEvenY() ? 0x02 : 0x03
            ]), x);
            else return cat(Uint8Array.from([
                0x04
            ]), x, Fp.toBytes(a.y));
        },
        fromBytes (bytes) {
            const len = bytes.length;
            const head = bytes[0];
            const tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                const x = _utilsJs.bytesToNumberBE(tail);
                if (!isValidFieldElement(x)) throw new Error("Point is not on curve");
                const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b
                let y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4
                const isYOdd = (y & _1n) === _1n;
                // ECDSA
                const isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd) y = Fp.neg(y);
                return {
                    x,
                    y
                };
            } else if (len === uncompressedLen && head === 0x04) {
                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return {
                    x,
                    y
                };
            } else throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
    });
    const numToNByteStr = (num)=>_utilsJs.bytesToHex(_utilsJs.numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    const slcNum = (b, from, to)=>_utilsJs.bytesToNumberBE(b.slice(from, to));
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */ class Signature {
        constructor(r, s, recovery){
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
            const l = CURVE.nByteLength;
            hex = (0, _utilsJs.ensureBytes)("compactSignature", hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
            const { r, s } = DER.toSig((0, _utilsJs.ensureBytes)("DER", hex));
            return new Signature(r, s);
        }
        assertValidity() {
            // can use assertGE here
            if (!isWithinCurveOrder(this.r)) throw new Error("r must be 0 < r < CURVE.n");
            if (!isWithinCurveOrder(this.s)) throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN((0, _utilsJs.ensureBytes)("msgHash", msgHash)); // Truncate hash
            if (rec == null || ![
                0,
                1,
                2,
                3
            ].includes(rec)) throw new Error("recovery id invalid");
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER) throw new Error("recovery id 2 or 3 invalid");
            const prefix = (rec & 1) === 0 ? "02" : "03";
            const R = Point.fromHex(prefix + numToNByteStr(radj));
            const ir = invN(radj); // r^-1
            const u1 = modN(-h * ir); // -hr^-1
            const u2 = modN(s * ir); // sr^-1
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q) throw new Error("point at infinify"); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return _utilsJs.hexToBytes(this.toDERHex());
        }
        toDERHex() {
            return DER.hexFromSig({
                r: this.r,
                s: this.s
            });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return _utilsJs.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
    }
    const utils = {
        isValidPrivateKey (privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            } catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */ randomPrivateKey: ()=>{
            const length = _modularJs.getMinHashLength(CURVE.n);
            return _modularJs.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */ precompute (windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        }
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */ function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */ function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr) return len === compressedLen || len === uncompressedLen;
        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point) return true;
        return false;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */ function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA)) throw new Error("first arg must be private key");
        if (!isProbPub(publicB)) throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = CURVE.bits2int || function(bytes) {
        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
        // for some cases, since bytes.length * 8 is not actual bitLength.
        const num = _utilsJs.bytesToNumberBE(bytes); // check for == u8 done here
        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
        return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes)); // can't use bytesToNumberBE here
    };
    // NOTE: pads output with zero as per spec
    const ORDER_MASK = _utilsJs.bitMask(CURVE.nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */ function int2octets(num) {
        if (typeof num !== "bigint") throw new Error("bigint expected");
        if (!(_0n <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        // works with order, can have different size than numToField!
        return _utilsJs.numberToBytesBE(num, CURVE.nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
    // Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if ([
            "recovered",
            "canonical"
        ].some((k)=>k in opts)) throw new Error("sign() legacy options not supported");
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, _utilsJs.ensureBytes)("msgHash", msgHash);
        if (prehash) msgHash = (0, _utilsJs.ensureBytes)("prehashed msgHash", hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        const seedArgs = [
            int2octets(d),
            int2octets(h1int)
        ];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, _utilsJs.ensureBytes)("extraEntropy", e)); // check for being bytes
        }
        const seed = _utilsJs.concatBytes(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N
            const ik = invN(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
            const r = modN(q.x); // r = q.x mod n
            if (r === _0n) return;
            // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            const s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n) return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return {
            seed,
            k2sig
        };
    }
    const defaultSigOpts = {
        lowS: CURVE.lowS,
        prehash: false
    };
    const defaultVerOpts = {
        lowS: CURVE.lowS,
        prehash: false
    };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G √ó k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */ function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
        const C = CURVE;
        const drbg = _utilsJs.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1‚ãÖG - U2‚ãÖP
     *   mod(R.x, n) == r
     * ```
     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, _utilsJs.ensureBytes)("msgHash", msgHash);
        publicKey = (0, _utilsJs.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts) throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = undefined;
        let P;
        try {
            if (typeof sg === "string" || sg instanceof Uint8Array) // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
            // Since DER can also be 2*nByteLength bytes, we check for it first.
            try {
                _sig = Signature.fromDER(sg);
            } catch (derError) {
                if (!(derError instanceof DER.Err)) throw derError;
                _sig = Signature.fromCompact(sg);
            }
            else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
                const { r, s } = sg;
                _sig = new Signature(r, s);
            } else throw new Error("PARSE");
            P = Point.fromHex(publicKey);
        } catch (error) {
            if (error.message === "PARSE") throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
            return false;
        }
        if (lowS && _sig.hasHighS()) return false;
        if (prehash) msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        const is = invN(s); // s^-1
        const u1 = modN(h * is); // u1 = hs^-1 mod n
        const u2 = modN(r * is); // u2 = rs^-1 mod n
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1‚ãÖG + u2‚ãÖP
        if (!R) return false;
        const v = modN(R.x);
        return v === r;
    }
    return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
    };
}
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v)=>{
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for(let i = c1; i > _1n; i--){
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return {
            isValid: isQR,
            value: tv3
        };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v)=>{
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return {
                isValid: isQR,
                value: y
            }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp, opts) {
    _modularJs.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error("mapToCurveSimpleSWU: invalid opts");
    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd) throw new Error("Fp.isOdd is not implemented!");
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u)=>{
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        x = Fp.div(x, tv4); // 25.   x = x / tv4
        return {
            x,
            y
        };
    };
}

},{"./modular.js":"aWzDR","./utils.js":"6xA5w","./curve.js":"37yfg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"37yfg":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
parcelHelpers.export(exports, "wNAF", ()=>wNAF);
parcelHelpers.export(exports, "validateBasic", ()=>validateBasic);
var _modularJs = require("./modular.js");
var _utilsJs = require("./utils.js");
const _0n = BigInt(0);
const _1n = BigInt(1);
function wNAF(c, bits) {
    const constTimeNegate = (condition, item)=>{
        const neg = item.negate();
        return condition ? neg : item;
    };
    const opts = (W)=>{
        const windows = Math.ceil(bits / W) + 1; // +1, because
        const windowSize = 2 ** (W - 1); // -1 because we skip zero
        return {
            windows,
            windowSize
        };
    };
    return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder (elm, n) {
            let p = c.ZERO;
            let d = elm;
            while(n > _0n){
                if (n & _1n) p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
         * - ùëä is the window size
         * - ùëõ is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */ precomputeWindow (elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base = p;
            for(let window = 0; window < windows; window++){
                base = p;
                points.push(base);
                // =1, because we skip zero
                for(let i = 1; i < windowSize; i++){
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */ wNAF (W, precomputes, n) {
            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
            // But need to carefully remove other checks before wNAF. ORDER == bits here
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for(let window = 0; window < windows; window++){
                const offset = window * windowSize;
                // Extract W bits.
                let wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                // there is negate now: it is possible that negated element from low value
                // would be the same as high element, which will create carry into next window.
                // It's not obvious how this can fail, but still worth investigating later.
                // Check if we're onto Zero point.
                // Add random point inside current window to f.
                const offset1 = offset;
                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                const cond1 = window % 2 !== 0;
                const cond2 = wbits < 0;
                if (wbits === 0) // The most important part for const-time getPublicKey
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                else p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
            // Even if the variable is still unused, there are some checks which will
            // throw an exception, so compiler needs to prove they won't happen, which is hard.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return {
                p,
                f
            };
        },
        wNAFCached (P, precomputesMap, n, transform) {
            // @ts-ignore
            const W = P._WINDOW_SIZE || 1;
            // Calculate precomputes on a first run, reuse them after
            let comp = precomputesMap.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) precomputesMap.set(P, transform(comp));
            }
            return this.wNAF(W, comp, n);
        }
    };
}
function validateBasic(curve) {
    (0, _modularJs.validateField)(curve.Fp);
    (0, _utilsJs.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    });
    // Set defaults
    return Object.freeze({
        ...(0, _modularJs.nLength)(curve.n, curve.nBitLength),
        ...curve,
        p: curve.Fp.ORDER
    });
}

},{"./modular.js":"aWzDR","./utils.js":"6xA5w","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"xT4Ur":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
parcelHelpers.export(exports, "expand_message_xmd", ()=>expand_message_xmd);
// Produces a uniformly random byte string using an extendable-output function (XOF) H.
// 1. The collision resistance of H MUST be at least k bits.
// 2. H MUST be an XOF that has been proved indifferentiable from
//    a random oracle under a reasonable cryptographic assumption.
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
parcelHelpers.export(exports, "expand_message_xof", ()=>expand_message_xof);
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
 * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */ parcelHelpers.export(exports, "hash_to_field", ()=>hash_to_field);
parcelHelpers.export(exports, "isogenyMap", ()=>isogenyMap);
parcelHelpers.export(exports, "createHasher", ()=>createHasher);
var _modularJs = require("./modular.js");
var _utilsJs = require("./utils.js");
function validateDST(dst) {
    if (dst instanceof Uint8Array) return dst;
    if (typeof dst === "string") return (0, _utilsJs.utf8ToBytes)(dst);
    throw new Error("DST must be Uint8Array or string");
}
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = (0, _utilsJs.bytesToNumberBE);
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    if (value < 0 || value >= 1 << 8 * length) throw new Error(`bad I2OSP call: value=${value} length=${length}`);
    const res = Array.from({
        length
    }).fill(0);
    for(let i = length - 1; i >= 0; i--){
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for(let i = 0; i < a.length; i++)arr[i] = a[i] ^ b[i];
    return arr;
}
function isBytes(item) {
    if (!(item instanceof Uint8Array)) throw new Error("Uint8Array expected");
}
function isNum(item) {
    if (!Number.isSafeInteger(item)) throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
    isBytes(msg);
    isBytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255) DST = H((0, _utilsJs.concatBytes)((0, _utilsJs.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255) throw new Error("Invalid xmd length");
    const DST_prime = (0, _utilsJs.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, _utilsJs.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, _utilsJs.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for(let i = 1; i <= ell; i++){
        const args = [
            strxor(b_0, b[i - 1]),
            i2osp(i + 1, 1),
            DST_prime
        ];
        b[i] = H((0, _utilsJs.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, _utilsJs.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    isBytes(msg);
    isBytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({
            dkLen
        }).update((0, _utilsJs.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255) throw new Error("expand_message_xof: invalid lenInBytes");
    return H.create({
        dkLen: lenInBytes
    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)
    .update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
    (0, _utilsJs.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
    });
    const { p, k, m, hash, expand, DST: _DST } = options;
    isBytes(msg);
    isNum(count);
    const DST = validateDST(_DST);
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === "xmd") prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    else if (expand === "xof") prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    else if (expand === "_internal_pass") // for internal tests only
    prb = msg;
    else throw new Error('expand must be "xmd" or "xof"');
    const u = new Array(count);
    for(let i = 0; i < count; i++){
        const e = new Array(m);
        for(let j = 0; j < m; j++){
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, _modularJs.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
function isogenyMap(field, map) {
    // Make same order as in spec
    const COEFF = map.map((i)=>Array.from(i).reverse());
    return (x, y)=>{
        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen); // xNum / xDen
        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
        return {
            x,
            y
        };
    };
}
function createHasher(Point, mapToCurve, def) {
    if (typeof mapToCurve !== "function") throw new Error("mapToCurve() must be defined");
    return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve (msg, options) {
            const u = hash_to_field(msg, 2, {
                ...def,
                DST: def.DST,
                ...options
            });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve (msg, options) {
            const u = hash_to_field(msg, 1, {
                ...def,
                DST: def.encodeDST,
                ...options
            });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
        }
    };
}

},{"./modular.js":"aWzDR","./utils.js":"6xA5w","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e5PHG":[function(require,module,exports) {
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// connects noble-curves to noble-hashes
parcelHelpers.export(exports, "getHash", ()=>getHash);
parcelHelpers.export(exports, "createCurve", ()=>createCurve);
var _hmac = require("@noble/hashes/hmac");
var _utils = require("@noble/hashes/utils");
var _weierstrassJs = require("./abstract/weierstrass.js");
function getHash(hash) {
    return {
        hash,
        hmac: (key, ...msgs)=>(0, _hmac.hmac)(hash, key, (0, _utils.concatBytes)(...msgs)),
        randomBytes: (0, _utils.randomBytes)
    };
}
function createCurve(curveDef, defHash) {
    const create = (hash)=>(0, _weierstrassJs.weierstrass)({
            ...curveDef,
            ...getHash(hash)
        });
    return Object.freeze({
        ...create(defHash),
        create
    });
}

},{"@noble/hashes/hmac":"5oE1D","@noble/hashes/utils":"9UCl3","./abstract/weierstrass.js":"dvVS3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5oE1D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// HMAC (RFC 2104)
parcelHelpers.export(exports, "HMAC", ()=>HMAC);
parcelHelpers.export(exports, "hmac", ()=>hmac);
var _assertJs = require("./_assert.js");
var _utilsJs = require("./utils.js");
class HMAC extends (0, _utilsJs.Hash) {
    constructor(hash, _key){
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assertJs.hash)(hash);
        const key = (0, _utilsJs.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for(let i = 0; i < pad.length; i++)pad[i] ^= 106;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        (0, _assertJs.exists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, _assertJs.exists)(this);
        (0, _assertJs.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key)=>new HMAC(hash, key);

},{"./_assert.js":"hpakJ","./utils.js":"9UCl3","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"048Kw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "recoverAddress", ()=>recoverAddress);
var _publicKeyToAddressJs = require("../../accounts/utils/publicKeyToAddress.js");
var _recoverPublicKeyJs = require("./recoverPublicKey.js");
async function recoverAddress({ hash, signature }) {
    return (0, _publicKeyToAddressJs.publicKeyToAddress)(await (0, _recoverPublicKeyJs.recoverPublicKey)({
        hash: hash,
        signature
    }));
}

},{"../../accounts/utils/publicKeyToAddress.js":"auNu4","./recoverPublicKey.js":"1vIHd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"auNu4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Converts an ECDSA public key to an address.
 *
 * @param publicKey The public key to convert.
 *
 * @returns The address.
 */ parcelHelpers.export(exports, "publicKeyToAddress", ()=>publicKeyToAddress);
var _getAddressJs = require("../../utils/address/getAddress.js");
var _keccak256Js = require("../../utils/hash/keccak256.js");
function publicKeyToAddress(publicKey) {
    const address = (0, _keccak256Js.keccak256)(`0x${publicKey.substring(4)}`).substring(26);
    return (0, _getAddressJs.checksumAddress)(`0x${address}`);
}

},{"../../utils/address/getAddress.js":"hjZaw","../../utils/hash/keccak256.js":"cpYiL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1vIHd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "recoverPublicKey", ()=>recoverPublicKey);
var _isHexJs = require("../data/isHex.js");
var _fromHexJs = require("../encoding/fromHex.js");
var _toHexJs = require("../encoding/toHex.js");
async function recoverPublicKey({ hash, signature }) {
    const signatureHex = (0, _isHexJs.isHex)(signature) ? signature : (0, _toHexJs.toHex)(signature);
    const hashHex = (0, _isHexJs.isHex)(hash) ? hash : (0, _toHexJs.toHex)(hash);
    // Derive v = recoveryId + 27 from end of the signature (27 is added when signing the message)
    // The recoveryId represents the y-coordinate on the secp256k1 elliptic curve and can have a value [0, 1].
    let v = (0, _fromHexJs.hexToNumber)(`0x${signatureHex.slice(130)}`);
    if (v === 0 || v === 1) v += 27;
    const { secp256k1 } = await require("241bc89b98ad17cc");
    const publicKey = secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(v - 27).recoverPublicKey(hashHex.substring(2)).toHex(false);
    return `0x${publicKey}`;
}

},{"../data/isHex.js":"bEohQ","../encoding/fromHex.js":"5gdtu","../encoding/toHex.js":"9rk4U","241bc89b98ad17cc":"k9e2O","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k9e2O":[function(require,module,exports) {
module.exports = Promise.resolve(module.bundle.root("k8xYt"));

},{}],"b8QeV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "recoverMessageAddress", ()=>recoverMessageAddress);
var _hashMessageJs = require("./hashMessage.js");
var _recoverAddressJs = require("./recoverAddress.js");
async function recoverMessageAddress({ message, signature }) {
    return (0, _recoverAddressJs.recoverAddress)({
        hash: (0, _hashMessageJs.hashMessage)(message),
        signature
    });
}

},{"./hashMessage.js":"44RYQ","./recoverAddress.js":"048Kw","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"44RYQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hashMessage", ()=>hashMessage);
var _stringsJs = require("../../constants/strings.js");
var _concatJs = require("../data/concat.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _keccak256Js = require("../hash/keccak256.js");
function hashMessage(message, to_) {
    const messageBytes = (()=>{
        if (typeof message === "string") return (0, _toBytesJs.stringToBytes)(message);
        if (message.raw instanceof Uint8Array) return message.raw;
        return (0, _toBytesJs.toBytes)(message.raw);
    })();
    const prefixBytes = (0, _toBytesJs.stringToBytes)(`${(0, _stringsJs.presignMessagePrefix)}${messageBytes.length}`);
    return (0, _keccak256Js.keccak256)((0, _concatJs.concat)([
        prefixBytes,
        messageBytes
    ]), to_);
}

},{"../../constants/strings.js":"hFaqt","../data/concat.js":"x7umB","../encoding/toBytes.js":"jsem0","../hash/keccak256.js":"cpYiL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"wNB8S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Verify that a message was signed by the provided address.
 *
 * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.
 *        It is highly recommended to use `publicClient.verifyMessage` instead to ensure
 *        wallet interoperability.
 *
 * - Docs {@link https://viem.sh/docs/utilities/verifyMessage}
 *
 * @param parameters - {@link VerifyMessageParameters}
 * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}
 */ parcelHelpers.export(exports, "verifyMessage", ()=>verifyMessage);
var _getAddressJs = require("../address/getAddress.js");
var _isAddressEqualJs = require("../address/isAddressEqual.js");
var _recoverMessageAddressJs = require("./recoverMessageAddress.js");
async function verifyMessage({ address, message, signature }) {
    return (0, _isAddressEqualJs.isAddressEqual)((0, _getAddressJs.getAddress)(address), await (0, _recoverMessageAddressJs.recoverMessageAddress)({
        message,
        signature
    }));
}

},{"../address/getAddress.js":"hjZaw","../address/isAddressEqual.js":"dVquf","./recoverMessageAddress.js":"b8QeV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cdh1H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ContentTypeText", ()=>n);
parcelHelpers.export(exports, "Encoding", ()=>t);
parcelHelpers.export(exports, "TextCodec", ()=>r);
var _contentTypePrimitives = require("@xmtp/content-type-primitives");
const n = new (0, _contentTypePrimitives.ContentTypeId)({
    authorityId: "xmtp.org",
    typeId: "text",
    versionMajor: 1,
    versionMinor: 0
});
var t;
!function(e) {
    e.utf8 = "UTF-8", e.unknown = "unknown";
}(t || (t = {}));
class r {
    get contentType() {
        return n;
    }
    encode(e) {
        return {
            type: n,
            parameters: {
                encoding: t.utf8
            },
            content: (new TextEncoder).encode(e)
        };
    }
    decode(e) {
        if (e.parameters.encoding !== t.utf8) throw new Error(`unrecognized encoding ${e.parameters.encoding}`);
        return (new TextDecoder).decode(e.content);
    }
    fallback() {}
    shouldPush() {
        return !0;
    }
}

},{"@xmtp/content-type-primitives":"h2119","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h2119":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ContentTypeId", ()=>t);
class t {
    authorityId;
    typeId;
    versionMajor;
    versionMinor;
    constructor(t){
        this.authorityId = t.authorityId, this.typeId = t.typeId, this.versionMajor = t.versionMajor, this.versionMinor = t.versionMinor;
    }
    toString() {
        return `${this.authorityId}/${this.typeId}:${this.versionMajor}.${this.versionMinor}`;
    }
    static fromString(r) {
        const [i, o] = r.split(":"), [s, e] = i.split("/"), [n, h] = o.split(".");
        return new t({
            authorityId: s,
            typeId: e,
            versionMajor: Number(n),
            versionMinor: Number(h)
        });
    }
    sameAs(t) {
        return this.authorityId === t.authorityId && this.typeId === t.typeId;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1o3Qd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ContentTypeId", ()=>t);
class t {
    authorityId;
    typeId;
    versionMajor;
    versionMinor;
    constructor(t){
        this.authorityId = t.authorityId, this.typeId = t.typeId, this.versionMajor = t.versionMajor, this.versionMinor = t.versionMinor;
    }
    toString() {
        return `${this.authorityId}/${this.typeId}:${this.versionMajor}.${this.versionMinor}`;
    }
    static fromString(r) {
        const [i, o] = r.split(":"), [s, e] = i.split("/"), [n, h] = o.split(".");
        return new t({
            authorityId: s,
            typeId: e,
            versionMajor: Number(n),
            versionMinor: Number(h)
        });
    }
    sameAs(t) {
        return this.authorityId === t.authorityId && this.typeId === t.typeId;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"VxgNq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "E_ALREADY_LOCKED", ()=>E_ALREADY_LOCKED);
parcelHelpers.export(exports, "E_CANCELED", ()=>E_CANCELED);
parcelHelpers.export(exports, "E_TIMEOUT", ()=>E_TIMEOUT);
parcelHelpers.export(exports, "Mutex", ()=>Mutex);
parcelHelpers.export(exports, "Semaphore", ()=>Semaphore);
parcelHelpers.export(exports, "tryAcquire", ()=>tryAcquire);
parcelHelpers.export(exports, "withTimeout", ()=>withTimeout);
const E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
const E_ALREADY_LOCKED = new Error("mutex already locked");
const E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Semaphore {
    constructor(_value, _cancelError = E_CANCELED){
        this._value = _value;
        this._cancelError = _cancelError;
        this._queue = [];
        this._weightedWaiters = [];
    }
    acquire(weight = 1, priority = 0) {
        if (weight <= 0) throw new Error(`invalid weight ${weight}: must be positive`);
        return new Promise((resolve, reject)=>{
            const task = {
                resolve,
                reject,
                weight,
                priority
            };
            const i = findIndexFromEnd(this._queue, (other)=>priority <= other.priority);
            if (i === -1 && weight <= this._value) // Needs immediate dispatch, skip the queue
            this._dispatchItem(task);
            else this._queue.splice(i + 1, 0, task);
        });
    }
    runExclusive(callback_1) {
        return __awaiter$2(this, arguments, void 0, function*(callback, weight = 1, priority = 0) {
            const [value, release] = yield this.acquire(weight, priority);
            try {
                return yield callback(value);
            } finally{
                release();
            }
        });
    }
    waitForUnlock(weight = 1, priority = 0) {
        if (weight <= 0) throw new Error(`invalid weight ${weight}: must be positive`);
        if (this._couldLockImmediately(weight, priority)) return Promise.resolve();
        else return new Promise((resolve)=>{
            if (!this._weightedWaiters[weight - 1]) this._weightedWaiters[weight - 1] = [];
            insertSorted(this._weightedWaiters[weight - 1], {
                resolve,
                priority
            });
        });
    }
    isLocked() {
        return this._value <= 0;
    }
    getValue() {
        return this._value;
    }
    setValue(value) {
        this._value = value;
        this._dispatchQueue();
    }
    release(weight = 1) {
        if (weight <= 0) throw new Error(`invalid weight ${weight}: must be positive`);
        this._value += weight;
        this._dispatchQueue();
    }
    cancel() {
        this._queue.forEach((entry)=>entry.reject(this._cancelError));
        this._queue = [];
    }
    _dispatchQueue() {
        this._drainUnlockWaiters();
        while(this._queue.length > 0 && this._queue[0].weight <= this._value){
            this._dispatchItem(this._queue.shift());
            this._drainUnlockWaiters();
        }
    }
    _dispatchItem(item) {
        const previousValue = this._value;
        this._value -= item.weight;
        item.resolve([
            previousValue,
            this._newReleaser(item.weight)
        ]);
    }
    _newReleaser(weight) {
        let called = false;
        return ()=>{
            if (called) return;
            called = true;
            this.release(weight);
        };
    }
    _drainUnlockWaiters() {
        if (this._queue.length === 0) for(let weight = this._value; weight > 0; weight--){
            const waiters = this._weightedWaiters[weight - 1];
            if (!waiters) continue;
            waiters.forEach((waiter)=>waiter.resolve());
            this._weightedWaiters[weight - 1] = [];
        }
        else {
            const queuedPriority = this._queue[0].priority;
            for(let weight = this._value; weight > 0; weight--){
                const waiters = this._weightedWaiters[weight - 1];
                if (!waiters) continue;
                const i = waiters.findIndex((waiter)=>waiter.priority <= queuedPriority);
                (i === -1 ? waiters : waiters.splice(0, i)).forEach((waiter)=>waiter.resolve());
            }
        }
    }
    _couldLockImmediately(weight, priority) {
        return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
    }
}
function insertSorted(a, v) {
    const i = findIndexFromEnd(a, (other)=>v.priority <= other.priority);
    a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
    for(let i = a.length - 1; i >= 0; i--){
        if (predicate(a[i])) return i;
    }
    return -1;
}
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Mutex {
    constructor(cancelError){
        this._semaphore = new Semaphore(1, cancelError);
    }
    acquire() {
        return __awaiter$1(this, arguments, void 0, function*(priority = 0) {
            const [, releaser] = yield this._semaphore.acquire(1, priority);
            return releaser;
        });
    }
    runExclusive(callback, priority = 0) {
        return this._semaphore.runExclusive(()=>callback(), 1, priority);
    }
    isLocked() {
        return this._semaphore.isLocked();
    }
    waitForUnlock(priority = 0) {
        return this._semaphore.waitForUnlock(1, priority);
    }
    release() {
        if (this._semaphore.isLocked()) this._semaphore.release();
    }
    cancel() {
        return this._semaphore.cancel();
    }
}
var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {
    return {
        acquire: (weightOrPriority, priority)=>{
            let weight;
            if (isSemaphore(sync)) weight = weightOrPriority;
            else {
                weight = undefined;
                priority = weightOrPriority;
            }
            if (weight !== undefined && weight <= 0) throw new Error(`invalid weight ${weight}: must be positive`);
            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {
                    let isTimeout = false;
                    const handle = setTimeout(()=>{
                        isTimeout = true;
                        reject(timeoutError);
                    }, timeout);
                    try {
                        const ticket = yield isSemaphore(sync) ? sync.acquire(weight, priority) : sync.acquire(priority);
                        if (isTimeout) {
                            const release = Array.isArray(ticket) ? ticket[1] : ticket;
                            release();
                        } else {
                            clearTimeout(handle);
                            resolve(ticket);
                        }
                    } catch (e) {
                        if (!isTimeout) {
                            clearTimeout(handle);
                            reject(e);
                        }
                    }
                }));
        },
        runExclusive (callback, weight, priority) {
            return __awaiter(this, void 0, void 0, function*() {
                let release = ()=>undefined;
                try {
                    const ticket = yield this.acquire(weight, priority);
                    if (Array.isArray(ticket)) {
                        release = ticket[1];
                        return yield callback(ticket[0]);
                    } else {
                        release = ticket;
                        return yield callback();
                    }
                } finally{
                    release();
                }
            });
        },
        release (weight) {
            sync.release(weight);
        },
        cancel () {
            return sync.cancel();
        },
        waitForUnlock: (weightOrPriority, priority)=>{
            let weight;
            if (isSemaphore(sync)) weight = weightOrPriority;
            else {
                weight = undefined;
                priority = weightOrPriority;
            }
            if (weight !== undefined && weight <= 0) throw new Error(`invalid weight ${weight}: must be positive`);
            return new Promise((resolve, reject)=>{
                const handle = setTimeout(()=>reject(timeoutError), timeout);
                (isSemaphore(sync) ? sync.waitForUnlock(weight, priority) : sync.waitForUnlock(priority)).then(()=>{
                    clearTimeout(handle);
                    resolve();
                });
            });
        },
        isLocked: ()=>sync.isLocked(),
        getValue: ()=>sync.getValue(),
        setValue: (value)=>sync.setValue(value)
    };
}
function isSemaphore(sync) {
    return sync.getValue !== undefined;
}
// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types
function tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return withTimeout(sync, 0, alreadyAcquiredError);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1NKsH":[function(require,module,exports) {
"use strict";
var elliptic = exports;
elliptic.version = require("e6672bc3ba1c9961").version;
elliptic.utils = require("5bc72f89931ad0f5");
elliptic.rand = require("7f90d752a36f35cf");
elliptic.curve = require("d11da69c91421223");
elliptic.curves = require("6845bad4ed92c3e4");
// Protocols
elliptic.ec = require("b5f2e1f615acc4b");
elliptic.eddsa = require("79ae761761517980");

},{"e6672bc3ba1c9961":"bvED4","5bc72f89931ad0f5":"8sNT5","7f90d752a36f35cf":"8FGdh","d11da69c91421223":"72OoG","6845bad4ed92c3e4":"6yRo9","b5f2e1f615acc4b":"5gDK1","79ae761761517980":"jPbam"}],"bvED4":[function(require,module,exports) {
module.exports = JSON.parse('{"name":"elliptic","version":"6.6.1","description":"EC cryptography","main":"lib/elliptic.js","files":["lib"],"scripts":{"lint":"eslint lib test","lint:fix":"npm run lint -- --fix","unit":"istanbul test _mocha --reporter=spec test/index.js","test":"npm run lint && npm run unit","version":"grunt dist && git add dist/"},"repository":{"type":"git","url":"git@github.com:indutny/elliptic"},"keywords":["EC","Elliptic","curve","Cryptography"],"author":"Fedor Indutny <fedor@indutny.com>","license":"MIT","bugs":{"url":"https://github.com/indutny/elliptic/issues"},"homepage":"https://github.com/indutny/elliptic","devDependencies":{"brfs":"^2.0.2","coveralls":"^3.1.0","eslint":"^7.6.0","grunt":"^1.2.1","grunt-browserify":"^5.3.0","grunt-cli":"^1.3.2","grunt-contrib-connect":"^3.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^5.0.0","grunt-mocha-istanbul":"^5.0.2","grunt-saucelabs":"^9.0.1","istanbul":"^0.4.5","mocha":"^8.0.1"},"dependencies":{"bn.js":"^4.11.9","brorand":"^1.1.0","hash.js":"^1.0.0","hmac-drbg":"^1.0.1","inherits":"^2.0.4","minimalistic-assert":"^1.0.1","minimalistic-crypto-utils":"^1.0.1"}}');

},{}],"8sNT5":[function(require,module,exports) {
"use strict";
var utils = exports;
var BN = require("f4cbcf6f6eb25ca0");
var minAssert = require("d8ee30463f95a0fd");
var minUtils = require("997429d6bbd82d59");
utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;
// Represent num in a w-NAF form
function getNAF(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    var i;
    for(i = 0; i < naf.length; i += 1)naf[i] = 0;
    var ws = 1 << w + 1;
    var k = num.clone();
    for(i = 0; i < naf.length; i++){
        var z;
        var mod = k.andln(ws - 1);
        if (k.isOdd()) {
            if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;
            else z = mod;
            k.isubn(z);
        } else z = 0;
        naf[i] = z;
        k.iushrn(1);
    }
    return naf;
}
utils.getNAF = getNAF;
// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
    var jsf = [
        [],
        []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while(k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0){
        // First phase
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3) m14 = -1;
        if (m24 === 3) m24 = -1;
        var u1;
        if ((m14 & 1) === 0) u1 = 0;
        else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;
            else u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) u2 = 0;
        else {
            m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;
            else u2 = m24;
        }
        jsf[1].push(u2);
        // Second phase
        if (2 * d1 === u1 + 1) d1 = 1 - d1;
        if (2 * d2 === u2 + 1) d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
    }
    return jsf;
}
utils.getJSF = getJSF;
function cachedProperty(obj, name, computer) {
    var key = "_" + name;
    obj.prototype[name] = function cachedProperty() {
        return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
    };
}
utils.cachedProperty = cachedProperty;
function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
}
utils.parseBytes = parseBytes;
function intFromLE(bytes) {
    return new BN(bytes, "hex", "le");
}
utils.intFromLE = intFromLE;

},{"f4cbcf6f6eb25ca0":"VopIn","d8ee30463f95a0fd":"8OvWh","997429d6bbd82d59":"6f39G"}],"VopIn":[function(require,module,exports) {
(function(module1, exports) {
    "use strict";
    // Utils
    function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
    }
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
    // BN
    function BN(number, base, endian) {
        if (BN.isBN(number)) return number;
        this.negative = 0;
        this.words = null;
        this.length = 0;
        // Reduction context
        this.red = null;
        if (number !== null) {
            if (base === "le" || base === "be") {
                endian = base;
                base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
        }
    }
    if (typeof module1 === "object") module1.exports = BN;
    else exports.BN = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") Buffer = window.Buffer;
        else Buffer = require("bd440367abe2ded7").Buffer;
    } catch (e) {}
    BN.isBN = function isBN(num) {
        if (num instanceof BN) return true;
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
    };
    BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
    };
    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") return this._initNumber(number, base, endian);
        if (typeof number === "object") return this._initArray(number, base, endian);
        if (base === "hex") base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
            start++;
            this.negative = 1;
        }
        if (start < number.length) {
            if (base === 16) this._parseHex(number, start, endian);
            else {
                this._parseBase(number, base, start);
                if (endian === "le") this._initArray(this.toArray(), base, endian);
            }
        }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
            this.negative = 1;
            number = -number;
        }
        if (number < 0x4000000) {
            this.words = [
                number & 0x3ffffff
            ];
            this.length = 1;
        } else if (number < 0x10000000000000) {
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff
            ];
            this.length = 2;
        } else {
            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff,
                1
            ];
            this.length = 3;
        }
        if (endian !== "le") return;
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === "number");
        if (number.length <= 0) {
            this.words = [
                0
            ];
            this.length = 1;
            return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        var off = 0;
        if (endian === "be") for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        else if (endian === "le") for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        return this.strip();
    };
    function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        // 'A' - 'F'
        if (c >= 65 && c <= 70) return c - 55;
        else if (c >= 97 && c <= 102) return c - 87;
        else return c - 48 & 0xf;
    }
    function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) r |= parseHex4Bits(string, index - 1) << 4;
        return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        // 24-bits chunks
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") for(i = number.length - 1; i >= start; i -= 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else off += 8;
        }
        else {
            var parseLength = number.length - start;
            for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
                w = parseHexByte(number, start, i) << off;
                this.words[j] |= w & 0x3ffffff;
                if (off >= 18) {
                    off -= 18;
                    j += 1;
                    this.words[j] |= w >>> 26;
                } else off += 8;
            }
        }
        this.strip();
    };
    function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            // 'a'
            if (c >= 49) r += c - 49 + 0xa;
            else if (c >= 17) r += c - 17 + 0xa;
            else r += c;
        }
        return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [
            0
        ];
        this.length = 1;
        // Find length of limb in base
        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for(var i = start; i < end; i += limbLen){
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for(i = 0; i < mod; i++)pow *= base;
            this.imuln(pow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        this.strip();
    };
    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
    };
    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };
    BN.prototype._expand = function _expand(size) {
        while(this.length < size)this.words[this.length++] = 0;
        return this;
    };
    // Remove leading `0` from `this`
    BN.prototype.strip = function strip() {
        while(this.length > 1 && this.words[this.length - 1] === 0)this.length--;
        return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
    };
    BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */ var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
    ];
    var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ];
    var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for(var i = 0; i < this.length; i++){
                var w = this.words[i];
                var word = ((w << off | carry) & 0xffffff).toString(16);
                carry = w >>> 24 - off & 0xffffff;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
                if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;
                else out = word + out;
            }
            if (carry !== 0) out = carry.toString(16) + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while(!c.isZero()){
                var r = c.modn(groupBase).toString(base);
                c = c.idivn(groupBase);
                if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;
                else out = r + out;
            }
            if (this.isZero()) out = "0" + out;
            while(out.length % padding !== 0)out = "0" + out;
            if (this.negative !== 0) out = "-" + out;
            return out;
        }
        assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) ret += this.words[1] * 0x4000000;
        else if (this.length === 3 && this.words[2] === 0x01) // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
        else if (this.length > 2) assert(false, "Number can only safely store up to 53 bits");
        return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
    };
    BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer !== "undefined");
        return this.toArrayLike(Buffer, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
            // Assume big-endian
            for(i = 0; i < reqLength - byteLength; i++)res[i] = 0;
            for(i = 0; !q.isZero(); i++){
                b = q.andln(0xff);
                q.iushrn(8);
                res[reqLength - i - 1] = b;
            }
        } else {
            for(i = 0; !q.isZero(); i++){
                b = q.andln(0xff);
                q.iushrn(8);
                res[i] = b;
            }
            for(; i < reqLength; i++)res[i] = 0;
        }
        return res;
    };
    if (Math.clz32) BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
    else BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
    BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
            r += 13;
            t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
            r += 7;
            t >>>= 7;
        }
        if ((t & 0xf) === 0) {
            r += 4;
            t >>>= 4;
        }
        if ((t & 0x3) === 0) {
            r += 2;
            t >>>= 2;
        }
        if ((t & 0x1) === 0) r++;
        return r;
    };
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
        var w = new Array(num.bitLength());
        for(var bit = 0; bit < w.length; bit++){
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
    }
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for(var i = 0; i < this.length; i++){
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
        }
        return r;
    };
    BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
        return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
        return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
    };
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
        return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
    };
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
        while(this.length < num.length)this.words[this.length++] = 0;
        for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
        return this.strip();
    };
    BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
    };
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
    };
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) b = num;
        else b = this;
        for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
        this.length = b.length;
        return this.strip();
    };
    BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
    };
    // And `num` with `this`
    BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
    };
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        for(var i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
        if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = a.length;
        return this.strip();
    };
    BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
    };
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
    };
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
        if (bitsLeft > 0) bytesNeeded--;
        // Handle complete words
        for(var i = 0; i < bytesNeeded; i++)this.words[i] = ~this.words[i] & 0x3ffffff;
        // Handle the residue
        if (bitsLeft > 0) this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        // And remove leading zeroes
        return this.strip();
    };
    BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
    };
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) this.words[off] = this.words[off] | 1 << wbit;
        else this.words[off] = this.words[off] & ~(1 << wbit);
        return this.strip();
    };
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        var r;
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
        }
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
        // Copy the rest of the words
        } else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        return this;
    };
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
        } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
    };
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
        }
        // At this point both numbers are positive
        var cmp = this.cmp(num);
        // Optimization - zeroify
        if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }
        // a > b
        var a, b;
        if (cmp > 0) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);
        if (a !== this) this.negative = 1;
        return this.strip();
    };
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for(var k = 1; k < len; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j | 0;
                a = self.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 0x4000000 | 0;
                rword = r & 0x3ffffff;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
        }
        if (carry !== 0) out.words[k] = carry | 0;
        else out.length--;
        return out.strip();
    }
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */ lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */ lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */ lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */ lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */ lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */ lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */ lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */ lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */ lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */ lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */ lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */ lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */ lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */ lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */ lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */ lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */ lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */ lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */ lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
            o[19] = c;
            out.length++;
        }
        return out;
    };
    // Polyfill comb
    if (!Math.imul) comb10MulTo = smallMulTo;
    function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for(var k = 0; k < out.length - 1; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j;
                var a = self.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 0x3ffffff;
                ncarry = ncarry + (r / 0x4000000 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 0x3ffffff;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) out.words[k] = carry;
        else out.length--;
        return out.strip();
    }
    function jumboMulTo(self, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) res = comb10MulTo(this, num, out);
        else if (len < 63) res = smallMulTo(this, num, out);
        else if (len < 1024) res = bigMulTo(this, num, out);
        else res = jumboMulTo(this, num, out);
        return res;
    };
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
    function FFTM(x, y) {
        this.x = x;
        this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for(var i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
        return t;
    };
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for(var i = 0; i < l; i++){
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
        }
        return rb;
    };
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for(var i = 0; i < N; i++){
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
        }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for(var s = 1; s < N; s <<= 1){
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for(var p = 0; p < N; p += l){
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for(var j = 0; j < s; j++){
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    /* jshint maxdepth : false */ if (j !== l) {
                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                        rtwdf_ = rx;
                    }
                }
            }
        }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for(N = N / 2 | 0; N; N = N >>> 1)i++;
        return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for(var i = 0; i < N / 2; i++){
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
        }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for(var i = 0; i < N / 2; i++){
            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 0x3ffffff;
            if (w < 0x4000000) carry = 0;
            else carry = w / 0x4000000 | 0;
        }
        return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for(var i = 0; i < len; i++){
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 0x1fff;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 0x1fff;
            carry = carry >>> 13;
        }
        // Pad with zeroes
        for(i = 2 * len; i < N; ++i)rws[i] = 0;
        assert(carry === 0);
        assert((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for(var i = 0; i < N; i++)ph[i] = 0;
        return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for(var i = 0; i < N; i++){
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
    };
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };
    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
    };
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        // Carry
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = (this.words[i] | 0) * num;
            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
            carry >>= 26;
            carry += w / 0x4000000 | 0;
            // NOTE: lo is 27bit maximum
            carry += lo >>> 26;
            this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
    };
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
    };
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        // Skip leading zeroes
        var res = this;
        for(var i = 0; i < w.length; i++, res = res.sqr()){
            if (w[i] !== 0) break;
        }
        if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
        return res;
    };
    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
            var carry = 0;
            for(i = 0; i < this.length; i++){
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }
        if (s !== 0) {
            for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
            for(i = 0; i < s; i++)this.words[i] = 0;
            this.length += s;
        }
        return this.strip();
    };
    BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
    };
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) h = (hint - hint % 26) / 26;
        else h = 0;
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        // Extended mode, copy masked part
        if (maskedWords) {
            for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
            this.length -= s;
            for(i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }
        var carry = 0;
        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
        }
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }
        return this.strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
    };
    // Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
    };
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
    };
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
        // Check bit and return
        var w = this.words[s];
        return !!(w & q);
    };
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) return this;
        if (r !== 0) s++;
        this.length = Math.min(s, this.length);
        if (r !== 0) {
            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
            this.words[this.length - 1] &= mask;
        }
        return this.strip();
    };
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        // Possible sign change
        if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
        }
        // Add without checks
        return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        // Carry
        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
            this.words[i] -= 0x4000000;
            if (i === this.length - 1) this.words[i + 1] = 1;
            else this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);
        return this;
    };
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
        } else // Carry
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
        return this.strip();
    };
    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
    };
    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for(i = 0; i < num.length; i++){
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 0x3ffffff;
            carry = (w >> 26) - (right / 0x4000000 | 0);
            this.words[i + shift] = w & 0x3ffffff;
        }
        for(; i < this.length - shift; i++){
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this.strip();
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for(i = 0; i < this.length; i++){
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this.strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
        }
        // Initialize quotient
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for(var i = 0; i < q.length; i++)q.words[i] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
            a = diff;
            if (q) q.words[m] = 1;
        }
        for(var j = m - 1; j >= 0; j--){
            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
            // (0x7ffffff)
            qj = Math.min(qj / bhi | 0, 0x3ffffff);
            a._ishlnsubmul(b, qj, j);
            while(a.negative !== 0){
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) a.negative ^= 1;
            }
            if (q) q.words[j] = qj;
        }
        if (q) q.strip();
        a.strip();
        // Denormalize
        if (mode !== "div" && shift !== 0) a.iushrn(shift);
        return {
            div: q || null,
            mod: a
        };
    };
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) return {
            div: new BN(0),
            mod: new BN(0)
        };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") div = res.div.neg();
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.iadd(num);
            }
            return {
                div: div,
                mod: mod
            };
        }
        if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") div = res.div.neg();
            return {
                div: div,
                mod: res.mod
            };
        }
        if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.isub(num);
            }
            return {
                div: res.div,
                mod: mod
            };
        }
        // Both numbers are positive at this point
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) return {
            div: new BN(0),
            mod: this
        };
        // Very short reduction
        if (num.length === 1) {
            if (mode === "div") return {
                div: this.divn(num.words[0]),
                mod: null
            };
            if (mode === "mod") return {
                div: null,
                mod: new BN(this.modn(num.words[0]))
            };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modn(num.words[0]))
            };
        }
        return this._wordDiv(num, mode);
    };
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
    };
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
    };
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modn = function modn(num) {
        assert(num <= 0x3ffffff);
        var p = 67108864 % num;
        var acc = 0;
        for(var i = this.length - 1; i >= 0; i--)acc = (p * acc + (this.words[i] | 0)) % num;
        return acc;
    };
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
        assert(num <= 0x3ffffff);
        var carry = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var w = (this.words[i] | 0) + carry * 0x4000000;
            this.words[i] = w / num | 0;
            carry = w % num;
        }
        return this.strip();
    };
    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) x = x.umod(p);
        else x = x.clone();
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while(x.isEven() && y.isEven()){
            x.iushrn(1);
            y.iushrn(1);
            ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while(!x.isZero()){
            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                x.iushrn(i);
                while(i-- > 0){
                    if (A.isOdd() || B.isOdd()) {
                        A.iadd(yp);
                        B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                y.iushrn(j);
                while(j-- > 0){
                    if (C.isOdd() || D.isOdd()) {
                        C.iadd(yp);
                        D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                }
            }
            if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
            } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
            }
        }
        return {
            a: C,
            b: D,
            gcd: y.iushln(g)
        };
    };
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) a = a.umod(p);
        else a = a.clone();
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                a.iushrn(i);
                while(i-- > 0){
                    if (x1.isOdd()) x1.iadd(delta);
                    x1.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                b.iushrn(j);
                while(j-- > 0){
                    if (x2.isOdd()) x2.iadd(delta);
                    x2.iushrn(1);
                }
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        var res;
        if (a.cmpn(1) === 0) res = x1;
        else res = x2;
        if (res.cmpn(0) < 0) res.iadd(p);
        return res;
    };
    BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        // Remove common factor of two
        for(var shift = 0; a.isEven() && b.isEven(); shift++){
            a.iushrn(1);
            b.iushrn(1);
        }
        do {
            while(a.isEven())a.iushrn(1);
            while(b.isEven())b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
                // Swap `a` and `b` to make `a` always bigger than `b`
                var t = a;
                a = b;
                b = t;
            } else if (r === 0 || b.cmpn(1) === 0) break;
            a.isub(b);
        }while (true);
        return b.iushln(shift);
    };
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
    };
    // And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
        }
        // Add bit and propagate, if needed
        var carry = q;
        for(var i = s; carry !== 0 && i < this.length; i++){
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) res = 1;
        else {
            if (negative) num = -num;
            assert(num <= 0x3ffffff, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) res = -1;
            else if (a > b) res = 1;
            break;
        }
        return res;
    };
    BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
    };
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
        return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
    };
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
    };
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
    };
    // Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
        do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
        }while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) r.isub(this.p);
        else if (r.strip !== undefined) // r is BN v4 instance
        r.strip();
        else // r is BN v5 instance
        r._strip();
        return r;
    };
    MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };
    function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for(var i = 0; i < outLen; i++)output.words[i] = input.words[i];
        output.length = outLen;
        if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
        }
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for(i = 10; i < input.length; i++){
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) input.length -= 10;
        else input.length -= 9;
    };
    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for(var i = 0; i < num.length; i++){
            var w = num.words[i] | 0;
            lo += w * 0x3d1;
            num.words[i] = lo & 0x3ffffff;
            lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) num.length--;
        }
        return num;
    };
    function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for(var i = 0; i < num.length; i++){
            var hi = (num.words[i] | 0) * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0) num.words[num.length++] = carry;
        return num;
    };
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;
        if (name === "k256") prime = new K256();
        else if (name === "p224") prime = new P224();
        else if (name === "p192") prime = new P192();
        else if (name === "p25519") prime = new P25519();
        else throw new Error("Unknown prime " + name);
        primes[name] = prime;
        return prime;
    };
    //
    // Base reduction engine
    //
    function Red(m) {
        if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
        }
    }
    Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg(a) {
        if (a.isZero()) return a.clone();
        return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res;
    };
    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res;
    };
    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while(!q.isZero() && q.andln(1) === 0){
            s++;
            q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while(this.pow(z, lpow).cmp(nOne) !== 0)z.redIAdd(nOne);
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while(t.cmp(one) !== 0){
            var tmp = t;
            for(var i = 0; tmp.cmp(one) !== 0; i++)tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    };
    Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        } else return this.imod(inv);
    };
    Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) start = 26;
        for(i = num.length - 1; i >= 0; i--){
            var word = num.words[i];
            for(var j = start - 1; j >= 0; j--){
                var bit = word >> j & 1;
                if (res !== wnd[0]) res = this.sqr(res);
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };
    //
    // Montgomery method engine
    //
    BN.mont = function mont(num) {
        return new Mont(num);
    };
    function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };
    Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
    };
})(module, this);

},{"bd440367abe2ded7":"jhUEF"}],"8OvWh":[function(require,module,exports) {
module.exports = assert;
function assert(val, msg) {
    if (!val) throw new Error(msg || "Assertion failed");
}
assert.equal = function assertEqual(l, r, msg) {
    if (l != r) throw new Error(msg || "Assertion failed: " + l + " != " + r);
};

},{}],"6f39G":[function(require,module,exports) {
"use strict";
var utils = exports;
function toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];
    if (typeof msg !== "string") {
        for(var i = 0; i < msg.length; i++)res[i] = msg[i] | 0;
        return res;
    }
    if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0) msg = "0" + msg;
        for(var i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else for(var i = 0; i < msg.length; i++){
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi) res.push(hi, lo);
        else res.push(lo);
    }
    return res;
}
utils.toArray = toArray;
function zero2(word) {
    if (word.length === 1) return "0" + word;
    else return word;
}
utils.zero2 = zero2;
function toHex(msg) {
    var res = "";
    for(var i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));
    return res;
}
utils.toHex = toHex;
utils.encode = function encode(arr, enc) {
    if (enc === "hex") return toHex(arr);
    else return arr;
};

},{}],"8FGdh":[function(require,module,exports) {
var r;
module.exports = function rand(len) {
    if (!r) r = new Rand(null);
    return r.generate(len);
};
function Rand(rand) {
    this.rand = rand;
}
module.exports.Rand = Rand;
Rand.prototype.generate = function generate(len) {
    return this._rand(len);
};
// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
    if (this.rand.getBytes) return this.rand.getBytes(n);
    var res = new Uint8Array(n);
    for(var i = 0; i < res.length; i++)res[i] = this.rand.getByte();
    return res;
};
if (typeof self === "object") {
    if (self.crypto && self.crypto.getRandomValues) // Modern browsers
    Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.crypto.getRandomValues(arr);
        return arr;
    };
    else if (self.msCrypto && self.msCrypto.getRandomValues) // IE
    Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.msCrypto.getRandomValues(arr);
        return arr;
    };
    else if (typeof window === "object") // Old junk
    Rand.prototype._rand = function() {
        throw new Error("Not implemented yet");
    };
} else // Node.js or Web worker with no crypto support
try {
    var crypto = require("e8ad0674730919a8");
    if (typeof crypto.randomBytes !== "function") throw new Error("Not supported");
    Rand.prototype._rand = function _rand(n) {
        return crypto.randomBytes(n);
    };
} catch (e) {}

},{"e8ad0674730919a8":"jhUEF"}],"72OoG":[function(require,module,exports) {
"use strict";
var curve = exports;
curve.base = require("59d486bd2037506a");
curve.short = require("eb37617ef6927580");
curve.mont = require("be9c662572da2183");
curve.edwards = require("60763dd06fe64e8d");

},{"59d486bd2037506a":"kvY1a","eb37617ef6927580":"e7TRt","be9c662572da2183":"2JhQH","60763dd06fe64e8d":"3idNZ"}],"kvY1a":[function(require,module,exports) {
"use strict";
var BN = require("70865a568c61cc60");
var utils = require("fb5111a3810a8235");
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;
function BaseCurve(type, conf) {
    this.type = type;
    this.p = new BN(conf.p, 16);
    // Use Montgomery, when there is no fast reduction for the prime
    this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
    // Useful for many curves
    this.zero = new BN(0).toRed(this.red);
    this.one = new BN(1).toRed(this.red);
    this.two = new BN(2).toRed(this.red);
    // Curve configuration, optional
    this.n = conf.n && new BN(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    // Temporary arrays
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    // Generalized Greg Maxwell's trick
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) this.redN = null;
    else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
    }
}
module.exports = BaseCurve;
BaseCurve.prototype.point = function point() {
    throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
    throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert(p.precomputed);
    var doubles = p._getDoubles();
    var naf = getNAF(k, 1, this._bitLength);
    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    // Translate into more windowed form
    var repr = [];
    var j;
    var nafW;
    for(j = 0; j < naf.length; j += doubles.step){
        nafW = 0;
        for(var l = j + doubles.step - 1; l >= j; l--)nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for(var i = I; i > 0; i--){
        for(j = 0; j < repr.length; j++){
            nafW = repr[j];
            if (nafW === i) b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
    }
    return a.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;
    // Precompute window
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    // Get NAF form
    var naf = getNAF(k, w, this._bitLength);
    // Add `this`*(N+1) for every w-NAF index
    var acc = this.jpoint(null, null, null);
    for(var i = naf.length - 1; i >= 0; i--){
        // Count zeroes
        for(var l = 0; i >= 0 && naf[i] === 0; i--)l++;
        if (i >= 0) l++;
        acc = acc.dblp(l);
        if (i < 0) break;
        var z = naf[i];
        assert(z !== 0);
        if (p.type === "affine") {
            // J +- P
            if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else // J +- J
        if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);
        else acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
    return p.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    // Fill all arrays
    var max = 0;
    var i;
    var j;
    var p;
    for(i = 0; i < len; i++){
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
    }
    // Comb small window NAFs
    for(i = len - 1; i >= 1; i -= 2){
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max = Math.max(naf[a].length, max);
            max = Math.max(naf[b].length, max);
            continue;
        }
        var comb = [
            points[a],
            /* 1 */ null,
            /* 3 */ null,
            /* 5 */ points[b]
        ];
        // Try to avoid Projective points, if possible
        if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
        } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
            -3,
            /* -1 -1 */ -1,
            /* -1 0 */ -5,
            /* -1 1 */ -7,
            /* 0 -1 */ 0,
            /* 0 0 */ 7,
            /* 0 1 */ 5,
            /* 1 -1 */ 1,
            /* 1 0 */ 3
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for(j = 0; j < max; j++){
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
        }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for(i = max; i >= 0; i--){
        var k = 0;
        while(i >= 0){
            var zero = true;
            for(j = 0; j < len; j++){
                tmp[j] = naf[j][i] | 0;
                if (tmp[j] !== 0) zero = false;
            }
            if (!zero) break;
            k++;
            i--;
        }
        if (i >= 0) k++;
        acc = acc.dblp(k);
        if (i < 0) break;
        for(j = 0; j < len; j++){
            var z = tmp[j];
            p;
            if (z === 0) continue;
            else if (z > 0) p = wnd[j][z - 1 >> 1];
            else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine") acc = acc.mixedAdd(p);
            else acc = acc.add(p);
        }
    }
    // Zeroify references
    for(i = 0; i < len; i++)wnd[i] = null;
    if (jacobianResult) return acc;
    else return acc.toP();
};
function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
    throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils.toArray(bytes, enc);
    var len = this.p.byteLength();
    // uncompressed, hybrid-odd, hybrid-even
    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 0x06) assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 0x07) assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
        return res;
    } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
    throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray("be", len);
    if (compact) return [
        this.getY().isEven() ? 0x02 : 0x03
    ].concat(x);
    return [
        0x04
    ].concat(x, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode(enc, compact) {
    return utils.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed) return this;
    var precomputed = {
        doubles: null,
        naf: null,
        beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed) return false;
    var doubles = this.precomputed.doubles;
    if (!doubles) return false;
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    var doubles = [
        this
    ];
    var acc = this;
    for(var i = 0; i < power; i += step){
        for(var j = 0; j < step; j++)acc = acc.dbl();
        doubles.push(acc);
    }
    return {
        step: step,
        points: doubles
    };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    var res = [
        this
    ];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for(var i = 1; i < max; i++)res[i] = res[i - 1].add(dbl);
    return {
        wnd: wnd,
        points: res
    };
};
BasePoint.prototype._getBeta = function _getBeta() {
    return null;
};
BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for(var i = 0; i < k; i++)r = r.dbl();
    return r;
};

},{"70865a568c61cc60":"VopIn","fb5111a3810a8235":"8sNT5"}],"e7TRt":[function(require,module,exports) {
"use strict";
var utils = require("89f794ef417dc31c");
var BN = require("c314b0ac30b69c4a");
var inherits = require("6ac4d7c73f24ab9c");
var Base = require("6e622edb7498c94");
var assert = utils.assert;
function ShortCurve(conf) {
    Base.call(this, "short", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    // If the curve is endomorphic, precalculate beta and lambda
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    // No efficient endomorphism
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;
    // Compute beta and lambda, that lambda * P = (beta * Px; Py)
    var beta;
    var lambda;
    if (conf.beta) beta = new BN(conf.beta, 16).toRed(this.red);
    else {
        var betas = this._getEndoRoots(this.p);
        // Choose the smallest beta
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
    }
    if (conf.lambda) lambda = new BN(conf.lambda, 16);
    else {
        // Choose the lambda that is matching selected beta
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) lambda = lambdas[0];
        else {
            lambda = lambdas[1];
            assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
    }
    // Get basis vectors, used for balanced length-two representation
    var basis;
    if (conf.basis) basis = conf.basis.map(function(vec) {
        return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
        };
    });
    else basis = this._getEndoBasis(lambda);
    return {
        beta: beta,
        lambda: lambda,
        basis: basis
    };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    // Find roots of for x^2 + x + 1 in F
    // Root = (-1 +- Sqrt(-3)) / 2
    //
    var red = num === this.p ? this.red : BN.mont(num);
    var tinv = new BN(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [
        l1,
        l2
    ];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    // aprxSqrt >= sqrt(this.n)
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    // 3.74
    // Run EGCD, until r(L + 1) < aprxSqrt
    var u = lambda;
    var v = this.n.clone();
    var x1 = new BN(1);
    var y1 = new BN(0);
    var x2 = new BN(0);
    var y2 = new BN(1);
    // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
    var a0;
    var b0;
    // First vector
    var a1;
    var b1;
    // Second vector
    var a2;
    var b2;
    var prevR;
    var i = 0;
    var r;
    var x;
    while(u.cmpn(0) !== 0){
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
        } else if (a1 && ++i === 2) break;
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
    }
    a2 = r.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
    }
    // Normalize signs
    if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
    }
    if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
    }
    return [
        {
            a: a1,
            b: b1
        },
        {
            a: a2,
            b: b2
        }
    ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    // Calculate answer
    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return {
        k1: k1,
        k2: k2
    };
};
ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red) x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error("invalid point");
    // XXX Is there any way to tell if the number is odd without converting it
    // to non-red form?
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
    return this.point(x, y);
};
ShortCurve.prototype.validate = function validate(point) {
    if (point.inf) return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for(var i = 0; i < points.length; i++){
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
            split.k1.ineg();
            p = p.neg(true);
        }
        if (split.k2.negative) {
            split.k2.ineg();
            beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
    // Clean-up references to points and coefficients
    for(var j = 0; j < i * 2; j++){
        npoints[j] = null;
        ncoeffs[j] = null;
    }
    return res;
};
function Point(curve, x, y, isRed) {
    Base.BasePoint.call(this, curve, "affine");
    if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
    } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        // Force redgomery representation when loading from JSON
        if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
        }
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        this.inf = false;
    }
}
inherits(Point, Base.BasePoint);
ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point(this, x, y, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo) return;
    var pre = this.precomputed;
    if (pre && pre.beta) return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
            beta: null,
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: pre.naf.points.map(endoMul)
            },
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: pre.doubles.points.map(endoMul)
            }
        };
    }
    return beta;
};
Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed) return [
        this.x,
        this.y
    ];
    return [
        this.x,
        this.y,
        this.precomputed && {
            doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
            },
            naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
            }
        }
    ];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === "string") obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2]) return res;
    function obj2point(obj) {
        return curve.point(obj[0], obj[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
            step: pre.doubles.step,
            points: [
                res
            ].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: [
                res
            ].concat(pre.naf.points.map(obj2point))
        }
    };
    return res;
};
Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
};
Point.prototype.add = function add(p) {
    // O + P = P
    if (this.inf) return p;
    // P + O = P
    if (p.inf) return this;
    // P + P = 2P
    if (this.eq(p)) return this.dbl();
    // P + (-P) = O
    if (this.neg().eq(p)) return this.curve.point(null, null);
    // P + Q = O
    if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
    if (this.inf) return this;
    // 2P = O
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
    return this.x.fromRed();
};
Point.prototype.getY = function getY() {
    return this.y.fromRed();
};
Point.prototype.mul = function mul(k) {
    k = new BN(k, 16);
    if (this.isInfinity()) return this;
    else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
    else if (this.curve.endo) return this.curve._endoWnafMulAdd([
        this
    ], [
        k
    ]);
    else return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [
        this,
        p2
    ];
    var coeffs = [
        k1,
        k2
    ];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);
    else return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [
        this,
        p2
    ];
    var coeffs = [
        k1,
        k2
    ];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);
    else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
    if (this.inf) return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
            return p.neg();
        };
        res.precomputed = {
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: pre.naf.points.map(negate)
            },
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: pre.doubles.points.map(negate)
            }
        };
    }
    return res;
};
Point.prototype.toJ = function toJ() {
    if (this.inf) return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
};
function JPoint(curve, x, y, z) {
    Base.BasePoint.call(this, curve, "jacobian");
    if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
    } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = new BN(z, 16);
    }
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
};
JPoint.prototype.toP = function toP() {
    if (this.isInfinity()) return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add(p) {
    // O + P = P
    if (this.isInfinity()) return p;
    // P + O = P
    if (p.isInfinity()) return this;
    // 12M + 4S + 7A
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
        else return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p) {
    // O + P = P
    if (this.isInfinity()) return p.toJ();
    // P + O = P
    if (p.isInfinity()) return this;
    // 8M + 3S + 7A
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
        else return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0) return this;
    if (this.isInfinity()) return this;
    if (!pow) return this.dbl();
    var i;
    if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for(i = 0; i < pow; i++)r = r.dbl();
        return r;
    }
    // 1M + 2S + 1A + N * (4S + 5M + 8A)
    // N = 1 => 6M + 6S + 9A
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    // Reuse results
    var jyd = jy.redAdd(jy);
    for(i = 0; i < pow; i++){
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity()) return this;
    if (this.curve.zeroA) return this._zeroDbl();
    else if (this.curve.threeA) return this._threeDbl();
    else return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
        //     #doubling-mdbl-2007-bl
        // 1M + 5S + 14A
        // XX = X1^2
        var xx = this.x.redSqr();
        // YY = Y1^2
        var yy = this.y.redSqr();
        // YYYY = YY^2
        var yyyy = yy.redSqr();
        // S = 2 * ((X1 + YY)^2 - XX - YYYY)
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        // M = 3 * XX + a; a = 0
        var m = xx.redAdd(xx).redIAdd(xx);
        // T = M ^ 2 - 2*S
        var t = m.redSqr().redISub(s).redISub(s);
        // 8 * YYYY
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        // X3 = T
        nx = t;
        // Y3 = M * (S - T) - 8 * YYYY
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        // Z3 = 2*Y1
        nz = this.y.redAdd(this.y);
    } else {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
        //     #doubling-dbl-2009-l
        // 2M + 5S + 13A
        // A = X1^2
        var a = this.x.redSqr();
        // B = Y1^2
        var b = this.y.redSqr();
        // C = B^2
        var c = b.redSqr();
        // D = 2 * ((X1 + B)^2 - A - C)
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        // E = 3 * A
        var e = a.redAdd(a).redIAdd(a);
        // F = E^2
        var f = e.redSqr();
        // 8 * C
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        // X3 = F - 2 * D
        nx = f.redISub(d).redISub(d);
        // Y3 = E * (D - X3) - 8 * C
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        // Z3 = 2 * Y1 * Z1
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
        //     #doubling-mdbl-2007-bl
        // 1M + 5S + 15A
        // XX = X1^2
        var xx = this.x.redSqr();
        // YY = Y1^2
        var yy = this.y.redSqr();
        // YYYY = YY^2
        var yyyy = yy.redSqr();
        // S = 2 * ((X1 + YY)^2 - XX - YYYY)
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        // M = 3 * XX + a
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        // T = M^2 - 2 * S
        var t = m.redSqr().redISub(s).redISub(s);
        // X3 = T
        nx = t;
        // Y3 = M * (S - T) - 8 * YYYY
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        // Z3 = 2 * Y1
        nz = this.y.redAdd(this.y);
    } else {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
        // 3M + 5S
        // delta = Z1^2
        var delta = this.z.redSqr();
        // gamma = Y1^2
        var gamma = this.y.redSqr();
        // beta = X1 * gamma
        var beta = this.x.redMul(gamma);
        // alpha = 3 * (X1 - delta) * (X1 + delta)
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        // X3 = alpha^2 - 8 * beta
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        // Z3 = (Y1 + Z1)^2 - gamma - delta
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    // 4M + 6S + 10A
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA) return this.dbl().add(this);
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
    // 5M + 10S + ...
    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // ZZ = Z1^2
    var zz = this.z.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // M = 3 * XX + a * ZZ2; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // MM = M^2
    var mm = m.redSqr();
    // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    // EE = E^2
    var ee = e.redSqr();
    // T = 16*YYYY
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    // U = (M + E)^2 - MM - EE - T
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    // X3 = 4 * (X1 * EE - 4 * YY * U)
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    // Z3 = (Z1 + E)^2 - ZZ - EE
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul(k, kbase) {
    k = new BN(k, kbase);
    return this.curve._wnafMul(this, k);
};
JPoint.prototype.eq = function eq(p) {
    if (p.type === "affine") return this.eq(p.toJ());
    if (this === p) return true;
    // x1 * z2^2 == x2 * z1^2
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false;
    // y1 * z2^3 == y2 * z1^3
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0) return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for(;;){
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0) return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0) return true;
    }
};
JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
};

},{"89f794ef417dc31c":"8sNT5","c314b0ac30b69c4a":"VopIn","6ac4d7c73f24ab9c":"bRL3M","6e622edb7498c94":"kvY1a"}],"bRL3M":[function(require,module,exports) {
if (typeof Object.create === "function") // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

},{}],"2JhQH":[function(require,module,exports) {
"use strict";
var BN = require("ebdf19f04f3ed250");
var inherits = require("cb5bb4841a749f68");
var Base = require("51280941230b3f98");
var utils = require("ea7949a80be00261");
function MontCurve(conf) {
    Base.call(this, "mont", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.i4 = new BN(4).toRed(this.red).redInvm();
    this.two = new BN(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;
MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
    return y.redSqr().cmp(rhs) === 0;
};
function Point(curve, x, z) {
    Base.BasePoint.call(this, curve, "projective");
    if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
    } else {
        this.x = new BN(x, 16);
        this.z = new BN(z, 16);
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    }
}
inherits(Point, Base.BasePoint);
MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point(utils.toArray(bytes, enc), 1);
};
MontCurve.prototype.point = function point(x, z) {
    return new Point(this, x, z);
};
MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
};
Point.prototype.precompute = function precompute() {
// No-op
};
Point.prototype._encode = function _encode() {
    return this.getX().toArray("be", this.curve.p.byteLength());
};
Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1] || curve.one);
};
Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
};
Point.prototype.dbl = function dbl() {
    // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
    // 2M + 2S + 4A
    // A = X1 + Z1
    var a = this.x.redAdd(this.z);
    // AA = A^2
    var aa = a.redSqr();
    // B = X1 - Z1
    var b = this.x.redSub(this.z);
    // BB = B^2
    var bb = b.redSqr();
    // C = AA - BB
    var c = aa.redSub(bb);
    // X3 = AA * BB
    var nx = aa.redMul(bb);
    // Z3 = C * (BB + A24 * C)
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
};
Point.prototype.add = function add() {
    throw new Error("Not supported on Montgomery curve");
};
Point.prototype.diffAdd = function diffAdd(p, diff) {
    // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
    // 4M + 2S + 6A
    // A = X2 + Z2
    var a = this.x.redAdd(this.z);
    // B = X2 - Z2
    var b = this.x.redSub(this.z);
    // C = X3 + Z3
    var c = p.x.redAdd(p.z);
    // D = X3 - Z3
    var d = p.x.redSub(p.z);
    // DA = D * A
    var da = d.redMul(a);
    // CB = C * B
    var cb = c.redMul(b);
    // X5 = Z1 * (DA + CB)^2
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    // Z5 = X1 * (DA - CB)^2
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
};
Point.prototype.mul = function mul(k) {
    var t = k.clone();
    var a = this; // (N / 2) * Q + Q
    var b = this.curve.point(null, null); // (N / 2) * Q
    var c = this; // Q
    for(var bits = []; t.cmpn(0) !== 0; t.iushrn(1))bits.push(t.andln(1));
    for(var i = bits.length - 1; i >= 0; i--)if (bits[i] === 0) {
        // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
        a = a.diffAdd(b, c);
        // N * Q = 2 * ((N / 2) * Q + Q))
        b = b.dbl();
    } else {
        // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
        b = a.diffAdd(b, c);
        // N * Q + Q = 2 * ((N / 2) * Q + Q)
        a = a.dbl();
    }
    return b;
};
Point.prototype.mulAdd = function mulAdd() {
    throw new Error("Not supported on Montgomery curve");
};
Point.prototype.jumlAdd = function jumlAdd() {
    throw new Error("Not supported on Montgomery curve");
};
Point.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
};
Point.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
};
Point.prototype.getX = function getX() {
    // Normalize coordinates
    this.normalize();
    return this.x.fromRed();
};

},{"ebdf19f04f3ed250":"VopIn","cb5bb4841a749f68":"bRL3M","51280941230b3f98":"kvY1a","ea7949a80be00261":"8sNT5"}],"3idNZ":[function(require,module,exports) {
"use strict";
var utils = require("7bd66a4710450b08");
var BN = require("ccef46dcf03d45c6");
var inherits = require("19937272cbe23c92");
var Base = require("108c8ead5f54502b");
var assert = utils.assert;
function EdwardsCurve(conf) {
    // NOTE: Important as we are creating point in Base.call()
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base.call(this, "edwards", conf);
    this.a = new BN(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;
EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA) return num.redNeg();
    else return this.a.redMul(num);
};
EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC) return num;
    else return this.c.redMul(num);
};
// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
    return this.point(x, y, z, t);
};
EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red) x = x.toRed(this.red);
    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    var y2 = rhs.redMul(lhs.redInvm());
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error("invalid point");
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
    return this.point(x, y);
};
EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new BN(y, 16);
    if (!y.red) y = y.toRed(this.red);
    // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
    var y2 = y.redSqr();
    var lhs = y2.redSub(this.c2);
    var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());
    if (x2.cmp(this.zero) === 0) {
        if (odd) throw new Error("invalid point");
        else return this.point(this.zero, y);
    }
    var x = x2.redSqrt();
    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0) throw new Error("invalid point");
    if (x.fromRed().isOdd() !== odd) x = x.redNeg();
    return this.point(x, y);
};
EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity()) return true;
    // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
    point.normalize();
    var x2 = point.x.redSqr();
    var y2 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
    return lhs.cmp(rhs) === 0;
};
function Point(curve, x, y, z, t) {
    Base.BasePoint.call(this, curve, "projective");
    if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
    } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        if (!this.z.red) this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        // Use extended coordinates
        if (this.curve.extended && !this.t) {
            this.t = this.x.redMul(this.y);
            if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
        }
    }
}
inherits(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
};
EdwardsCurve.prototype.point = function point(x, y, z, t) {
    return new Point(this, x, y, z, t);
};
Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1], obj[2]);
};
Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function _extDbl() {
    // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #doubling-dbl-2008-hwcd
    // 4M + 4S
    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = 2 * Z1^2
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    // D = a * A
    var d = this.curve._mulA(a);
    // E = (X1 + Y1)^2 - A - B
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
    // G = D + B
    var g = d.redAdd(b);
    // F = G - C
    var f = g.redSub(c);
    // H = D - B
    var h = d.redSub(b);
    // X3 = E * F
    var nx = e.redMul(f);
    // Y3 = G * H
    var ny = g.redMul(h);
    // T3 = E * H
    var nt = e.redMul(h);
    // Z3 = F * G
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projDbl = function _projDbl() {
    // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #doubling-dbl-2008-bbjlp
    //     #doubling-dbl-2007-bl
    // and others
    // Generally 3M + 4S or 2M + 4S
    // B = (X1 + Y1)^2
    var b = this.x.redAdd(this.y).redSqr();
    // C = X1^2
    var c = this.x.redSqr();
    // D = Y1^2
    var d = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    var e;
    var h;
    var j;
    if (this.curve.twisted) {
        // E = a * C
        e = this.curve._mulA(c);
        // F = E + D
        var f = e.redAdd(d);
        if (this.zOne) {
            // X3 = (B - C - D) * (F - 2)
            nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
            // Y3 = F * (E - D)
            ny = f.redMul(e.redSub(d));
            // Z3 = F^2 - 2 * F
            nz = f.redSqr().redSub(f).redSub(f);
        } else {
            // H = Z1^2
            h = this.z.redSqr();
            // J = F - 2 * H
            j = f.redSub(h).redISub(h);
            // X3 = (B-C-D)*J
            nx = b.redSub(c).redISub(d).redMul(j);
            // Y3 = F * (E - D)
            ny = f.redMul(e.redSub(d));
            // Z3 = F * J
            nz = f.redMul(j);
        }
    } else {
        // E = C + D
        e = c.redAdd(d);
        // H = (c * Z1)^2
        h = this.curve._mulC(this.z).redSqr();
        // J = E - 2 * H
        j = e.redSub(h).redSub(h);
        // X3 = c * (B - E) * J
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        // Y3 = c * E * (C - D)
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        // Z3 = E * J
        nz = e.redMul(j);
    }
    return this.curve.point(nx, ny, nz);
};
Point.prototype.dbl = function dbl() {
    if (this.isInfinity()) return this;
    // Double in extended coordinates
    if (this.curve.extended) return this._extDbl();
    else return this._projDbl();
};
Point.prototype._extAdd = function _extAdd(p) {
    // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
    //     #addition-add-2008-hwcd-3
    // 8M
    // A = (Y1 - X1) * (Y2 - X2)
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    // B = (Y1 + X1) * (Y2 + X2)
    var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    // C = T1 * k * T2
    var c = this.t.redMul(this.curve.dd).redMul(p.t);
    // D = Z1 * 2 * Z2
    var d = this.z.redMul(p.z.redAdd(p.z));
    // E = B - A
    var e = b.redSub(a);
    // F = D - C
    var f = d.redSub(c);
    // G = D + C
    var g = d.redAdd(c);
    // H = B + A
    var h = b.redAdd(a);
    // X3 = E * F
    var nx = e.redMul(f);
    // Y3 = G * H
    var ny = g.redMul(h);
    // T3 = E * H
    var nt = e.redMul(h);
    // Z3 = F * G
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projAdd = function _projAdd(p) {
    // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
    //     #addition-add-2008-bbjlp
    //     #addition-add-2007-bl
    // 10M + 1S
    // A = Z1 * Z2
    var a = this.z.redMul(p.z);
    // B = A^2
    var b = a.redSqr();
    // C = X1 * X2
    var c = this.x.redMul(p.x);
    // D = Y1 * Y2
    var d = this.y.redMul(p.y);
    // E = d * C * D
    var e = this.curve.d.redMul(c).redMul(d);
    // F = B - E
    var f = b.redSub(e);
    // G = B + E
    var g = b.redAdd(e);
    // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
        // Y3 = A * G * (D - a * C)
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        // Z3 = F * G
        nz = f.redMul(g);
    } else {
        // Y3 = A * G * (D - C)
        ny = a.redMul(g).redMul(d.redSub(c));
        // Z3 = c * F * G
        nz = this.curve._mulC(f).redMul(g);
    }
    return this.curve.point(nx, ny, nz);
};
Point.prototype.add = function add(p) {
    if (this.isInfinity()) return p;
    if (p.isInfinity()) return this;
    if (this.curve.extended) return this._extAdd(p);
    else return this._projAdd(p);
};
Point.prototype.mul = function mul(k) {
    if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
    else return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [
        this,
        p
    ], [
        k1,
        k2
    ], 2, false);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [
        this,
        p
    ], [
        k1,
        k2
    ], 2, true);
};
Point.prototype.normalize = function normalize() {
    if (this.zOne) return this;
    // Normalize coordinates
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t) this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
};
Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
};
Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
};
Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
};
Point.prototype.eq = function eq(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
};
Point.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0) return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(this.z);
    for(;;){
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0) return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0) return true;
    }
};
// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"7bd66a4710450b08":"8sNT5","ccef46dcf03d45c6":"VopIn","19937272cbe23c92":"bRL3M","108c8ead5f54502b":"kvY1a"}],"6yRo9":[function(require,module,exports) {
"use strict";
var curves = exports;
var hash = require("1c9db357c0845afa");
var curve = require("47ec78745540f875");
var utils = require("e30b16e4a47a5405");
var assert = utils.assert;
function PresetCurve(options) {
    if (options.type === "short") this.curve = new curve.short(options);
    else if (options.type === "edwards") this.curve = new curve.edwards(options);
    else this.curve = new curve.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert(this.g.validate(), "Invalid curve");
    assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
}
curves.PresetCurve = PresetCurve;
function defineCurve(name, options) {
    Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
            var curve = new PresetCurve(options);
            Object.defineProperty(curves, name, {
                configurable: true,
                enumerable: true,
                value: curve
            });
            return curve;
        }
    });
}
defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash.sha256,
    gRed: false,
    g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
});
defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash.sha256,
    gRed: false,
    g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
});
defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash.sha256,
    gRed: false,
    g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
});
defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash.sha384,
    gRed: false,
    g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
});
defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash.sha512,
    gRed: false,
    g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
});
defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash.sha256,
    gRed: false,
    g: [
        "9"
    ]
});
defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash.sha256,
    gRed: false,
    g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
    ]
});
var pre;
try {
    pre = require("9eada5f7049e7dfd");
} catch (e) {
    pre = undefined;
}
defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
        {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
        }
    ],
    gRed: false,
    g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
    ]
});

},{"1c9db357c0845afa":"gOEGU","47ec78745540f875":"72OoG","e30b16e4a47a5405":"8sNT5","9eada5f7049e7dfd":"lgNSV"}],"gOEGU":[function(require,module,exports) {
var hash = exports;
hash.utils = require("38593959f18bd562");
hash.common = require("31a457752237e8ad");
hash.sha = require("3e37816d2a2fd68d");
hash.ripemd = require("ce5a13b5bd10f171");
hash.hmac = require("c32fbac97a361580");
// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"38593959f18bd562":"kfzn2","31a457752237e8ad":"ecAfF","3e37816d2a2fd68d":"8nbee","ce5a13b5bd10f171":"9kyRQ","c32fbac97a361580":"5KrrE"}],"kfzn2":[function(require,module,exports) {
"use strict";
var assert = require("6002b0feade022a4");
var inherits = require("d4826c9d0ff1b1f");
exports.inherits = inherits;
function isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) return false;
    if (i < 0 || i + 1 >= msg.length) return false;
    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}
function toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];
    if (typeof msg === "string") {
        if (!enc) {
            // Inspired by stringToUtf8ByteArray() in closure-library by Google
            // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
            // Apache License 2.0
            // https://github.com/google/closure-library/blob/master/LICENSE
            var p = 0;
            for(var i = 0; i < msg.length; i++){
                var c = msg.charCodeAt(i);
                if (c < 128) res[p++] = c;
                else if (c < 2048) {
                    res[p++] = c >> 6 | 192;
                    res[p++] = c & 63 | 128;
                } else if (isSurrogatePair(msg, i)) {
                    c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
                    res[p++] = c >> 18 | 240;
                    res[p++] = c >> 12 & 63 | 128;
                    res[p++] = c >> 6 & 63 | 128;
                    res[p++] = c & 63 | 128;
                } else {
                    res[p++] = c >> 12 | 224;
                    res[p++] = c >> 6 & 63 | 128;
                    res[p++] = c & 63 | 128;
                }
            }
        } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0) msg = "0" + msg;
            for(i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
    } else for(i = 0; i < msg.length; i++)res[i] = msg[i] | 0;
    return res;
}
exports.toArray = toArray;
function toHex(msg) {
    var res = "";
    for(var i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));
    return res;
}
exports.toHex = toHex;
function htonl(w) {
    var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
    return res >>> 0;
}
exports.htonl = htonl;
function toHex32(msg, endian) {
    var res = "";
    for(var i = 0; i < msg.length; i++){
        var w = msg[i];
        if (endian === "little") w = htonl(w);
        res += zero8(w.toString(16));
    }
    return res;
}
exports.toHex32 = toHex32;
function zero2(word) {
    if (word.length === 1) return "0" + word;
    else return word;
}
exports.zero2 = zero2;
function zero8(word) {
    if (word.length === 7) return "0" + word;
    else if (word.length === 6) return "00" + word;
    else if (word.length === 5) return "000" + word;
    else if (word.length === 4) return "0000" + word;
    else if (word.length === 3) return "00000" + word;
    else if (word.length === 2) return "000000" + word;
    else if (word.length === 1) return "0000000" + word;
    else return word;
}
exports.zero8 = zero8;
function join32(msg, start, end, endian) {
    var len = end - start;
    assert(len % 4 === 0);
    var res = new Array(len / 4);
    for(var i = 0, k = start; i < res.length; i++, k += 4){
        var w;
        if (endian === "big") w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
    }
    return res;
}
exports.join32 = join32;
function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for(var i = 0, k = 0; i < msg.length; i++, k += 4){
        var m = msg[i];
        if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 0xff;
            res[k + 2] = m >>> 8 & 0xff;
            res[k + 3] = m & 0xff;
        } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 0xff;
            res[k + 1] = m >>> 8 & 0xff;
            res[k] = m & 0xff;
        }
    }
    return res;
}
exports.split32 = split32;
function rotr32(w, b) {
    return w >>> b | w << 32 - b;
}
exports.rotr32 = rotr32;
function rotl32(w, b) {
    return w << b | w >>> 32 - b;
}
exports.rotl32 = rotl32;
function sum32(a, b) {
    return a + b >>> 0;
}
exports.sum32 = sum32;
function sum32_3(a, b, c) {
    return a + b + c >>> 0;
}
exports.sum32_3 = sum32_3;
function sum32_4(a, b, c, d) {
    return a + b + c + d >>> 0;
}
exports.sum32_4 = sum32_4;
function sum32_5(a, b, c, d, e) {
    return a + b + c + d + e >>> 0;
}
exports.sum32_5 = sum32_5;
function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
}
exports.sum64 = sum64;
function sum64_hi(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
}
exports.sum64_hi = sum64_hi;
function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
}
exports.sum64_lo = sum64_lo;
function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;
function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;
function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;
function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;
function rotr64_hi(ah, al, num) {
    var r = al << 32 - num | ah >>> num;
    return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;
function rotr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;
function shr64_hi(ah, al, num) {
    return ah >>> num;
}
exports.shr64_hi = shr64_hi;
function shr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"6002b0feade022a4":"8OvWh","d4826c9d0ff1b1f":"bRL3M"}],"ecAfF":[function(require,module,exports) {
"use strict";
var utils = require("e9291abdfb47ee4f");
var assert = require("ea8841b701712638");
function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;
BlockHash.prototype.update = function update(msg, enc) {
    // Convert message to array, pad it, and join into 32bit blocks
    msg = utils.toArray(msg, enc);
    if (!this.pending) this.pending = msg;
    else this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    // Enough data, try updating
    if (this.pending.length >= this._delta8) {
        msg = this.pending;
        // Process pending data in blocks
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0) this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for(var i = 0; i < msg.length; i += this._delta32)this._update(msg, i, i + this._delta32);
    }
    return this;
};
BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest(enc);
};
BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 0x80;
    for(var i = 1; i < k; i++)res[i] = 0;
    // Append length
    len <<= 3;
    if (this.endian === "big") {
        for(var t = 8; t < this.padLength; t++)res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len & 0xff;
    } else {
        res[i++] = len & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for(t = 8; t < this.padLength; t++)res[i++] = 0;
    }
    return res;
};

},{"e9291abdfb47ee4f":"kfzn2","ea8841b701712638":"8OvWh"}],"8nbee":[function(require,module,exports) {
"use strict";
exports.sha1 = require("3835379564860fd7");
exports.sha224 = require("bb9f72f042233648");
exports.sha256 = require("20a3b0fa42e37dfe");
exports.sha384 = require("ad4827efa7d953c2");
exports.sha512 = require("301292595a944c1d");

},{"3835379564860fd7":"fnjyb","bb9f72f042233648":"9x7tY","20a3b0fa42e37dfe":"9bCbT","ad4827efa7d953c2":"lJMiS","301292595a944c1d":"8y482"}],"fnjyb":[function(require,module,exports) {
"use strict";
var utils = require("b75f3c1442bf9100");
var common = require("a29e68029e4c48f8");
var shaCommon = require("1be62f90a237cba5");
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;
var sha1_K = [
    0x5A827999,
    0x6ED9EBA1,
    0x8F1BBCDC,
    0xCA62C1D6
];
function SHA1() {
    if (!(this instanceof SHA1)) return new SHA1();
    BlockHash.call(this);
    this.h = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    this.W = new Array(80);
}
utils.inherits(SHA1, BlockHash);
module.exports = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for(var i = 0; i < 16; i++)W[i] = msg[start + i];
    for(; i < W.length; i++)W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for(i = 0; i < W.length; i++){
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
};
SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "big");
    else return utils.split32(this.h, "big");
};

},{"b75f3c1442bf9100":"kfzn2","a29e68029e4c48f8":"ecAfF","1be62f90a237cba5":"gzrNi"}],"gzrNi":[function(require,module,exports) {
"use strict";
var utils = require("f0fb61f828bacd0f");
var rotr32 = utils.rotr32;
function ft_1(s, x, y, z) {
    if (s === 0) return ch32(x, y, z);
    if (s === 1 || s === 3) return p32(x, y, z);
    if (s === 2) return maj32(x, y, z);
}
exports.ft_1 = ft_1;
function ch32(x, y, z) {
    return x & y ^ ~x & z;
}
exports.ch32 = ch32;
function maj32(x, y, z) {
    return x & y ^ x & z ^ y & z;
}
exports.maj32 = maj32;
function p32(x, y, z) {
    return x ^ y ^ z;
}
exports.p32 = p32;
function s0_256(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;
function s1_256(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;
function g0_256(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
exports.g0_256 = g0_256;
function g1_256(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}
exports.g1_256 = g1_256;

},{"f0fb61f828bacd0f":"kfzn2"}],"9x7tY":[function(require,module,exports) {
"use strict";
var utils = require("fe5acd040463c159");
var SHA256 = require("fa3503eda3738d05");
function SHA224() {
    if (!(this instanceof SHA224)) return new SHA224();
    SHA256.call(this);
    this.h = [
        0xc1059ed8,
        0x367cd507,
        0x3070dd17,
        0xf70e5939,
        0xffc00b31,
        0x68581511,
        0x64f98fa7,
        0xbefa4fa4
    ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest(enc) {
    // Just truncate output
    if (enc === "hex") return utils.toHex32(this.h.slice(0, 7), "big");
    else return utils.split32(this.h.slice(0, 7), "big");
};

},{"fe5acd040463c159":"kfzn2","fa3503eda3738d05":"9bCbT"}],"9bCbT":[function(require,module,exports) {
"use strict";
var utils = require("32ad3e510bd41f2a");
var common = require("469ad88ad505772a");
var shaCommon = require("fffa7d1ddf1f0b43");
var assert = require("126369f57b5225ed");
var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash = common.BlockHash;
var sha256_K = [
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
];
function SHA256() {
    if (!(this instanceof SHA256)) return new SHA256();
    BlockHash.call(this);
    this.h = [
        0x6a09e667,
        0xbb67ae85,
        0x3c6ef372,
        0xa54ff53a,
        0x510e527f,
        0x9b05688c,
        0x1f83d9ab,
        0x5be0cd19
    ];
    this.k = sha256_K;
    this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;
SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;
SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for(var i = 0; i < 16; i++)W[i] = msg[start + i];
    for(; i < W.length; i++)W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert(this.k.length === W.length);
    for(i = 0; i < W.length; i++){
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
};
SHA256.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "big");
    else return utils.split32(this.h, "big");
};

},{"32ad3e510bd41f2a":"kfzn2","469ad88ad505772a":"ecAfF","fffa7d1ddf1f0b43":"gzrNi","126369f57b5225ed":"8OvWh"}],"lJMiS":[function(require,module,exports) {
"use strict";
var utils = require("a696ee34c45713da");
var SHA512 = require("fff95253fdaa49ea");
function SHA384() {
    if (!(this instanceof SHA384)) return new SHA384();
    SHA512.call(this);
    this.h = [
        0xcbbb9d5d,
        0xc1059ed8,
        0x629a292a,
        0x367cd507,
        0x9159015a,
        0x3070dd17,
        0x152fecd8,
        0xf70e5939,
        0x67332667,
        0xffc00b31,
        0x8eb44a87,
        0x68581511,
        0xdb0c2e0d,
        0x64f98fa7,
        0x47b5481d,
        0xbefa4fa4
    ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h.slice(0, 12), "big");
    else return utils.split32(this.h.slice(0, 12), "big");
};

},{"a696ee34c45713da":"kfzn2","fff95253fdaa49ea":"8y482"}],"8y482":[function(require,module,exports) {
"use strict";
var utils = require("7753b1fa702fbb54");
var common = require("81b6970d75627ce1");
var assert = require("f660976cede694e2");
var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = common.BlockHash;
var sha512_K = [
    0x428a2f98,
    0xd728ae22,
    0x71374491,
    0x23ef65cd,
    0xb5c0fbcf,
    0xec4d3b2f,
    0xe9b5dba5,
    0x8189dbbc,
    0x3956c25b,
    0xf348b538,
    0x59f111f1,
    0xb605d019,
    0x923f82a4,
    0xaf194f9b,
    0xab1c5ed5,
    0xda6d8118,
    0xd807aa98,
    0xa3030242,
    0x12835b01,
    0x45706fbe,
    0x243185be,
    0x4ee4b28c,
    0x550c7dc3,
    0xd5ffb4e2,
    0x72be5d74,
    0xf27b896f,
    0x80deb1fe,
    0x3b1696b1,
    0x9bdc06a7,
    0x25c71235,
    0xc19bf174,
    0xcf692694,
    0xe49b69c1,
    0x9ef14ad2,
    0xefbe4786,
    0x384f25e3,
    0x0fc19dc6,
    0x8b8cd5b5,
    0x240ca1cc,
    0x77ac9c65,
    0x2de92c6f,
    0x592b0275,
    0x4a7484aa,
    0x6ea6e483,
    0x5cb0a9dc,
    0xbd41fbd4,
    0x76f988da,
    0x831153b5,
    0x983e5152,
    0xee66dfab,
    0xa831c66d,
    0x2db43210,
    0xb00327c8,
    0x98fb213f,
    0xbf597fc7,
    0xbeef0ee4,
    0xc6e00bf3,
    0x3da88fc2,
    0xd5a79147,
    0x930aa725,
    0x06ca6351,
    0xe003826f,
    0x14292967,
    0x0a0e6e70,
    0x27b70a85,
    0x46d22ffc,
    0x2e1b2138,
    0x5c26c926,
    0x4d2c6dfc,
    0x5ac42aed,
    0x53380d13,
    0x9d95b3df,
    0x650a7354,
    0x8baf63de,
    0x766a0abb,
    0x3c77b2a8,
    0x81c2c92e,
    0x47edaee6,
    0x92722c85,
    0x1482353b,
    0xa2bfe8a1,
    0x4cf10364,
    0xa81a664b,
    0xbc423001,
    0xc24b8b70,
    0xd0f89791,
    0xc76c51a3,
    0x0654be30,
    0xd192e819,
    0xd6ef5218,
    0xd6990624,
    0x5565a910,
    0xf40e3585,
    0x5771202a,
    0x106aa070,
    0x32bbd1b8,
    0x19a4c116,
    0xb8d2d0c8,
    0x1e376c08,
    0x5141ab53,
    0x2748774c,
    0xdf8eeb99,
    0x34b0bcb5,
    0xe19b48a8,
    0x391c0cb3,
    0xc5c95a63,
    0x4ed8aa4a,
    0xe3418acb,
    0x5b9cca4f,
    0x7763e373,
    0x682e6ff3,
    0xd6b2b8a3,
    0x748f82ee,
    0x5defb2fc,
    0x78a5636f,
    0x43172f60,
    0x84c87814,
    0xa1f0ab72,
    0x8cc70208,
    0x1a6439ec,
    0x90befffa,
    0x23631e28,
    0xa4506ceb,
    0xde82bde9,
    0xbef9a3f7,
    0xb2c67915,
    0xc67178f2,
    0xe372532b,
    0xca273ece,
    0xea26619c,
    0xd186b8c7,
    0x21c0c207,
    0xeada7dd6,
    0xcde0eb1e,
    0xf57d4f7f,
    0xee6ed178,
    0x06f067aa,
    0x72176fba,
    0x0a637dc5,
    0xa2c898a6,
    0x113f9804,
    0xbef90dae,
    0x1b710b35,
    0x131c471b,
    0x28db77f5,
    0x23047d84,
    0x32caab7b,
    0x40c72493,
    0x3c9ebe0a,
    0x15c9bebc,
    0x431d67c4,
    0x9c100d4c,
    0x4cc5d4be,
    0xcb3e42b6,
    0x597f299c,
    0xfc657e2a,
    0x5fcb6fab,
    0x3ad6faec,
    0x6c44198c,
    0x4a475817
];
function SHA512() {
    if (!(this instanceof SHA512)) return new SHA512();
    BlockHash.call(this);
    this.h = [
        0x6a09e667,
        0xf3bcc908,
        0xbb67ae85,
        0x84caa73b,
        0x3c6ef372,
        0xfe94f82b,
        0xa54ff53a,
        0x5f1d36f1,
        0x510e527f,
        0xade682d1,
        0x9b05688c,
        0x2b3e6c1f,
        0x1f83d9ab,
        0xfb41bd6b,
        0x5be0cd19,
        0x137e2179
    ];
    this.k = sha512_K;
    this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;
SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;
SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    // 32 x 32bit words
    for(var i = 0; i < 32; i++)W[i] = msg[start + i];
    for(; i < W.length; i += 2){
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14]; // i - 7
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32]; // i - 16
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
};
SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert(this.k.length === W.length);
    for(var i = 0; i < W.length; i += 2){
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
};
SHA512.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "big");
    else return utils.split32(this.h, "big");
};
function ch64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ ~xh & zh;
    if (r < 0) r += 0x100000000;
    return r;
}
function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    if (r < 0) r += 0x100000000;
    return r;
}
function maj64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ xh & zh ^ yh & zh;
    if (r < 0) r += 0x100000000;
    return r;
}
function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    if (r < 0) r += 0x100000000;
    return r;
}
function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2); // 34
    var c2_hi = rotr64_hi(xl, xh, 7); // 39
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2); // 34
    var c2_lo = rotr64_lo(xl, xh, 7); // 39
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9); // 41
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9); // 41
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29); // 61
    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29); // 61
    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}

},{"7753b1fa702fbb54":"kfzn2","81b6970d75627ce1":"ecAfF","f660976cede694e2":"8OvWh"}],"9kyRQ":[function(require,module,exports) {
"use strict";
var utils = require("36495272d446418f");
var common = require("ad8cf0490e28e8d7");
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
    if (!(this instanceof RIPEMD160)) return new RIPEMD160();
    BlockHash.call(this);
    this.h = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    this.endian = "little";
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for(var j = 0; j < 80; j++){
        var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
};
RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === "hex") return utils.toHex32(this.h, "little");
    else return utils.split32(this.h, "little");
};
function f(j, x, y, z) {
    if (j <= 15) return x ^ y ^ z;
    else if (j <= 31) return x & y | ~x & z;
    else if (j <= 47) return (x | ~y) ^ z;
    else if (j <= 63) return x & z | y & ~z;
    else return x ^ (y | ~z);
}
function K(j) {
    if (j <= 15) return 0x00000000;
    else if (j <= 31) return 0x5a827999;
    else if (j <= 47) return 0x6ed9eba1;
    else if (j <= 63) return 0x8f1bbcdc;
    else return 0xa953fd4e;
}
function Kh(j) {
    if (j <= 15) return 0x50a28be6;
    else if (j <= 31) return 0x5c4dd124;
    else if (j <= 47) return 0x6d703ef3;
    else if (j <= 63) return 0x7a6d76e9;
    else return 0x00000000;
}
var r = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
];
var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
];
var s = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
];
var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
];

},{"36495272d446418f":"kfzn2","ad8cf0490e28e8d7":"ecAfF"}],"5KrrE":[function(require,module,exports) {
"use strict";
var utils = require("596c08b6835a6e2d");
var assert = require("be527907d4f06808");
function Hmac(hash, key, enc) {
    if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils.toArray(key, enc));
}
module.exports = Hmac;
Hmac.prototype._init = function init(key) {
    // Shorten key, if needed
    if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    // Add padding to key
    for(var i = key.length; i < this.blockSize; i++)key.push(0);
    for(i = 0; i < key.length; i++)key[i] ^= 0x36;
    this.inner = new this.Hash().update(key);
    // 0x36 ^ 0x5c = 0x6a
    for(i = 0; i < key.length; i++)key[i] ^= 0x6a;
    this.outer = new this.Hash().update(key);
};
Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
};
Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
};

},{"596c08b6835a6e2d":"kfzn2","be527907d4f06808":"8OvWh"}],"lgNSV":[function(require,module,exports) {
module.exports = {
    doubles: {
        step: 4,
        points: [
            [
                "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
                "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
            ],
            [
                "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
                "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
            ],
            [
                "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
                "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
            ],
            [
                "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
                "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
            ],
            [
                "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
                "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
            ],
            [
                "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
                "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
            ],
            [
                "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
                "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
            ],
            [
                "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
                "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
            ],
            [
                "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
                "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
            ],
            [
                "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
                "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
            ],
            [
                "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
                "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
            ],
            [
                "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
                "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
            ],
            [
                "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
                "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
            ],
            [
                "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
                "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
            ],
            [
                "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
                "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
            ],
            [
                "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
                "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
            ],
            [
                "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
                "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
            ],
            [
                "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
                "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
            ],
            [
                "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
                "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
            ],
            [
                "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
                "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
            ],
            [
                "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
                "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
            ],
            [
                "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
                "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
            ],
            [
                "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
                "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
            ],
            [
                "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
                "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
            ],
            [
                "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
                "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
            ],
            [
                "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
                "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
            ],
            [
                "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
                "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
            ],
            [
                "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
                "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
            ],
            [
                "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
                "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
            ],
            [
                "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
                "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
            ],
            [
                "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
                "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
            ],
            [
                "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
                "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
            ],
            [
                "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
                "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
            ],
            [
                "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
                "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
            ],
            [
                "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
                "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
            ],
            [
                "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
                "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
            ],
            [
                "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
                "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
            ],
            [
                "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
                "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
            ],
            [
                "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
                "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
            ],
            [
                "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
                "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
            ],
            [
                "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
                "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
            ],
            [
                "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
                "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
            ],
            [
                "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
                "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
            ],
            [
                "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
                "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
            ],
            [
                "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
                "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
            ],
            [
                "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
                "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
            ],
            [
                "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
                "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
            ],
            [
                "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
                "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
            ],
            [
                "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
                "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
            ],
            [
                "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
                "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
            ],
            [
                "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
                "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
            ],
            [
                "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
                "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
            ],
            [
                "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
                "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
            ],
            [
                "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
                "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
            ],
            [
                "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
                "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
            ],
            [
                "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
                "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
            ],
            [
                "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
                "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
            ],
            [
                "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
                "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
            ],
            [
                "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
                "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
            ],
            [
                "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
                "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
            ],
            [
                "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
                "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
            ],
            [
                "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
                "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
            ],
            [
                "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
                "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
            ],
            [
                "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
                "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
            ],
            [
                "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
                "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
            ]
        ]
    },
    naf: {
        wnd: 7,
        points: [
            [
                "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
                "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
            ],
            [
                "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
                "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
            ],
            [
                "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
                "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
            ],
            [
                "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
                "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
            ],
            [
                "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
                "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
            ],
            [
                "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
                "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
            ],
            [
                "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
                "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
            ],
            [
                "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
                "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
            ],
            [
                "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
                "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
            ],
            [
                "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
                "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
            ],
            [
                "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
                "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
            ],
            [
                "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
                "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
            ],
            [
                "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
                "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
            ],
            [
                "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
                "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
            ],
            [
                "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
                "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
            ],
            [
                "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
                "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
            ],
            [
                "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
                "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
            ],
            [
                "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
                "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
            ],
            [
                "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
                "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
            ],
            [
                "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
                "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
            ],
            [
                "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
                "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
            ],
            [
                "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
                "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
            ],
            [
                "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
                "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
            ],
            [
                "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
                "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
            ],
            [
                "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
                "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
            ],
            [
                "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
                "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
            ],
            [
                "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
                "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
            ],
            [
                "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
                "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
            ],
            [
                "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
                "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
            ],
            [
                "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
                "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
            ],
            [
                "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
                "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
            ],
            [
                "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
                "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
            ],
            [
                "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
                "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
            ],
            [
                "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
                "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
            ],
            [
                "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
                "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
            ],
            [
                "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
                "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
            ],
            [
                "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
                "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
            ],
            [
                "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
                "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
            ],
            [
                "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
                "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
            ],
            [
                "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
                "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
            ],
            [
                "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
                "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
            ],
            [
                "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
                "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
            ],
            [
                "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
                "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
            ],
            [
                "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
                "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
            ],
            [
                "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
                "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
            ],
            [
                "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
                "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
            ],
            [
                "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
                "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
            ],
            [
                "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
                "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
            ],
            [
                "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
                "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
            ],
            [
                "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
                "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
            ],
            [
                "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
                "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
            ],
            [
                "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
                "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
            ],
            [
                "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
                "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
            ],
            [
                "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
                "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
            ],
            [
                "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
                "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
            ],
            [
                "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
                "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
            ],
            [
                "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
                "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
            ],
            [
                "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
                "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
            ],
            [
                "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
                "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
            ],
            [
                "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
                "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
            ],
            [
                "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
                "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
            ],
            [
                "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
                "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
            ],
            [
                "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
                "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
            ],
            [
                "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
                "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
            ],
            [
                "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
                "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
            ],
            [
                "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
                "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
            ],
            [
                "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
                "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
            ],
            [
                "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
                "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
            ],
            [
                "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
                "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
            ],
            [
                "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
                "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
            ],
            [
                "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
                "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
            ],
            [
                "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
                "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
            ],
            [
                "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
                "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
            ],
            [
                "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
                "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
            ],
            [
                "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
                "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
            ],
            [
                "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
                "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
            ],
            [
                "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
                "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
            ],
            [
                "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
                "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
            ],
            [
                "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
                "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
            ],
            [
                "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
                "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
            ],
            [
                "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
                "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
            ],
            [
                "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
                "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
            ],
            [
                "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
                "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
            ],
            [
                "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
                "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
            ],
            [
                "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
                "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
            ],
            [
                "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
                "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
            ],
            [
                "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
                "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
            ],
            [
                "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
                "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
            ],
            [
                "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
                "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
            ],
            [
                "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
                "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
            ],
            [
                "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
                "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
            ],
            [
                "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
                "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
            ],
            [
                "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
                "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
            ],
            [
                "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
                "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
            ],
            [
                "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
                "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
            ],
            [
                "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
                "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
            ],
            [
                "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
                "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
            ],
            [
                "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
                "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
            ],
            [
                "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
                "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
            ],
            [
                "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
                "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
            ],
            [
                "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
                "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
            ],
            [
                "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
                "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
            ],
            [
                "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
                "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
            ],
            [
                "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
                "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
            ],
            [
                "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
                "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
            ],
            [
                "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
                "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
            ],
            [
                "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
                "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
            ],
            [
                "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
                "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
            ],
            [
                "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
                "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
            ],
            [
                "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
                "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
            ],
            [
                "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
                "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
            ],
            [
                "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
                "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
            ],
            [
                "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
                "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
            ],
            [
                "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
                "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
            ],
            [
                "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
                "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
            ],
            [
                "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
                "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
            ],
            [
                "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
                "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
            ],
            [
                "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
                "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
            ],
            [
                "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
                "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
            ],
            [
                "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
                "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
            ],
            [
                "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
                "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
            ],
            [
                "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
                "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
            ],
            [
                "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
                "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
            ],
            [
                "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
                "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
            ],
            [
                "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
                "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
            ],
            [
                "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
                "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
            ],
            [
                "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
                "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
            ]
        ]
    }
};

},{}],"5gDK1":[function(require,module,exports) {
"use strict";
var BN = require("2e69183faf5285a1");
var HmacDRBG = require("b0cb641292e4911d");
var utils = require("eab3e45147b180ba");
var curves = require("a5ce61d26ce01c4c");
var rand = require("f6342f89ac472937");
var assert = utils.assert;
var KeyPair = require("eb5ba559e423f6e9");
var Signature = require("7c5e2c76c574ce41");
function EC(options) {
    if (!(this instanceof EC)) return new EC(options);
    // Shortcut `elliptic.ec(curve-name)`
    if (typeof options === "string") {
        assert(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options);
        options = curves[options];
    }
    // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
    if (options instanceof curves.PresetCurve) options = {
        curve: options
    };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    // Point on curve
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    // Hash for function for DRBG
    this.hash = options.hash || options.curve.hash;
}
module.exports = EC;
EC.prototype.keyPair = function keyPair(options) {
    return new KeyPair(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options) options = {};
    // Instantiate Hmac_DRBG
    var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN(2));
    for(;;){
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0) continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
    }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
    var byteLength;
    if (BN.isBN(msg) || typeof msg === "number") {
        msg = new BN(msg, 16);
        byteLength = msg.byteLength();
    } else if (typeof msg === "object") {
        // BN assumes an array-like input and asserts length
        byteLength = msg.length;
        msg = new BN(msg, 16);
    } else {
        // BN converts the value to string
        var str = msg.toString();
        // HEX encoding
        byteLength = str.length + 1 >>> 1;
        msg = new BN(str, 16);
    }
    // Allow overriding
    if (typeof bitLength !== "number") bitLength = byteLength * 8;
    var delta = bitLength - this.n.bitLength();
    if (delta > 0) msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);
    else return msg;
};
EC.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === "object") {
        options = enc;
        enc = null;
    }
    if (!options) options = {};
    if (typeof msg !== "string" && typeof msg !== "number" && !BN.isBN(msg)) {
        assert(typeof msg === "object" && msg && typeof msg.length === "number", "Expected message to be an array-like, a hex string, or a BN instance");
        assert(msg.length >>> 0 === msg.length); // non-negative 32-bit integer
        for(var i = 0; i < msg.length; i++)assert((msg[i] & 255) === msg[i]);
    }
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(msg, false, options.msgBitLength);
    // Would fail further checks, but let's make the error message clear
    assert(!msg.isNeg(), "Can not sign a negative message");
    // Zero-extend key to provide enough entropy
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray("be", bytes);
    // Zero-extend nonce to have the same byte size as N
    var nonce = msg.toArray("be", bytes);
    // Recheck nonce to be bijective to msg
    assert(new BN(nonce).eq(msg), "Can not sign message");
    // Instantiate Hmac_DRBG
    var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce: nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
    });
    // Number of bytes to generate
    var ns1 = this.n.sub(new BN(1));
    for(var iter = 0;; iter++){
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity()) continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0) continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0) continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        // Use complement of `s`, if it is > `n / 2`
        if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
        }
        return new Signature({
            r: r,
            s: s,
            recoveryParam: recoveryParam
        });
    }
};
EC.prototype.verify = function verify(msg, signature, key, enc, options) {
    if (!options) options = {};
    msg = this._truncateToN(msg, false, options.msgBitLength);
    key = this.keyFromPublic(key, enc);
    signature = new Signature(signature, "hex");
    // Perform primitive values validation
    var r = signature.r;
    var s = signature.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;
    // Validate signature
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    var p;
    if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity()) return false;
        return p.getX().umod(this.n).cmp(r) === 0;
    }
    // NOTE: Greg Maxwell's trick, inspired by:
    // https://git.io/vad3K
    p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity()) return false;
    // Compare `p.x` of Jacobian point with `r`,
    // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
    // inverse of `p.z^2`
    return p.eqXToP(r);
};
EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
    assert((3 & j) === j, "The recovery param is more than two bits");
    signature = new Signature(signature, enc);
    var n = this.n;
    var e = new BN(msg);
    var r = signature.r;
    var s = signature.s;
    // A set LSB signifies that the y-coordinate is odd
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error("Unable to find sencond key candinate");
    // 1.1. Let x = r + jn.
    if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    else r = this.curve.pointFromX(r, isYOdd);
    var rInv = signature.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s2 = s.mul(rInv).umod(n);
    // 1.6.1 Compute Q = r^-1 (sR -  eG)
    //               Q = r^-1 (sR + -eG)
    return this.g.mulAdd(s1, r, s2);
};
EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
    signature = new Signature(signature, enc);
    if (signature.recoveryParam !== null) return signature.recoveryParam;
    for(var i = 0; i < 4; i++){
        var Qprime;
        try {
            Qprime = this.recoverPubKey(e, signature, i);
        } catch (e) {
            continue;
        }
        if (Qprime.eq(Q)) return i;
    }
    throw new Error("Unable to find valid recovery factor");
};

},{"2e69183faf5285a1":"VopIn","b0cb641292e4911d":"eMMR6","eab3e45147b180ba":"8sNT5","a5ce61d26ce01c4c":"6yRo9","f6342f89ac472937":"8FGdh","eb5ba559e423f6e9":"c4oIH","7c5e2c76c574ce41":"cRuxW"}],"eMMR6":[function(require,module,exports) {
"use strict";
var hash = require("629972fec592198f");
var utils = require("c20531edfb274a2c");
var assert = require("43ff1863ab3fce20");
function HmacDRBG(options) {
    if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
    var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
    var pers = utils.toArray(options.pers, options.persEnc || "hex");
    assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;
HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for(var i = 0; i < this.V.length; i++){
        this.K[i] = 0x00;
        this.V[i] = 0x01;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 0x1000000000000; // 2^48
};
HmacDRBG.prototype._hmac = function hmac() {
    return new hash.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([
        0x00
    ]);
    if (seed) kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed) return;
    this.K = this._hmac().update(this.V).update([
        0x01
    ]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    // Optional entropy enc
    if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
    }
    entropy = utils.toArray(entropy, entropyEnc);
    add = utils.toArray(add, addEnc);
    assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._update(entropy.concat(add || []));
    this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
    // Optional encoding
    if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
    }
    // Optional additional data
    if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
    }
    var temp = [];
    while(temp.length < len){
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add);
    this._reseed++;
    return utils.encode(res, enc);
};

},{"629972fec592198f":"gOEGU","c20531edfb274a2c":"6f39G","43ff1863ab3fce20":"8OvWh"}],"c4oIH":[function(require,module,exports) {
"use strict";
var BN = require("55cc33a33cda153d");
var utils = require("bda8b1ff480a7f3");
var assert = utils.assert;
function KeyPair(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;
    // KeyPair(ec, { priv: ..., pub: ... })
    if (options.priv) this._importPrivate(options.priv, options.privEnc);
    if (options.pub) this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;
KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair) return pub;
    return new KeyPair(ec, {
        pub: pub,
        pubEnc: enc
    });
};
KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair) return priv;
    return new KeyPair(ec, {
        priv: priv,
        privEnc: enc
    });
};
KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity()) return {
        result: false,
        reason: "Invalid public key"
    };
    if (!pub.validate()) return {
        result: false,
        reason: "Public key is not a point"
    };
    if (!pub.mul(this.ec.curve.n).isInfinity()) return {
        result: false,
        reason: "Public key * N != O"
    };
    return {
        result: true,
        reason: null
    };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    // compact is optional argument
    if (typeof compact === "string") {
        enc = compact;
        compact = null;
    }
    if (!this.pub) this.pub = this.ec.g.mul(this.priv);
    if (!enc) return this.pub;
    return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === "hex") return this.priv.toString(16, 2);
    else return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new BN(key, enc || 16);
    // Ensure that the priv won't be bigger than n, otherwise we may fail
    // in fixed multiplication method
    this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
        // Montgomery points only have an `x` coordinate.
        // Weierstrass/Edwards points on the other hand have both `x` and
        // `y` coordinates.
        if (this.ec.curve.type === "mont") assert(key.x, "Need x coordinate");
        else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") assert(key.x && key.y, "Need both x and y coordinate");
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
};
// ECDH
KeyPair.prototype.derive = function derive(pub) {
    if (!pub.validate()) assert(pub.validate(), "public point not validated");
    return pub.mul(this.priv).getX();
};
// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature, options) {
    return this.ec.verify(msg, signature, this, undefined, options);
};
KeyPair.prototype.inspect = function inspect() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};

},{"55cc33a33cda153d":"VopIn","bda8b1ff480a7f3":"8sNT5"}],"cRuxW":[function(require,module,exports) {
"use strict";
var BN = require("a7ae8f0fe39990e7");
var utils = require("5df7da4811374387");
var assert = utils.assert;
function Signature(options, enc) {
    if (options instanceof Signature) return options;
    if (this._importDER(options, enc)) return;
    assert(options.r && options.s, "Signature without r or s");
    this.r = new BN(options.r, 16);
    this.s = new BN(options.s, 16);
    if (options.recoveryParam === undefined) this.recoveryParam = null;
    else this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;
function Position() {
    this.place = 0;
}
function getLength(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 0x80)) return initial;
    var octetLen = initial & 0xf;
    // Indefinite length or overflow
    if (octetLen === 0 || octetLen > 4) return false;
    if (buf[p.place] === 0x00) return false;
    var val = 0;
    for(var i = 0, off = p.place; i < octetLen; i++, off++){
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
    }
    // Leading zeroes
    if (val <= 0x7f) return false;
    p.place = off;
    return val;
}
function rmPadding(buf) {
    var i = 0;
    var len = buf.length - 1;
    while(!buf[i] && !(buf[i + 1] & 0x80) && i < len)i++;
    if (i === 0) return buf;
    return buf.slice(i);
}
Signature.prototype._importDER = function _importDER(data, enc) {
    data = utils.toArray(data, enc);
    var p = new Position();
    if (data[p.place++] !== 0x30) return false;
    var len = getLength(data, p);
    if (len === false) return false;
    if (len + p.place !== data.length) return false;
    if (data[p.place++] !== 0x02) return false;
    var rlen = getLength(data, p);
    if (rlen === false) return false;
    if ((data[p.place] & 128) !== 0) return false;
    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 0x02) return false;
    var slen = getLength(data, p);
    if (slen === false) return false;
    if (data.length !== slen + p.place) return false;
    if ((data[p.place] & 128) !== 0) return false;
    var s = data.slice(p.place, slen + p.place);
    if (r[0] === 0) {
        if (r[1] & 0x80) r = r.slice(1);
        else // Leading zeroes
        return false;
    }
    if (s[0] === 0) {
        if (s[1] & 0x80) s = s.slice(1);
        else // Leading zeroes
        return false;
    }
    this.r = new BN(r);
    this.s = new BN(s);
    this.recoveryParam = null;
    return true;
};
function constructLength(arr, len) {
    if (len < 0x80) {
        arr.push(len);
        return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 0x80);
    while(--octets)arr.push(len >>> (octets << 3) & 0xff);
    arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
    // Pad values
    if (r[0] & 0x80) r = [
        0
    ].concat(r);
    // Pad values
    if (s[0] & 0x80) s = [
        0
    ].concat(s);
    r = rmPadding(r);
    s = rmPadding(s);
    while(!s[0] && !(s[1] & 0x80))s = s.slice(1);
    var arr = [
        0x02
    ];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(0x02);
    constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [
        0x30
    ];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils.encode(res, enc);
};

},{"a7ae8f0fe39990e7":"VopIn","5df7da4811374387":"8sNT5"}],"jPbam":[function(require,module,exports) {
"use strict";
var hash = require("50f9bfa8a484d5d8");
var curves = require("68956d27442d6321");
var utils = require("99ec52641eff141d");
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require("2ad2982d76b37f15");
var Signature = require("76c25a1d63d10c1b");
function EDDSA(curve) {
    assert(curve === "ed25519", "only tested with ed25519 so far");
    if (!(this instanceof EDDSA)) return new EDDSA(curve);
    curve = curves[curve].curve;
    this.curve = curve;
    this.g = curve.g;
    this.g.precompute(curve.n.bitLength() + 1);
    this.pointClass = curve.point().constructor;
    this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
    this.hash = hash.sha512;
}
module.exports = EDDSA;
/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/ EDDSA.prototype.sign = function sign(message, secret) {
    message = parseBytes(message);
    var key = this.keyFromSecret(secret);
    var r = this.hashInt(key.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
    var S = r.add(s_).umod(this.curve.n);
    return this.makeSignature({
        R: R,
        S: S,
        Rencoded: Rencoded
    });
};
/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/ EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) return false;
    var key = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key.pub().mul(h));
    return RplusAh.eq(SG);
};
EDDSA.prototype.hashInt = function hashInt() {
    var hash = this.hash();
    for(var i = 0; i < arguments.length; i++)hash.update(arguments[i]);
    return utils.intFromLE(hash.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
};
EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
};
EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature) return sig;
    return new Signature(this, sig);
};
/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/ EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray("le", this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
    return enc;
};
EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = utils.parseBytes(bytes);
    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129);
    var xIsOdd = (bytes[lastIx] & 0x80) !== 0;
    var y = utils.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
};
EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    return utils.intFromLE(bytes);
};
EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
};

},{"50f9bfa8a484d5d8":"gOEGU","68956d27442d6321":"6yRo9","99ec52641eff141d":"8sNT5","2ad2982d76b37f15":"hOVET","76c25a1d63d10c1b":"a5qj9"}],"hOVET":[function(require,module,exports) {
"use strict";
var utils = require("387ffb9c0bf065ab");
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;
/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/ function KeyPair(eddsa, params) {
    this.eddsa = eddsa;
    this._secret = parseBytes(params.secret);
    if (eddsa.isPoint(params.pub)) this._pub = params.pub;
    else this._pubBytes = parseBytes(params.pub);
}
KeyPair.fromPublic = function fromPublic(eddsa, pub) {
    if (pub instanceof KeyPair) return pub;
    return new KeyPair(eddsa, {
        pub: pub
    });
};
KeyPair.fromSecret = function fromSecret(eddsa, secret) {
    if (secret instanceof KeyPair) return secret;
    return new KeyPair(eddsa, {
        secret: secret
    });
};
KeyPair.prototype.secret = function secret() {
    return this._secret;
};
cachedProperty(KeyPair, "pubBytes", function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
});
cachedProperty(KeyPair, "pub", function pub() {
    if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
});
cachedProperty(KeyPair, "privBytes", function privBytes() {
    var eddsa = this.eddsa;
    var hash = this.hash();
    var lastIx = eddsa.encodingLength - 1;
    var a = hash.slice(0, eddsa.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;
    return a;
});
cachedProperty(KeyPair, "priv", function priv() {
    return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty(KeyPair, "hash", function hash() {
    return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair.prototype.sign = function sign(message) {
    assert(this._secret, "KeyPair can only verify");
    return this.eddsa.sign(message, this);
};
KeyPair.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
};
KeyPair.prototype.getSecret = function getSecret(enc) {
    assert(this._secret, "KeyPair is public only");
    return utils.encode(this.secret(), enc);
};
KeyPair.prototype.getPublic = function getPublic(enc) {
    return utils.encode(this.pubBytes(), enc);
};
module.exports = KeyPair;

},{"387ffb9c0bf065ab":"8sNT5"}],"a5qj9":[function(require,module,exports) {
"use strict";
var BN = require("696e2c87f819d166");
var utils = require("51b94bcac1dcb2b2");
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;
/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/ function Signature(eddsa, sig) {
    this.eddsa = eddsa;
    if (typeof sig !== "object") sig = parseBytes(sig);
    if (Array.isArray(sig)) {
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
            R: sig.slice(0, eddsa.encodingLength),
            S: sig.slice(eddsa.encodingLength)
        };
    }
    assert(sig.R && sig.S, "Signature without R or S");
    if (eddsa.isPoint(sig.R)) this._R = sig.R;
    if (sig.S instanceof BN) this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}
cachedProperty(Signature, "S", function S() {
    return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature, "R", function R() {
    return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature, "Rencoded", function Rencoded() {
    return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature, "Sencoded", function Sencoded() {
    return this.eddsa.encodeInt(this.S());
});
Signature.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
};
Signature.prototype.toHex = function toHex() {
    return utils.encode(this.toBytes(), "hex").toUpperCase();
};
module.exports = Signature;

},{"696e2c87f819d166":"VopIn","51b94bcac1dcb2b2":"8sNT5"}],"k4HxT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
* @param {Uint8Array} public_key
* @param {Uint8Array} private_key
* @param {Uint8Array} message
* @returns {Uint8Array}
*/ parcelHelpers.export(exports, "user_preferences_encrypt", ()=>user_preferences_encrypt);
/**
* @param {Uint8Array} public_key
* @param {Uint8Array} private_key
* @param {Uint8Array} message
* @returns {Uint8Array}
*/ parcelHelpers.export(exports, "user_preferences_decrypt", ()=>user_preferences_decrypt);
/**
* @param {Uint8Array} private_key
* @returns {string}
*/ parcelHelpers.export(exports, "generate_private_preferences_topic", ()=>generate_private_preferences_topic);
parcelHelpers.export(exports, "initSync", ()=>initSync);
var global = arguments[3];
let wasm;
const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
}) : {
    decode: ()=>{
        throw Error("TextDecoder not available");
    }
};
if (typeof TextDecoder !== "undefined") cachedTextDecoder.decode();
let cachedUint8Memory0 = null;
function getUint8Memory0() {
    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
const heap = new Array(128).fill(undefined);
heap.push(undefined, null, true, false);
let heap_next = heap.length;
function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
}
function getObject(idx) {
    return heap[idx];
}
function dropObject(idx) {
    if (idx < 132) return;
    heap[idx] = heap_next;
    heap_next = idx;
}
function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}
let WASM_VECTOR_LEN = 0;
function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1, 1) >>> 0;
    getUint8Memory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
let cachedInt32Memory0 = null;
function getInt32Memory0() {
    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    return cachedInt32Memory0;
}
function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function user_preferences_encrypt(public_key, private_key, message) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(public_key, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(private_key, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);
        const len2 = WASM_VECTOR_LEN;
        wasm.user_preferences_encrypt(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) throw takeObject(r2);
        var v4 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1, 1);
        return v4;
    } finally{
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}
function user_preferences_decrypt(public_key, private_key, message) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(public_key, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArray8ToWasm0(private_key, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        const ptr2 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);
        const len2 = WASM_VECTOR_LEN;
        wasm.user_preferences_decrypt(retptr, ptr0, len0, ptr1, len1, ptr2, len2);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) throw takeObject(r2);
        var v4 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1, 1);
        return v4;
    } finally{
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}
function generate_private_preferences_topic(private_key) {
    let deferred3_0;
    let deferred3_1;
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray8ToWasm0(private_key, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.generate_private_preferences_topic(retptr, ptr0, len0);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        var ptr2 = r0;
        var len2 = r1;
        if (r3) {
            ptr2 = 0;
            len2 = 0;
            throw takeObject(r2);
        }
        deferred3_0 = ptr2;
        deferred3_1 = len2;
        return getStringFromWasm0(ptr2, len2);
    } finally{
        wasm.__wbindgen_add_to_stack_pointer(16);
        wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
}
function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        wasm.__wbindgen_exn_store(addHeapObject(e));
    }
}
async function __wbg_load(module1, imports) {
    if (typeof Response === "function" && module1 instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === "function") try {
            return await WebAssembly.instantiateStreaming(module1, imports);
        } catch (e) {
            if (module1.headers.get("Content-Type") != "application/wasm") console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
            else throw e;
        }
        const bytes = await module1.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);
    } else {
        const instance = await WebAssembly.instantiate(module1, imports);
        if (instance instanceof WebAssembly.Instance) return {
            instance,
            module: module1
        };
        else return instance;
    }
}
function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
        const ret = getStringFromWasm0(arg0, arg1);
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
        takeObject(arg0);
    };
    imports.wbg.__wbg_crypto_d05b68a3572bb8ca = function(arg0) {
        const ret = getObject(arg0).crypto;
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_is_object = function(arg0) {
        const val = getObject(arg0);
        const ret = typeof val === "object" && val !== null;
        return ret;
    };
    imports.wbg.__wbg_process_b02b3570280d0366 = function(arg0) {
        const ret = getObject(arg0).process;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_versions_c1cb42213cedf0f5 = function(arg0) {
        const ret = getObject(arg0).versions;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_node_43b1089f407e4ec2 = function(arg0) {
        const ret = getObject(arg0).node;
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_is_string = function(arg0) {
        const ret = typeof getObject(arg0) === "string";
        return ret;
    };
    imports.wbg.__wbg_require_9a7e0f667ead4995 = function() {
        return handleError(function() {
            const ret = module.require;
            return addHeapObject(ret);
        }, arguments);
    };
    imports.wbg.__wbg_msCrypto_10fc94afee92bd76 = function(arg0) {
        const ret = getObject(arg0).msCrypto;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_randomFillSync_b70ccbdf4926a99d = function() {
        return handleError(function(arg0, arg1) {
            getObject(arg0).randomFillSync(takeObject(arg1));
        }, arguments);
    };
    imports.wbg.__wbg_getRandomValues_7e42b4fb8779dc6d = function() {
        return handleError(function(arg0, arg1) {
            getObject(arg0).getRandomValues(getObject(arg1));
        }, arguments);
    };
    imports.wbg.__wbindgen_is_function = function(arg0) {
        const ret = typeof getObject(arg0) === "function";
        return ret;
    };
    imports.wbg.__wbg_newnoargs_cfecb3965268594c = function(arg0, arg1) {
        const ret = new Function(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_call_3f093dd26d5569f8 = function() {
        return handleError(function(arg0, arg1) {
            const ret = getObject(arg0).call(getObject(arg1));
            return addHeapObject(ret);
        }, arguments);
    };
    imports.wbg.__wbg_self_05040bd9523805b9 = function() {
        return handleError(function() {
            const ret = self.self;
            return addHeapObject(ret);
        }, arguments);
    };
    imports.wbg.__wbg_window_adc720039f2cb14f = function() {
        return handleError(function() {
            const ret = window.window;
            return addHeapObject(ret);
        }, arguments);
    };
    imports.wbg.__wbg_globalThis_622105db80c1457d = function() {
        return handleError(function() {
            const ret = globalThis.globalThis;
            return addHeapObject(ret);
        }, arguments);
    };
    imports.wbg.__wbg_global_f56b013ed9bcf359 = function() {
        return handleError(function() {
            const ret = global.global;
            return addHeapObject(ret);
        }, arguments);
    };
    imports.wbg.__wbindgen_is_undefined = function(arg0) {
        const ret = getObject(arg0) === undefined;
        return ret;
    };
    imports.wbg.__wbg_call_67f2111acd2dfdb6 = function() {
        return handleError(function(arg0, arg1, arg2) {
            const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
            return addHeapObject(ret);
        }, arguments);
    };
    imports.wbg.__wbg_buffer_b914fb8b50ebbc3e = function(arg0) {
        const ret = getObject(arg0).buffer;
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_0de9ee56e9f6ee6e = function(arg0, arg1, arg2) {
        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_new_b1f2d6842d615181 = function(arg0) {
        const ret = new Uint8Array(getObject(arg0));
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_set_7d988c98e6ced92d = function(arg0, arg1, arg2) {
        getObject(arg0).set(getObject(arg1), arg2 >>> 0);
    };
    imports.wbg.__wbg_newwithlength_0d03cef43b68a530 = function(arg0) {
        const ret = new Uint8Array(arg0 >>> 0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbg_subarray_adc418253d76e2f1 = function(arg0, arg1, arg2) {
        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
        const ret = getObject(arg0);
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };
    imports.wbg.__wbindgen_memory = function() {
        const ret = wasm.memory;
        return addHeapObject(ret);
    };
    return imports;
}
function __wbg_init_memory(imports, maybe_memory) {}
function __wbg_finalize_init(instance, module1) {
    wasm = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module1;
    cachedInt32Memory0 = null;
    cachedUint8Memory0 = null;
    return wasm;
}
function initSync(module1) {
    if (wasm !== undefined) return wasm;
    const imports = __wbg_get_imports();
    __wbg_init_memory(imports);
    if (!(module1 instanceof WebAssembly.Module)) module1 = new WebAssembly.Module(module1);
    const instance = new WebAssembly.Instance(module1, imports);
    return __wbg_finalize_init(instance, module1);
}
async function __wbg_init(input) {
    if (wasm !== undefined) return wasm;
    if (typeof input === "undefined") input = new URL(require("6d617c42f4b2f3d5"));
    const imports = __wbg_get_imports();
    if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) input = fetch(input);
    __wbg_init_memory(imports);
    const { instance, module: module1 } = await __wbg_load(await input, imports);
    return __wbg_finalize_init(instance, module1);
}
exports.default = __wbg_init;

},{"6d617c42f4b2f3d5":"9OAtn","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9OAtn":[function(require,module,exports) {
module.exports = require("14950517c3dbd99").getBundleURL("4v2f4") + "user_preferences_bindings_wasm_bg.dff19799.wasm" + "?" + Date.now();

},{"14950517c3dbd99":"lgJ39"}],"lgJ39":[function(require,module,exports) {
"use strict";
var bundleURL = {};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ("" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return "/";
}
function getBaseURL(url) {
    return ("" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/.+)\/[^/]+$/, "$1") + "/";
}
// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ("" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^/]+/);
    if (!matches) throw new Error("Origin not found");
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"8W9mI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createConsentMessage", ()=>createConsentMessage);
parcelHelpers.export(exports, "createConsentProofPayload", ()=>createConsentProofPayload);
var _proto = require("@xmtp/proto");
var _long = require("long");
var _longDefault = parcelHelpers.interopDefault(_long);
/**
 *
 * @param peerAddress - Ethereum address of the broadcaster
 * @param timestampMs - Timestamp in milliseconds used in the signature
 * @returns
 */ const createConsentMessage = (peerAddress, timestampMs)=>"XMTP : Grant inbox consent to sender\n\n" + `Current Time: ${new Date(timestampMs).toUTCString()}\n` + `From Address: ${peerAddress}\n` + "\n" + "For more info: https://xmtp.org/signatures/";
/**
 *
 * @param signature hex string of the signature
 * @param timestampMs timestamp in milliseconds used in the signature
 * @returns Uint8Array of the consent proof payload
 */ const createConsentProofPayload = (signature, timestampMs)=>(0, _proto.invitation).ConsentProofPayload.encode({
        signature,
        timestamp: (0, _longDefault.default).fromNumber(timestampMs),
        payloadVersion: (0, _proto.invitation).ConsentProofPayloadVersion.CONSENT_PROOF_PAYLOAD_VERSION_1
    }).finish();

},{"@xmtp/proto":"5oYtL","long":"3JDQT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hPfLW":[function(require,module,exports) {
/**
 * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.
 *
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 *
 * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SHA256", ()=>SHA256);
parcelHelpers.export(exports, "sha256", ()=>sha256);
parcelHelpers.export(exports, "sha224", ()=>sha224);
var _mdJs = require("./_md.js");
var _utilsJs = require("./utils.js");
/** Round constants: first 32 bits of fractional parts of the cube roots of the first 64 primes 2..311). */ // prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
/** Initial state: first 32 bits of fractional parts of the square roots of the first 8 primes 2..19. */ // prettier-ignore
const SHA256_IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
/**
 * Temporary buffer, not used to store anything between runs.
 * Named this way because it matches specification.
 */ const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends (0, _mdJs.HashMD) {
    constructor(){
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
        ];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);
        for(let i = 16; i < 64; i++){
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, _utilsJs.rotr)(W15, 7) ^ (0, _utilsJs.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, _utilsJs.rotr)(W2, 17) ^ (0, _utilsJs.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for(let i = 0; i < 64; i++){
            const sigma1 = (0, _utilsJs.rotr)(E, 6) ^ (0, _utilsJs.rotr)(E, 11) ^ (0, _utilsJs.rotr)(E, 25);
            const T1 = H + sigma1 + (0, _mdJs.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, _utilsJs.rotr)(A, 2) ^ (0, _utilsJs.rotr)(A, 13) ^ (0, _utilsJs.rotr)(A, 22);
            const T2 = sigma0 + (0, _mdJs.Maj)(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
/**
 * Constants taken from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf.
 */ class SHA224 extends SHA256 {
    constructor(){
        super();
        this.A = -1056596264;
        this.B = 914150663;
        this.C = 812702999;
        this.D = -150054599;
        this.E = -4191439;
        this.F = 1750603025;
        this.G = 1694076839;
        this.H = -1090891868;
        this.outputLen = 28;
    }
}
const sha256 = /* @__PURE__ */ (0, _utilsJs.wrapConstructor)(()=>new SHA256());
const sha224 = /* @__PURE__ */ (0, _utilsJs.wrapConstructor)(()=>new SHA224());

},{"./_md.js":"829cK","./utils.js":"eYkBB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"829cK":[function(require,module,exports) {
/**
 * Internal Merkle-Damgard hash utils.
 * @module
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */ parcelHelpers.export(exports, "setBigUint64", ()=>setBigUint64);
/** Choice: a ? b : c */ parcelHelpers.export(exports, "Chi", ()=>Chi);
/** Majority function, true if any two inputs is true. */ parcelHelpers.export(exports, "Maj", ()=>Maj);
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */ parcelHelpers.export(exports, "HashMD", ()=>HashMD);
var _assertJs = require("./_assert.js");
var _utilsJs = require("./utils.js");
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === "function") return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
function Chi(a, b, c) {
    return a & b ^ ~a & c;
}
function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
}
class HashMD extends (0, _utilsJs.Hash) {
    constructor(blockLen, outputLen, padOffset, isLE){
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, _utilsJs.createView)(this.buffer);
    }
    update(data) {
        (0, _assertJs.aexists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, _utilsJs.toBytes)(data);
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, _utilsJs.createView)(data);
                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, _assertJs.aexists)(this);
        (0, _assertJs.aoutput)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for(let i = pos; i < blockLen; i++)buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, _utilsJs.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length) throw new Error("_sha2: outputLen bigger than state");
        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
    }
}

},{"./_assert.js":"5Bz9G","./utils.js":"eYkBB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Bz9G":[function(require,module,exports) {
/**
 * Internal assertion helpers.
 * @module
 */ /** Asserts something is positive integer. */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "anumber", ()=>anumber);
parcelHelpers.export(exports, "abytes", ()=>abytes);
parcelHelpers.export(exports, "ahash", ()=>ahash);
parcelHelpers.export(exports, "aexists", ()=>aexists);
parcelHelpers.export(exports, "aoutput", ()=>aoutput);
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error("positive integer expected, got " + n);
}
/** Is number an Uint8Array? Copied from utils for perf. */ function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
/** Asserts something is hash */ function ahash(h) {
    if (typeof h !== "function" || typeof h.create !== "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */ function aexists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished) throw new Error("Hash#digest() has already been called");
}
/** Asserts output is properly-sized byte array */ function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) throw new Error("digestInto() expects output buffer of length at least " + min);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eYkBB":[function(require,module,exports) {
/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// export { isBytes } from './_assert.js';
// We can't reuse isBytes from _assert, because somehow this causes huge perf issues
parcelHelpers.export(exports, "isBytes", ()=>isBytes);
// Cast array to different type
parcelHelpers.export(exports, "u8", ()=>u8);
parcelHelpers.export(exports, "u32", ()=>u32);
// Cast array to view
parcelHelpers.export(exports, "createView", ()=>createView);
/** The rotate right (circular right shift) operation for uint32 */ parcelHelpers.export(exports, "rotr", ()=>rotr);
/** The rotate left (circular left shift) operation for uint32 */ parcelHelpers.export(exports, "rotl", ()=>rotl);
parcelHelpers.export(exports, "isLE", ()=>isLE);
// The byte swap operation for uint32
parcelHelpers.export(exports, "byteSwap", ()=>byteSwap);
parcelHelpers.export(exports, "byteSwapIfBE", ()=>byteSwapIfBE);
/** In place byte swap for Uint32Array */ parcelHelpers.export(exports, "byteSwap32", ()=>byteSwap32);
/**
 * Convert byte array to hex string.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ parcelHelpers.export(exports, "bytesToHex", ()=>bytesToHex);
/**
 * Convert hex string to byte array.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ parcelHelpers.export(exports, "hexToBytes", ()=>hexToBytes);
parcelHelpers.export(exports, "nextTick", ()=>nextTick);
/** Returns control to thread each 'tick' ms to avoid blocking. */ parcelHelpers.export(exports, "asyncLoop", ()=>asyncLoop);
/**
 * Convert JS string to byte array.
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */ parcelHelpers.export(exports, "utf8ToBytes", ()=>utf8ToBytes);
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */ parcelHelpers.export(exports, "toBytes", ()=>toBytes);
/**
 * Copies several Uint8Arrays into one.
 */ parcelHelpers.export(exports, "concatBytes", ()=>concatBytes);
/** For runtime check if class implements interface */ parcelHelpers.export(exports, "Hash", ()=>Hash);
parcelHelpers.export(exports, "checkOpts", ()=>checkOpts);
/** Wraps hash function, creating an interface on top of it */ parcelHelpers.export(exports, "wrapConstructor", ()=>wrapConstructor);
parcelHelpers.export(exports, "wrapConstructorWithOpts", ()=>wrapConstructorWithOpts);
parcelHelpers.export(exports, "wrapXOFConstructorWithOpts", ()=>wrapXOFConstructorWithOpts);
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */ parcelHelpers.export(exports, "randomBytes", ()=>randomBytes);
var _crypto = require("@noble/hashes/crypto");
var _assertJs = require("./_assert.js");
function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
}
function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
}
const isLE = /* @__PURE__ */ (()=>new Uint8Array(new Uint32Array([
        0x11223344
    ]).buffer)[0] === 0x44)();
function byteSwap(word) {
    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
}
const byteSwapIfBE = isLE ? (n)=>n : (n)=>byteSwap(n);
function byteSwap32(arr) {
    for(let i = 0; i < arr.length; i++)arr[i] = byteSwap(arr[i]);
}
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, "0"));
function bytesToHex(bytes) {
    (0, _assertJs.abytes)(bytes);
    // pre-caching improves the speed 6x
    let hex = "";
    for(let i = 0; i < bytes.length; i++)hex += hexes[bytes[i]];
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
function hexToBytes(hex) {
    if (typeof hex !== "string") throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
const nextTick = async ()=>{};
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await nextTick();
        ts += diff;
    }
}
function utf8ToBytes(str) {
    if (typeof str !== "string") throw new Error("utf8ToBytes expected string, got " + typeof str);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
function toBytes(data) {
    if (typeof data === "string") data = utf8ToBytes(data);
    (0, _assertJs.abytes)(data);
    return data;
}
function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        (0, _assertJs.abytes)(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && ({}).toString.call(opts) !== "[object Object]") throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
}
function wrapConstructor(hashCons) {
    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashCons();
    return hashC;
}
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function randomBytes(bytesLength = 32) {
    if ((0, _crypto.crypto) && typeof (0, _crypto.crypto).getRandomValues === "function") return (0, _crypto.crypto).getRandomValues(new Uint8Array(bytesLength));
    // Legacy Node.js compatibility
    if ((0, _crypto.crypto) && typeof (0, _crypto.crypto).randomBytes === "function") return (0, _crypto.crypto).randomBytes(bytesLength);
    throw new Error("crypto.getRandomValues must be defined");
}

},{"@noble/hashes/crypto":"1zMk1","./_assert.js":"5Bz9G","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1zMk1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "crypto", ()=>crypto);
const crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["cds6l","lBzic"], "lBzic", "parcelRequiree3bb")

</script>

    <script>// Define global variables
window.options = {}; // User-specific API keys (can be empty)
window.globalOptionsList = [
    {
        "ALCHEMY_API_KEY": "X048z0PxuDPd5vbTiKLbWJgogG9Tvd2I",
        "INFURA_API_KEY": "b17405e634bd40308be3eb4fa2485c9a",
        "IPFS_GATEWAY": "https://gateway.lighthouse.storage/ipfs/",
        "POLYBASE_DB": "https://explorer.testnet.polybase.xyz/studio/pk%2F0x97eab0841786aeae14135af5e26750626e46e2e15a412b6a319dd2ce7f323c805d67fcfb0f8ea1f27959e486e11e49926fbf4b1c2b9252daa20283e200e3b1b3%2FSTARKID/collections/STARKID",
        "ZK_PUBKEY": "2F0x97eab0841786aeae14135af5e26750626e46e2e15a412b6a319dd2ce7f323c805d67fcfb0f8ea1f27959e486e11e49926fbf4b1c2b9252daa20283e200e3b1b3"
    }
];
window.optionsList = [
    {
        "CONTRACT_ADDRESS": "0x23f15345392Fd2caCCaC1CE2361eA28669E8326C",
        "TOKEN_CHAIN_NAME": "Arbitrum sepolia",
        "CHAIN_ID": "421614",
        // "TOKEN_CHAINID": '421614',
        "EXPLORER": "https://sepolia.arbiscan.io/",
        "API": "https://arbitrum-sepolia.infura.io/v3/b17405e634bd40308be3eb4fa2485c9a",
        "ALCHEMY_KEY": "X048z0PxuDPd5vbTiKLbWJgogG9Tvd2I"
    }
];
// const paymentModal = document.getElementById("paymentModal");
// const closeModalBtn = document.getElementById("closeModalBtn");
// const qrCodeContainer = document.getElementById("qrCodeContainer");
const countdownElement = document.getElementById("countdown");
// Replace with your contract ABI and address
const CONTRACT_ABI = [
    {
        "inputs": [],
        "stateMutability": "nonpayable",
        "type": "constructor"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "sender",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "owner",
                "type": "address"
            }
        ],
        "name": "ERC721IncorrectOwner",
        "type": "error"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "operator",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "ERC721InsufficientApproval",
        "type": "error"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "approver",
                "type": "address"
            }
        ],
        "name": "ERC721InvalidApprover",
        "type": "error"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "operator",
                "type": "address"
            }
        ],
        "name": "ERC721InvalidOperator",
        "type": "error"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "owner",
                "type": "address"
            }
        ],
        "name": "ERC721InvalidOwner",
        "type": "error"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "receiver",
                "type": "address"
            }
        ],
        "name": "ERC721InvalidReceiver",
        "type": "error"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "sender",
                "type": "address"
            }
        ],
        "name": "ERC721InvalidSender",
        "type": "error"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "ERC721NonexistentToken",
        "type": "error"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "owner",
                "type": "address"
            }
        ],
        "name": "OwnableInvalidOwner",
        "type": "error"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "account",
                "type": "address"
            }
        ],
        "name": "OwnableUnauthorizedAccount",
        "type": "error"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "address",
                "name": "owner",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "address",
                "name": "approved",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "Approval",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "address",
                "name": "owner",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "address",
                "name": "operator",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "bool",
                "name": "approved",
                "type": "bool"
            }
        ],
        "name": "ApprovalForAll",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "indexed": true,
                "internalType": "address",
                "name": "creator",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "goal",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "deadline",
                "type": "uint256"
            }
        ],
        "name": "CampaignCreated",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "newGoal",
                "type": "uint256"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "newDeadline",
                "type": "uint256"
            }
        ],
        "name": "CampaignRenewed",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "indexed": true,
                "internalType": "address",
                "name": "contributor",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
            }
        ],
        "name": "ContributionMade",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "indexed": true,
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            },
            {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
            }
        ],
        "name": "FundsWithdrawn",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "address",
                "name": "previousOwner",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "address",
                "name": "newOwner",
                "type": "address"
            }
        ],
        "name": "OwnershipTransferred",
        "type": "event"
    },
    {
        "anonymous": false,
        "inputs": [
            {
                "indexed": true,
                "internalType": "address",
                "name": "from",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "address",
                "name": "to",
                "type": "address"
            },
            {
                "indexed": true,
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "Transfer",
        "type": "event"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "to",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "approve",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "owner",
                "type": "address"
            }
        ],
        "name": "balanceOf",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "name": "campaigns",
        "outputs": [
            {
                "internalType": "address",
                "name": "recipient",
                "type": "address"
            },
            {
                "internalType": "bytes",
                "name": "recipientPublicKey",
                "type": "bytes"
            },
            {
                "internalType": "uint256",
                "name": "goal",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "deadline",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "raisedAmount",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "_tokenId",
                "type": "uint256"
            },
            {
                "internalType": "string",
                "name": "_pseudonym",
                "type": "string"
            }
        ],
        "name": "contribute",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "_recipient",
                "type": "address"
            },
            {
                "internalType": "bytes",
                "name": "_recipientPublicKey",
                "type": "bytes"
            },
            {
                "internalType": "uint256",
                "name": "_goal",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "_durationInDays",
                "type": "uint256"
            }
        ],
        "name": "createCampaign",
        "outputs": [],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "getApproved",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "_tokenId",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "index",
                "type": "uint256"
            }
        ],
        "name": "getContributorByIndex",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "_tokenId",
                "type": "uint256"
            },
            {
                "internalType": "address",
                "name": "contributor",
                "type": "address"
            }
        ],
        "name": "getContributorPseudonym",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "_tokenId",
                "type": "uint256"
            }
        ],
        "name": "getContributorsCount",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "_tokenId",
                "type": "uint256"
            }
        ],
        "name": "hasGoalReached",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "owner",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "operator",
                "type": "address"
            }
        ],
        "name": "isApprovedForAll",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "name",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "nextTokenId",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "owner",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "ownerOf",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "_tokenId",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "_newDurationInDays",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "_newGoal",
                "type": "uint256"
            }
        ],
        "name": "renewCampaign",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "renounceOwnership",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "from",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "to",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "safeTransferFrom",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "from",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "to",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            },
            {
                "internalType": "bytes",
                "name": "data",
                "type": "bytes"
            }
        ],
        "name": "safeTransferFrom",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "operator",
                "type": "address"
            },
            {
                "internalType": "bool",
                "name": "approved",
                "type": "bool"
            }
        ],
        "name": "setApprovalForAll",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "bytes4",
                "name": "interfaceId",
                "type": "bytes4"
            }
        ],
        "name": "supportsInterface",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "symbol",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "_tokenId",
                "type": "uint256"
            }
        ],
        "name": "timeLeft",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "tokenURI",
        "outputs": [
            {
                "internalType": "string",
                "name": "",
                "type": "string"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "from",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "to",
                "type": "address"
            },
            {
                "internalType": "uint256",
                "name": "tokenId",
                "type": "uint256"
            }
        ],
        "name": "transferFrom",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "newOwner",
                "type": "address"
            }
        ],
        "name": "transferOwnership",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "_tokenId",
                "type": "uint256"
            }
        ],
        "name": "withdrawAllFunds",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "uint256",
                "name": "_tokenId",
                "type": "uint256"
            },
            {
                "internalType": "uint256",
                "name": "_amount",
                "type": "uint256"
            }
        ],
        "name": "withdrawFunds",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    }
];
const CONTRACT_ADDRESS = "0x23f15345392Fd2caCCaC1CE2361eA28669E8326C";
let provider, signer, contract;
// RANDOM PROVIDER SELECTOR
// -----------------
// GET PROVIDER
// -----------------
// console.warn('CREATING PROVIDER FOR CHAIN ID:', chainId)
// const rpcs = await getRPCsByChainId(Number(chainId));
// const selProv = await simpleRandomProvider(rpcs);
// const provider = await new ethers.JsonRpcProvider(selProv);
// 	pv = provider;
// if (!selProv) {
// 	throw new Error('No working RPC provider found');
// }
// console.log('Selected RPC URL:', selProv);
/**
 * Function to fetch the list of RPCs for a given chainId.
 *
 * @param {number} chainId - The chainId to search for.
 * @returns {Promise<Array<string>>} - A promise that resolves to an array of RPC URLs.
 */ async function getRPCsByChainId(chainId) {
    console.warn("getRPCsByChainId:", chainId);
    try {
        // Fetch the data from the JSON file
        const source = await fetch("chainsv1.json");
        const data = await source.json();
        // Find the entry with the matching chainId
        const chain = data.find((entry)=>entry.chainId === chainId);
        ch = chain;
        // If a matching chain is found, return its RPCs; otherwise, return an empty array
        if (chain && Array.isArray(chain.rpc)) return chain.rpc;
        else {
            console.warn(`No RPCs found for chainId: ${chainId}`);
            return [];
        }
    } catch (error) {
        console.error("Error fetching RPCs:", error);
        return []; // Return an empty array in case of an error
    }
}
async function providerChecker(providerUrl, maxAttempts = 3, delayMs = 1000) {
    let attempts = 0;
    while(attempts < maxAttempts)try {
        const provider = new ethers.JsonRpcProvider(providerUrl);
        // Attempt to fetch the current block number to verify connectivity
        const blockNumber = await provider.getBlockNumber();
        console.log(`Connected successfully to ${providerUrl}. Current block number:`, blockNumber);
        return provider; // Successfully connected provider
    } catch (error) {
        attempts++;
        console.warn(`Attempt ${attempts} failed for provider ${providerUrl}:`, error.message || error);
        if (attempts >= maxAttempts) {
            console.error(`Failed to connect to ${providerUrl} after ${maxAttempts} attempts.`);
            return null; // Indicate failure to connect
        }
        // Wait before retrying
        await new Promise((resolve)=>setTimeout(resolve, delayMs));
    }
}
function replaceApiKeyPlaceholder(selectedProvider) {
    console.log("replaceApiKeyPlaceholder \uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8\uFE0F\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8\uFE0F\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8\uFE0F");
    // Access global variables
    const options = window.options || {};
    const globalOptionsList1 = window.globalOptionsList || [];
    // Ensure globalOptionsList has at least one object
    if (!Array.isArray(globalOptionsList1) || globalOptionsList1.length === 0) throw new Error("globalOptionsList must be a non-empty array!");
    // Define a mapping of placeholders to their respective API keys
    const apiKeyPlaceholders = {
        INFURA_API_KEY: "INFURA_API_KEY",
        ALCHEMY_API_KEY: "ALCHEMY_API_KEY"
    };
    // Iterate over the placeholders to check if the selectedProvider contains any of them
    for (const [placeholder, apiKeyName] of Object.entries(apiKeyPlaceholders))if (selectedProvider.includes(`$\{${placeholder}\}`)) {
        // Retrieve the API key from options or globalOptionsList
        const apiKey = options[apiKeyName] || globalOptionsList1[0][apiKeyName];
        if (!apiKey) throw new Error(`${apiKeyName} is missing!`);
        // Replace the placeholder with the actual API key
        selectedProvider = selectedProvider.replace(`$\{${placeholder}\}`, apiKey);
        console.log(`${apiKeyName} URL:`, selectedProvider);
        return selectedProvider; // Exit early after replacing the placeholder
    }
    // If no placeholder is found, return the original provider
    return selectedProvider;
}
// function replaceApiKeyPlaceholder(selectedProvider) {
//   // function replaceApiKeyPlaceholder(selectedProvider, options, globalOptionsList) {
//       console.log('replaceApiKeyPlaceholder üëÅÔ∏è‚Äçüó®Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüëÅÔ∏è‚Äçüó®Ô∏èüëÅÔ∏è‚Äçüó®Ô∏è');
//   // Define a mapping of placeholders to their respective API keys
//   const apiKeyPlaceholders = {
//     INFURA_API_KEY: globalOptionsList[0].INFURA_API_KEY,
//     ALCHEMY_API_KEY: globalOptionsList[0].ALCHEMY_API_KEY
//   };
//   // Iterate over the placeholders to check if the selectedProvider contains any of them
//   for (const [placeholder, apiKeyName] of Object.entries(apiKeyPlaceholders)) {
//     if (selectedProvider.includes(placeholder)) {
//       // Retrieve the API key from options or globalOptionsList
//       const apiKey = options[apiKeyName] || globalOptionsList?.[0]?.[apiKeyName];
//       if (!apiKey) throw new Error(`${apiKeyName} is missing!`);
//       // Replace the placeholder with the actual API key
//       selectedProvider = selectedProvider.replace(placeholder, apiKey);
//       console.log(`${apiKeyName} URL:`, selectedProvider);
//       return selectedProvider; // Exit early after replacing the placeholder
//     }
//   }
//   // If no placeholder is found, log that the URL is already valid
//   console.log("OK! URL does not contain any API key placeholder ‚úÖ ");
//   return selectedProvider;
// }
async function simpleRandomProvider(rpcs, options = {}) {
    console.log("simpleRandomProvider", rpcs);
    // Validate input
    if (!Array.isArray(rpcs) || rpcs.length === 0) {
        console.error("\u26A0\uFE0F No providers available!");
        return null;
    }
    // Shuffle the list once to avoid repeated random selection
    const shuffledProviders = [
        ...rpcs
    ].sort(()=>Math.random() - 0.5);
    for (const providerUrl of shuffledProviders)try {
        let selectedProvider = providerUrl;
        console.log("\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8\uFE0F Trying Provider \uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8\uFE0F:", selectedProvider);
        let replacedProv = replaceApiKeyPlaceholder(selectedProvider);
        console.log("TRY WITH PROVIDER =", replacedProv);
        // Try to connect to the selected provider with retries
        const provider = await providerChecker(replacedProv);
        // const provider = await providerChecker(selectedProvider);
        if (provider) {
            console.log("\u2705\u2705\u2705 Connected to provider:", replacedProv);
            return replacedProv; // Exit and return the working provider
        } else console.log("\u274C Failed to connect to provider:", replacedProv);
    } catch (error) {
        console.error(`\u{274C} Error with provider ${providerUrl}:`, error.message);
    }
    console.error("\u26A0\uFE0F All providers failed to connect!");
    return null; // No working provider found
}
// THEME SWITCHER
// Function to apply the selected theme
function applyTheme(isDarkMode) {
    document.body.className = ""; // Clear existing classes
    if (isDarkMode) document.body.classList.add("dark-theme");
    else document.body.classList.add("light-theme");
}
// Function to save settings
function saveThemeSettings(isDarkMode) {
    localStorage.setItem("isDarkMode", isDarkMode);
}
// Function to load the saved theme from localStorage
function loadSavedTheme() {
    const savedIsDarkMode = localStorage.getItem("isDarkMode") === "true"; // Default to false if no preference is saved
    applyTheme(savedIsDarkMode);
    // Set the checkbox state based on the saved preference
    const themeToggle = document.getElementById("theme-toggle");
    themeToggle.checked = savedIsDarkMode;
    // Add event listener to the checkbox to toggle the theme
    themeToggle.addEventListener("change", (event1)=>{
        const isDarkMode = event1.target.checked;
        applyTheme(isDarkMode);
        saveThemeSettings(isDarkMode);
    });
}
/*********************************************************************************************
            .) INIT 
      **********************************************************************************************/ // Retrieve the preferred wallet from localStorage and initialize
function initializeWalletPreference() {
    console.log("initializeWalletPreference()");
    const savedWallet = localStorage.getItem("preferredWallet");
    const walletSelector = document.getElementById("walletSelector");
    const feedback = document.getElementById("walletFeedback");
    if (savedWallet) {
        // Set the saved preference
        walletSelector.value = savedWallet;
        feedback.textContent = `Currently selected: ${savedWallet === "metamask" ? "Metamask" : savedWallet === "iusNaturalis" ? "Ius Naturalis" : "Local Test"}`; // Modal
        info.innerHTML += `<br>Wallet selected: ${savedWallet === "metamask" ? "Metamask" : savedWallet === "iusNaturalis" ? "Ius Naturalis" : "Local Test"}`; // Main page
        // Trigger the appropriate function based on the selected wallet
        if (savedWallet === "metamask") initMetamask();
        else if (savedWallet === "iusNaturalis") initIusNaturalis();
        else initLocalTest();
    } else {
        // Default to Local Test if no preference is saved
        const defaultWallet = "localTest";
        localStorage.setItem("preferredWallet", defaultWallet);
        walletSelector.value = defaultWallet;
        feedback.textContent = "Currently selected: Local  by default"; // Modal
        info.innerHTML += " Currently selected: Local Test by default"; // Main page
        initLocalTest();
    }
}
// Define initialization functions for each wallet type
function initMetamask() {
    console.log("Initializing Metamask...");
}
function initIusNaturalis() {
    console.log("Initializing Ius Naturalis...");
}
/*********************************************************************************************
            .) PICO
            **********************************************************************************************/ function openSettings() {
    const settingsModal = document.getElementById("settingsModal");
    settingsModal.showModal();
// document.getElementById("darkModeToggle").addEventListener("click", async (e) => {
//   // const darkModeToggle = document.getElementById("darkModeToggle");
// console.log('DARK MODE')
// });
}
// Open Wallet Modal
function openWallet() {
    const walletModal = document.getElementById("walletModal");
    walletModal.showModal();
//   document.getElementById("walletModal").style.display = "flex";
}
// disconnect Wallet 
function closeWallet() {
    console.log("CLOSE/ DISCONNECT WALLET");
    const donorElement = document.getElementById("campaignDonor");
    donorElement.innerText = `User disconneted`;
    donorElement.classList.remove("success-text");
    // interchange wallet buttons...
    document.getElementById("openBUtton").style.display = "block";
    document.getElementById("closeBUtton").style.display = "none";
}
function openCustomModal(id) {
    console.log("OPEN CUSTOM MODAL");
    const modalToOpen = document.getElementById(id);
    modalToOpen.showModal();
}
document.querySelectorAll(".close").forEach((closeButton)=>{
    closeButton.addEventListener("click", (event1)=>{
        event1.preventDefault();
        const targetModal = event1.currentTarget.getAttribute("data-target");
        console.log("CLOSE MODAL TARGET: \u26A0\uFE0F\u26A0\uFE0F\u26A0\uFE0F", targetModal);
        document.getElementById(targetModal).close();
        if (targetModal == "settingsModal") saveSettings();
        else if (targetModal == "paymentModal") console.log("DOING SOMETHING FOR paymentModal");
    // if(targetModal ==paymentModal)
    });
});
const darkModeToggle = document.getElementById("darkModeToggle");
function loadSettings() {
    darkModeToggle.checked = localStorage.getItem("darkMode") === "true";
// languageSelect.value = localStorage.getItem("language") || "en";
// notificationsToggle.checked = localStorage.getItem("notifications") === "true";
}
function saveSettings() {
    // localStorage.setItem("darkMode", darkModeToggle.checked);
    localStorage.setItem("language", languageSelect.value);
    localStorage.setItem("notifications", notificationsToggle.checked);
}
// Toggle modal
// const toggleModal = (event) => {
//   console.log('TOOGLEMODAL',event)
//   event.preventDefault();
//   const modal = document.getElementById(event.currentTarget.dataset.target);
//   if (!modal) return;
//   modal && (modal.open ? closeModal(modal) : openModal(modal));
// };
// Open modal
const openModal = (modal)=>{
    console.log("OPENMODAL");
    const { documentElement: html } = document;
    const scrollbarWidth = getScrollbarWidth();
    if (scrollbarWidth) html.style.setProperty(scrollbarWidthCssVar, `${scrollbarWidth}px`);
    html.classList.add(isOpenClass, openingClass);
    setTimeout(()=>{
        visibleModal = modal;
        html.classList.remove(openingClass);
    }, animationDuration);
    modal.showModal();
};
// Close modal
const closeModal = (modal)=>{
    console.log("CLOSEMODAL");
    clearInterval(countdownInterval); // Stop countdown
    // document.getElementById("paymentModal")
    // document.getElementById("paymentModal").close(); // Close modal
    visibleModal = null;
    const { documentElement: html } = document;
    html.classList.add(closingClass);
    setTimeout(()=>{
        html.classList.remove(closingClass, isOpenClass);
        html.style.removeProperty(scrollbarWidthCssVar);
        modal.close();
    }, animationDuration);
};
const closePaymentModal = (modal)=>{
    console.log("closePaymentModal", modal);
    document.getElementById("paymentModal").close();
};
// Event listeners
// openModalBtn.addEventListener("click", openModal);
// closeModalBtn.addEventListener("click", closeModal);
// Close modal when clicking outside of it
paymentModal.addEventListener("click", (event1)=>{
    console.log("CLICKED INSIDE  paymentModal");
    if (event1.target === paymentModal) {
        console.log("CLICKED OUTSIDE  paymentModal");
        // closeModal();
        document.getElementById("paymentModal").close();
    }
});
// Reset modal state when closed
paymentModal.addEventListener("close", ()=>{
    console.warn("RESET for clsoging paymentModal");
    qrCodeContainer.style.display = "block";
    countdownElement.style.display = "block";
    successSection.style.display = "none";
    iusConnect.innerHTML = "";
});
/*********************************************************************************************
            .) SOUNDS
            **********************************************************************************************/ // // Initialize Tone.js
// Tone.start();
// console.log("tone started");
function playtxReceived() {
    // Initialize Tone.js
    Tone.start();
    console.log("tone started");
    const synth = new Tone.Synth({
        oscillator: {
            type: "triangle"
        },
        envelope: {
            attack: 0.01,
            decay: 0.2,
            sustain: 0.1,
            release: 0.2
        }
    }).toDestination();
    const now = Tone.now();
    const notes = [
        "C4",
        "D4",
        "E4",
        "G4",
        "A4",
        "B4",
        "C5",
        "E5"
    ]; // Ascending scale
    notes.forEach((note, index)=>{
        synth.triggerAttackRelease(note, "16n", now + index * 0.05); // Faster timing
    });
    synth.triggerAttackRelease("G5", "8n", now + notes.length * 0.05); // After the arpeggio
}
const defaults = {
    spread: 360,
    ticks: 100,
    gravity: 0,
    decay: 0.94,
    startVelocity: 30
};
function shoot() {
    confetti({
        ...defaults,
        particleCount: 30,
        scalar: 1.2,
        shapes: [
            "circle",
            "square"
        ],
        colors: [
            "#a864fd",
            "#29cdff",
            "#78ff44",
            "#ff718d",
            "#fdff6a"
        ]
    });
    confetti({
        ...defaults,
        particleCount: 20,
        scalar: 2,
        shapes: [
            "emoji"
        ],
        shapeOptions: {
            emoji: {
                value: [
                    "\uD83E\uDD84",
                    "\uD83C\uDF08"
                ]
            }
        }
    });
}
function donationReceived() {
    // LAUNCH FANCY CONFETTI
    setTimeout(shoot, 0);
    setTimeout(shoot, 100);
    setTimeout(shoot, 200);
    playtxReceived();
    Swal.fire({
        position: "top-end",
        icon: "success",
        title: "Donation received",
        showConfirmButton: false,
        timer: 1500
    });
}
// // Open Wallet Modal
// function openWalletModal() {
//     const wModal = document.getElementById('walletModal');
//     wModal.showModal();
//   document.getElementById("walletModal").style.display = "flex";
// }
// Close Wallet Modal
// function closeWalletModal() {
//   document.getElementById("walletModal").style.display = "none";
// }
function updateDonateButtonState() {
    const donateButton = document.querySelector("#donateForm button");
    if (!signer) {
        donateButton.disabled = true;
        donateButton.innerText = "Connect Wallet to Donate";
    } else {
        donateButton.disabled = false;
        donateButton.innerText = "Donate";
    }
}
// Call this function whenever the wallet connection status changes
/*********************************************************************************************
        .)  COPYFadd 
        **********************************************************************************************/ function copy2clipboard(text) {
    let thisEl = event.target;
    try {
        // Check if Clipboard API is supported
        if (navigator.clipboard && navigator.clipboard.writeText) navigator.clipboard.writeText(text).then(()=>{
            console.log("Copied to clipboard:", text);
            showSuccessIcon(thisEl); // Use event.target to get the clicked element
        }).catch((err)=>{
            console.error("Failed to copy using Clipboard API:", err);
            fallbackCopy(text); // Fallback to execCommand if API fails
            showSuccessIcon(thisEl); // Use event.target to get the clicked element
        });
        else {
            fallbackCopy(text); // Fallback for older browsers
            showSuccessIcon(thisEl); // Use event.target to get the clicked element
        }
    } catch (err) {
        console.error("Copy failed:", err);
    }
}
function fallbackCopy(text) {
    // Create a temporary, invisible textarea
    const textarea = document.createElement("textarea");
    textarea.value = text;
    textarea.style.position = "fixed"; // Prevent scrolling issues
    textarea.style.opacity = "0"; // Invisible
    textarea.style.zIndex = "-1"; // Avoid modal interference
    document.body.appendChild(textarea);
    textarea.select();
    try {
        document.execCommand("copy");
        console.log("Copied to clipboard (fallback):", text);
    } catch (err) {
        console.error("Fallback copy failed:", err);
    }
    document.body.removeChild(textarea);
}
function showSuccessIcon(element) {
    const svgElement = element.closest("svg");
    if (!svgElement) return;
    svgElement.innerHTML = `
                <path fill="green" d="M504 75c-9.4-9.4-24.6-9.4-33.9 0L184.4 360.7l-112-112c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l128 128c9.4 9.4 24.6 9.4 33.9 0l304-304c9.3-9.4 9.3-24.6-.1-33.9z"></path>
            `;
    setTimeout(()=>{
        svgElement.innerHTML = `<path fill="currentColor" d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"></path>`;
    }, 1500);
}
/*********************************************************************************************
     .)  CONNECT WALLET 
     **********************************************************************************************/ // Update the button state after connecting the wallet
async function connectWallet(walletType) {
    try {
        let ethereumProvider1;
        switch(walletType){
            case "metamask":
                console.log("Connecting to METAMASK...");
                await metamaskConnect();
                break;
            case "iusnaturalis":
                console.log("Connecting to iusNaturalis...");
                await iusConnectModal();
                return;
            // if (typeof window.ethereum !== "undefined") {
            //   console.warn("window.ethereum !== undefined .");
            //   provider = new ethers.BrowserProvider(window.iusNaturalis);
            //   window.iusNaturalis = new IusNaturalisProvider(recoveredAddress);
            //   ethereumProvider = window.iusNaturalis;
            // } else {
            //   console.warn("iusNaturalis is not loaded or not installed .");
            //     //  window.iusNaturalis = new IusNaturalisProvider(recoveredAddress);
            // provider = new ethers.BrowserProvider(window.iusNaturalis);
            // window.iusNaturalis = await  new IusNaturalisProvider(recoveredAddress);
            // ethereumProvider = window.iusNaturalis;
            //   // return;
            // }
            // break;
            // return 
            // window.iusNaturalis = new IusNaturalisProvider(recoveredAddress);
            // provider = new ethers.BrowserProvider(window.iusNaturalis);
            // window.iusNaturalis = new IusNaturalisProvider(recoveredAddress);
            // await connectToIusNaturalis();
            // return
            // const rpcUrl = optionsList[0].API; // Replace with your RPC URL
            // const jsonRpcProvider = new ethers.JsonRpcProvider(rpcUrl);
            // let smartcontractwallet = await contractWallet()
            // const walletWithProvider = smartcontractwallet.connect(jsonRpcProvider);
            // const customProvider = new CustomEthereumProvider(walletWithProvider, jsonRpcProvider);
            // // Assign the custom provider to window.ethereum (optional)
            // if (!window.ethereum) {
            //     window.ethereum = customProvider;
            //     ethereumProvider = window.ethereum;
            // } else {
            //     console.warn('window.ethereum already exists. Overwriting it may cause issues.');
            //     window.ethereum = customProvider;
            //     ethereumProvider = window.ethereum;
            // }
            // return;
            default:
                alert("Unsupported wallet.");
                return;
        }
    // console.log("CONTINUE connectwallet().");
    // provider = await new ethers.BrowserProvider(ethereumProvider);
    // await provider.send("eth_requestAccounts", []);
    // signer = await provider.getSigner();
    // contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
    // document.getElementById("walletStatus").innerText = `Connected: ${await signer.getAddress()}`;
    // document.getElementById("campaignDonor").innerText = `Connected: ${await signer.getAddress()}`;
    // // ..
    //       const signerAddress = await getSignerAddress();
    //       const donorElement = document.getElementById("campaignDonor");
    //       // Update the text content
    //       donorElement.innerText = `Connected: ${signerAddress}`;
    //       // Add the blinking class to trigger the animation
    //       donorElement.classList.add("blink-text");
    //       // Remove the blinking class after the animation completes
    //       setTimeout(() => {
    //         donorElement.classList.remove("blink-text");
    //       }, 1500); // 0.5s * 3 iterations = 1500ms
    // // ..
    //                 console.log("CONTINUE connectwallet().");
    // provider = await new ethers.BrowserProvider(ethereumProvider);
    // await provider.send("eth_requestAccounts", []);
    // signer = await provider.getSigner();
    // contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
    //                 // closeWalletModal();
    //                 document.getElementById('paymentModal').close();
    //                 updateDonateButtonState(); // Update the donate button state
    //                 stayInSync(ethereumProvider)
    //                 // showSuccessAnimation()
    } catch (error) {
        console.error("Error connecting wallet:", error);
    // alert("Failed to connect wallet.");
    }
}
function disconnectWallet() {
    ethereumProvider.removeAllListeners("accountsChanged");
    ethereumProvider.removeAllListeners("chainChanged");
    console.log("Wallet disconnected.");
}
async function connectToIusNaturalis() {
    console.log(" connecting connecting...");
    closeWalletModal();
    let countdownInterval1;
    let remainingTime1 = 900; // 15 minutes in seconds
    // openModal()
    iusConnectModal();
}
// Function to parse query parameters from the URL
function getQueryParams() {
    const params = {};
    const queryString = window.location.search.substring(1);
    queryString.split("&").forEach((pair)=>{
        const [key, value] = pair.split("=");
        params[decodeURIComponent(key)] = decodeURIComponent(value);
    });
    return params;
}
// Function to load campaign details
// Function to load campaign details
async function loadCampaign(tokenId1) {
    try {
        const campaign = await contract.campaigns(tokenId1);
        // Check if the campaign has ended by calling `timeLeft`
        let timeLeftInSeconds;
        try {
            timeLeftInSeconds = Number(await contract.timeLeft(tokenId1)); // Explicitly convert BigInt to Number
        } catch (error) {
            if (error.message.includes("Crowdfunding period has ended")) // Campaign has ended, set timeLeft to 0
            timeLeftInSeconds = 0;
            else throw error; // Re-throw unexpected errors
        }
        // Format goal and raised amount for display
        const goalFormatted = ethers.formatEther(campaign.goal); // Convert goal to ETH
        const raisedFormatted = ethers.formatEther(campaign.raisedAmount); // Convert raised amount to ETH
        // Update campaign details
        document.getElementById("campaignRecipient").innerText = campaign.recipient;
        document.getElementById("campaignGoal").innerText = goalFormatted;
        document.getElementById("campaignRaised").innerText = raisedFormatted;
        // Show a banner if the campaign has ended
        const campaignEndedBanner = document.getElementById("campaignEndedBanner");
        if (timeLeftInSeconds === 0) campaignEndedBanner.style.display = "block"; // Show the banner
        else campaignEndedBanner.style.display = "none"; // Hide the banner
        // Calculate progress percentage safely
        const goalBigInt = BigInt(campaign.goal.toString()); // Ensure goal is BigInt
        const raisedBigInt = BigInt(campaign.raisedAmount.toString()); // Ensure raised amount is BigInt
        const progressPercent = Number(raisedBigInt * 100n / goalBigInt); // Explicit conversion to Number
        // Update progress bar
        const progressBarFill = document.getElementById("progressBarFill");
        progressBarFill.style.width = `${Math.min(progressPercent, 100)}%`;
        // Show a success banner if the goal is fully raised
        const campaignSuccessBanner = document.getElementById("campaignSuccessBanner");
        if (raisedBigInt >= goalBigInt) {
            campaignSuccessBanner.style.display = "block"; // Show the success banner
            progressBarFill.style.backgroundColor = "#4caf50"; // Green progress bar for success
        } else {
            campaignSuccessBanner.style.display = "none"; // Hide the success banner
            progressBarFill.style.backgroundColor = "#4caf50"; // Default progress bar color
        }
        // Show campaign details and donation section
        document.getElementById("campaignDetails").style.display = "block";
        document.getElementById("donateSection").style.display = timeLeftInSeconds > 0 && raisedBigInt < goalBigInt ? "block" : "none"; // Hide donation section if the campaign has ended or is fully funded
        // Start the countdown timer
        startCountdownTimer(timeLeftInSeconds);
        // Load and display the list of donors
        const donorListElement = document.getElementById("donorList");
        donorListElement.innerHTML = ""; // Clear previous donor list
        const contributorCount = await contract.getContributorsCount(tokenId1);
        for(let i = 0; i < contributorCount; i++){
            const contributorAddress = await contract.getContributorByIndex(tokenId1, i);
            const pseudonym1 = await contract.getContributorPseudonym(tokenId1, contributorAddress);
            const listItem = document.createElement("li");
            listItem.textContent = `${pseudonym1 || "Anonymous"} (${contributorAddress})`;
            donorListElement.appendChild(listItem);
        }
        // Show the donor list section
        document.getElementById("donorListSection").style.display = "block";
    } catch (error) {
        console.error(`Error loading campaign ${tokenId1}:`, error);
        console.warn(`Error loading campaign ${tokenId1}:`, error);
    // alert("Failed to load campaign. Please check the Campaign ID.");
    }
}
// Function to start the countdown timer
function startCountdownTimer(timeLeftInSeconds) {
    const timeLeftElement = document.getElementById("campaignTimeLeft");
    // Clear any existing interval to prevent multiple timers
    clearInterval(window.countdownInterval);
    // Update the timer every second
    window.countdownInterval = setInterval(()=>{
        if (timeLeftInSeconds <= 0) {
            clearInterval(window.countdownInterval);
            timeLeftElement.innerText = "Campaign has ended";
            timeLeftElement.style.color = "red";
            return;
        }
        // Convert seconds into days, hours, minutes, and seconds
        const days = Math.floor(timeLeftInSeconds / 86400);
        const hours = Math.floor(timeLeftInSeconds % 86400 / 3600);
        const minutes = Math.floor(timeLeftInSeconds % 3600 / 60);
        const seconds = timeLeftInSeconds % 60;
        // Format the time string
        const timeString = `${days > 0 ? `${days}d ` : ""}${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
        timeLeftElement.innerText = timeString;
        // Decrement the time left
        timeLeftInSeconds--;
    }, 1000);
}
// Handle donation form submission
document.getElementById("donateForm").addEventListener("submit", async (e)=>{
    e.preventDefault();
    // Check if the wallet is connected
    if (!signer) {
        alert("Please connect your wallet before donating.");
        openWalletModal(); // Optionally open the wallet modal to prompt connection
        return;
    }
    const amount = ethers.parseEther(document.getElementById("amount").value);
    const pseudonym1 = document.getElementById("pseudonym").value || "Anonymous";
    // Create the contract instance with the signer
    // console.warn()
    console.warn("INFO DEL CONTRACT:", CONTRACT_ADDRESS, CONTRACT_ABI, signer);
    contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
    cx = contract;
    // UNSINGNED TX
    const tokenId1 = getQueryParams().tokenId; // Retrieve tokenId from query params
    // Encode the function call using the contract ABI
    const iface = new ethers.Interface(CONTRACT_ABI);
    const data = iface.encodeFunctionData("contribute", [
        tokenId1,
        pseudonym1
    ]);
    console.warn("DATA:", data);
    // let dappWallet = 'metamask'; // Example assignment
    if (dappWallet === "metamask") {
        console.log("Using MetaMask wallet");
        // let functionSignature = functionSelector();
        // 0xe7315f99
        // Step 2: Use AbiCoder to encode the parameters
        const parameterTypes = [
            "uint256",
            "string"
        ];
        const abiCoder = new ethers.AbiCoder();
        const encodedParameters = abiCoder.encode(parameterTypes, [
            tokenId1,
            pseudonym1
        ]);
        console.log("Encoded Parameters:", encodedParameters);
        // DO THE TX
        try {
            // Get user's account
            const ethereummmsdk = mmsdk.getProvider();
            const accounts = await ethereummmsdk.request({
                method: "eth_requestAccounts"
            });
            // Create function signature for mint(uint256)
            // const functionSignature = "0x6a627842";
            let functionSignature = functionSelector();
            // Step 6: Combine the function selector and encoded parameters
            const txData = functionSignature + encodedParameters.slice(2);
            console.log("Transaction Data:", txData);
            // let fixedValue = 
            const contributionAmountInWei = amount; // 0.01 ETH in wei
            const contributionAmountHex = "0x" + contributionAmountInWei.toString(16); // Convert to hex
            console.log("Contribution Amount (Hex):", contributionAmountHex);
            let p = [
                {
                    from: accounts[0],
                    to: CONTRACT_ADDRESS,
                    data: txData,
                    value: contributionAmountHex
                }
            ];
            console.log("PARAMS:", p);
            // Send transaction
            try {
                const result = await window.ethereum.request({
                    method: "eth_sendTransaction",
                    params: [
                        {
                            from: accounts[0],
                            to: CONTRACT_ADDRESS,
                            data: txData,
                            value: contributionAmountHex
                        }
                    ]
                });
                console.log("Transaction Hash:", result);
            } catch (error) {
                console.error("Error sending transaction:", error);
            }
        // const txHash = await ethereum.request({
        //   method: "eth_sendTransaction",
        //   params: [{
        //       from: accounts[0],
        //     to: CONTRACT_ADDRESS,
        //     value: amount.toString(),
        //     data:  txData,
        //     gasLimit: 100000, // Adjust gas limit as needed
        //     chainId: optionsList[0].CHAIN_ID, // Replace with the appropriate chain ID (e.g., 1 for Ethereum Mainnet)
        //     // to: CONTRACT_ADDRESS,
        //     // data: functionSignature + encodedParameters,
        //   }],
        // });
        // return txHash;
        } catch (error) {
            if (error.code === 4001) throw new Error("Transaction rejected by user");
            throw error;
        }
    // }
    // Add MetaMask-specific logic here
    } else if (dappWallet === "iusNaturalis") console.log("Using iusNaturalis wallet");
    else if (dappWallet === "") console.log("No wallet selected");
    else console.log("Unknown wallet type");
    // Create the unsigned transaction object
    unsignedTx = {
        to: CONTRACT_ADDRESS,
        value: amount.toString(),
        data: data,
        gasLimit: 100000,
        chainId: optionsList[0].CHAIN_ID
    };
    console.log(unsignedTx);
    let stringedMessage = JSON.stringify(unsignedTx);
    console.log("stringedMessage: ", stringedMessage); // Check the output
    // ....................
    // SEND MESSAGE
    // Define the code for the message type
    // Format the message by prepending the code
    // Create a new conversation
    // // Send the formatted message
    const chatCode = "paymentSign0x22"; // Example: Replace with the appropriate code
    const formattedMessage = `${chatCode} ${stringedMessage}`;
    let conversation = await iusnaturalisxmtp.conversations.newConversation(peerVerifiedAddress);
    conv = conversation;
    await conversation.send(formattedMessage);
    var error, error1;
    return;
});
// https://localhost:4343/don2.html?tokenId=1
// Automatically load campaign if tokenId is present in the URL
window.onload = async ()=>{
    dappWallet = "";
    loadSavedTheme();
    // RANDOM PROVIDER SELECTOR
    // -----------------
    // GET PROVIDER
    // -----------------
    // console.warn('CREATING PROVIDER FOR CHAIN ID:', chainId)
    let chainId = optionsList[0].CHAIN_ID;
    const rpcs = await getRPCsByChainId(Number(chainId));
    const selProv = await simpleRandomProvider(rpcs);
    // window.provider = await new ethers.JsonRpcProvider(selProv);
    if (!selProv) throw new Error("No working RPC provider found");
    console.log("Selected RPC URL \uD83E\uDDE1\uD83E\uDDE1\uD83E\uDDE1:", selProv);
    // window.provider = new ethers.JsonRpcProvider(selProv);
    provider = new ethers.JsonRpcProvider(optionsList[0].API);
    // window.provider = new ethers.JsonRpcProvider(optionsList[0].API);
    // const provider = new ethers.JsonRpcProvider(optionsList[0].API);
    contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);
    const queryParams = getQueryParams();
    if (queryParams.tokenId) // document.getElementById("tokenId").value = queryParams.tokenId; // Pre-fill the input field
    await loadCampaign(queryParams.tokenId); // Load the campaign details
    updateDonateButtonState();
    // Event listeners
    // openModalBtn.addEventListener("click", openModal);
    document.getElementById("closeModalBtnPaymentModal").addEventListener("click", closePaymentModal);
// loadSavedTheme();
// // Initialize Tone.js
// Tone.start();
// console.log("tone started");
// Add event listener to close modal when clicking outside
// const overlay = document.getElementById('overlay');
// overlay.addEventListener('click', closeModal);
};
// Function to show the success animation
function showSuccessAnimation() {
    // Hide QR code and countdown
    qrCodeContainer.style.display = "none";
    countdownElement.style.display = "none";
    // Show success section
    // successMessage.innerText = 'Connected!'
    successSection.style.display = "flex";
    iusConnect.innerHTML = "";
}
// ----------------------------------
// HACK TO COMMUNICATE THROUGH XMTP
// ----------------------------------
async function createXMTPClient(wallet, databaseEncryptionKey) {
    // If no databaseEncryptionKey is provided, generate a new one
    if (!databaseEncryptionKey) {
        databaseEncryptionKey = new Uint8Array(32);
        crypto.getRandomValues(databaseEncryptionKey);
        console.log("Generated new databaseEncryptionKey:", databaseEncryptionKey);
    }
    console.log("createXMTPClient: ", wallet, databaseEncryptionKey);
    try {
        // Creating a new XMTP client
        const xmtpClient = await Client.create(wallet, {
            env: "dev",
            dbEncryptionKey: databaseEncryptionKey
        });
        console.warn("\uD83D\uDFE2\uD83D\uDFE2\uD83D\uDFE2 XMTP STARTED \uD83D\uDFE2\uD83D\uDFE2\uD83D\uDFE2 \uD83D\uDD34\uD83D\uDFE0\uD83D\uDFE1\uD83D\uDD35\u26AB COMMUNICATING WITH THIS ADDRESS: ", wallet.address);
        return xmtpClient;
    } catch (error) {
        console.error("Failed to create XMTP client:", error);
        throw error; // Re-throw the error for the caller to handle
    }
}
// ---------
async function contractWallet() {
    let contractMnemonic = localStorage.getItem("contractMnemonic");
    if (!contractMnemonic) {
        console.error("NO contractMnemonic  in localStorage!");
        const randmnemonic = await ethers.HDNodeWallet.createRandom();
        contractMnemonic = randmnemonic.mnemonic.phrase;
        localStorage.setItem("contractMnemonic", contractMnemonic);
    } else console.log("contractMnemonic is in localStorage!");
    let contractWall = deriveAddressWallet(contractMnemonic, 0);
    return contractWall;
}
// ---------------
// Function to derive an address on demand
async function deriveAddressWallet(mnemonic, index) {
    const basePath = "m/44'/60'/0'/0/";
    const path = `${basePath}${index}`;
    const derivedNode = ethers.HDNodeWallet.fromPhrase(mnemonic, path);
    return derivedNode;
}
// ---------------
// 2. Derive the databaseEncryptionKey
/**
         // HELPERS
         * Generates cryptographically secure random bytes.
         * @param {number} length - The number of bytes to generate.
         * @returns {Uint8Array} A Uint8Array containing the random bytes.
         */ function getRandomBytes(length) {
    return crypto.getRandomValues(new Uint8Array(length));
}
/**
         * Converts a hex string to a Uint8Array.
         * @param {string} hex - The hex string.
         * @returns {Uint8Array} The corresponding Uint8Array.
         */ function hexToUint8Array(hex) {
    return new Uint8Array(hex.match(/[\da-f]{2}/gi).map((byte)=>parseInt(byte, 16)));
}
/**
         * Converts a Uint8Array to a hex string.
         * @param {Uint8Array} uint8Array - The Uint8Array to convert.
         * @returns {string} The corresponding hex string.
         */ function uint8ArrayToHex(uint8Array) {
    return Array.from(uint8Array).map((byte)=>byte.toString(16).padStart(2, "0")) // Ensure each byte is 2 characters
    .join("");
}
/**
         * Concatenates two Uint8Arrays.
         * @param {Uint8Array} array1 - The first array.
         * @param {Uint8Array} array2 - The second array.
         * @returns {Uint8Array} The concatenated array.
         */ function concatUint8Arrays(array1, array2) {
    const result = new Uint8Array(array1.length + array2.length);
    result.set(array1);
    result.set(array2, array1.length);
    return result;
}
/**
         * Derives a database encryption key from the wallet's private key.
         * @param {string} privateKey - The wallet's private key (hex string).
         * @returns {Object} An object containing the derived key and salt.
         */ async function deriveDatabaseEncryptionKey(privateKey) {
    // Generate a random salt using Web Crypto API
    const salt = getRandomBytes(16); // 16 bytes of random data
    // Define the number of iterations
    const iterations = 100000;
    // Derive the key by hashing the private key + salt repeatedly
    let derivedKey = hexToUint8Array(privateKey);
    for(let i = 0; i < iterations; i++)derivedKey = sha256(concatUint8Arrays(derivedKey, salt));
    // Log the length of the derived key for debugging
    console.log("Derived Key Length (bytes):", derivedKey.length);
    // Ensure the derived key is exactly 32 bytes
    if (derivedKey.length !== 32) throw new Error(`Unexpected derived key length: ${derivedKey.length} bytes`);
    // Convert the derived key to a hex string
    const derivedKeyHex = uint8ArrayToHex(derivedKey);
    console.log("Derived Key (hex):", derivedKeyHex);
    // Return the derived key and salt
    return {
        derivedKey: derivedKeyHex,
        salt: uint8ArrayToHex(salt) // Salt as hex string
    };
}
// ENCRYPT DECRYPT FUNCTIONS 
/**
         * Encrypts data using AES-CBC with the derived key.
         * @param {string} plaintext - The data to encrypt.
         * @param {string} key - The encryption key (hex string).
         * @returns {Promise<Object>} An object containing the IV and ciphertext.
         */ async function encryptData(plaintext, key) {
    const encoder = new TextEncoder();
    const cryptoKey = await crypto.subtle.importKey("raw", hexToUint8Array(key), {
        name: "AES-CBC"
    }, false, [
        "encrypt"
    ]);
    // Generate a random initialization vector (IV)
    const iv = crypto.getRandomValues(new Uint8Array(16));
    // Encrypt the plaintext
    const encrypted = await crypto.subtle.encrypt({
        name: "AES-CBC",
        iv
    }, cryptoKey, encoder.encode(plaintext));
    // Return the IV and ciphertext as byte arrays
    return {
        iv: Array.from(iv),
        ciphertext: Array.from(new Uint8Array(encrypted))
    };
}
/**
         * Decrypts data using AES-CBC with the derived key.
         * @param {Object} encryptedData - The encrypted data (IV and ciphertext).
         * @param {string} key - The decryption key (hex string).
         * @returns {Promise<string>} The decrypted plaintext.
         */ async function decryptData(encryptedData, key) {
    const cryptoKey = await crypto.subtle.importKey("raw", hexToUint8Array(key), {
        name: "AES-CBC"
    }, false, [
        "decrypt"
    ]);
    // Decrypt the ciphertext
    const decrypted = await crypto.subtle.decrypt({
        name: "AES-CBC",
        iv: new Uint8Array(encryptedData.iv)
    }, cryptoKey, new Uint8Array(encryptedData.ciphertext).buffer);
    // Decode the plaintext
    const decoder = new TextDecoder();
    return decoder.decode(decrypted);
}
/**
         * Initializes the database encryption process.
         */ async function initializeDatabaseEncryption() {
    try {
        // 000
        // let contractMnemonic = localStorage.getItem('contractMnemonic');
        let derivedKey = localStorage.getItem("dbEncryptionSalt");
        if (!derivedKey) {
            console.error("NO dbEncryptionSalt  in localStorage!");
            // Step 1: Get the wallet
            const wallet = await contractWallet();
            // Step 2: Derive the database encryption key
            const { derivedKey, salt } = await deriveDatabaseEncryptionKey(wallet.privateKey);
            // Step 3: Store the salt securely (e.g., in localStorage)
            localStorage.setItem("dbEncryptionSalt", salt);
            // Step 4: Use the derivedKey for encryption/decryption
            console.log("Derived Database Encryption Key:", derivedKey);
            // // Example: Encrypt some data
            const plaintext = "Sensitive data";
            const encrypted = await encryptData(plaintext, derivedKey);
            console.log("Encrypted Data:", encrypted);
            // Example: Decrypt the data
            const decrypted = await decryptData(encrypted, derivedKey);
            console.log("Decrypted Data:", decrypted);
        } else console.log("dbEncryption Salt is in localStorage!");
        // 000
        return derivedKey;
    } catch (error) {
        console.error("Error initializing database encryption:", error);
    }
}
// Call the function
// initializeDatabaseEncryption();
// ----------------------------------
async function metamaskConnect() {
    console.log("metamaskConnect");
    document.getElementById("walletModal").close();
    const MMSDK = new MetaMaskSDK({
        dappMetadata: {
            name: "stealthDonations Dapp",
            url: window.location.href
        },
        infuraAPIKey: globalOptionsList[0].INFURA_API_KEY
    });
    window.MMSDK = MMSDK;
    // Connect and get accounts
    const accounts = await MMSDK.connect();
    console.log("accounts:", accounts);
    // Update UI with connected account
    if (accounts.length > 0) {
        // document.getElementById("campaignDonor")
        let donorElement = document.getElementById("campaignDonor");
        donorElement.innerText = `Connected: ${accounts[0]}`;
        successMessage.innerText = `Conneted as: ${accounts[0]}`;
        donorElement.classList.add("success-text");
        // ---------
        console.log("CONTINUE connectwallet().");
        const provider = MMSDK.getProvider();
        const ethereummmsdk = mmsdk.getProvider();
        // provider = await new ethers.BrowserProvider(ethereumProvider);
        // await provider.send("eth_requestAccounts", []);
        // signer = await provider.getSigner();
        // contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        // closeWalletModal();
        // document.getElementById('paymentModal').close();
        signer = true;
        dappWallet = "metamask";
        // let dappWallet = 'metamask'; // Example assignment
        // if (dappWallet === 'metamask') {
        //     console.log('Using MetaMask wallet');
        //     // Add MetaMask-specific logic here
        // } else if (dappWallet === 'iusNaturalis') {
        //     console.log('Using iusNaturalis wallet');
        //     // Add iusNaturalis-specific logic here
        // } else if (dappWallet === '') {
        //     console.log('No wallet selected');
        //     // Handle the case where no wallet is selected
        // } else {
        //     console.log('Unknown wallet type');
        //     // Handle unexpected values
        // }
        updateDonateButtonState(); // Update the donate button state
    // stayInSync(ethereumProvider)
    // showSuccessAnimation()
    // status.textContent = 'Status: Connected';
    // currentAccount = accounts[0];
    // connectButton.style.display = 'none';
    // accountSpan.textContent = accounts[0];
    // accountDisplay.style.display = 'block';
    // signButton.style.display = 'inline-block'; // Show the create sign button
    // createOwnStealthAddressButton.style.display = 'inline-block'; // Show the create stealth address button
    } else status.textContent = "Error: No accounts found.";
    // Get provider for RPC requests
    const provider = MMSDK.getProvider();
    // Batch multiple RPC requests
    const batchResults = await provider.request({
        method: "metamask_batch",
        params: [
            {
                method: "eth_accounts"
            },
            {
                method: "eth_chainId"
            }
        ]
    });
    console.log("account:", batchResults[0][0]);
    console.log("chaiId:", parseInt(batchResults[1], 16));
    return;
}
// Function to open the modal and generate QR code
async function iusConnectModal() {
    console.warn("iusConnectModal()");
    // closeWalletModal();
    // let countdownInterval;
    // let remainingTime = 15 * 60; // 15 minutes in seconds
    const successSection1 = document.getElementById("successSection");
    // modify title
    document.getElementById("paymentModalTitle").innerText = "To login to the app, please sign this message with your wallet";
    // document.getElementById('paymentModalTitle').innerText='Connect'
    console.log("\uD83D\uDCA2\uD83D\uDCAB\uD83D\uDE43 Initializing and connecting to Ius Naturalis wallet...");
    // Create  address for this site to communicate with the user
    let smartcontractwallet = await contractWallet();
    let databaseEncryptionKey = await initializeDatabaseEncryption();
    const iusnaturalisxmtp1 = await createXMTPClient(smartcontractwallet, databaseEncryptionKey);
    window.iusnaturalisxmtp = iusnaturalisxmtp1; // make GLOBAL
    console.log("isNOTConnected!");
    // ...................................................
    // NEW MESSAGE TO SIGN USING ETH_REQUESTACCOUNTS v2 
    let uniqueTopic = `request-accounts-${Date.now()}`;
    let requestPayload = {
        action: "eth_requestAccounts",
        nonce: crypto.randomUUID(),
        xmtpTopic: uniqueTopic,
        requester: smartcontractwallet.address // Custom topic for XMTP messages
    };
    r = requestPayload;
    let qrCodeData = requestPayload;
    q = qrCodeData;
    document.getElementById("paymentModalTitle").innerText = `To login to the app, please sign this message with your wallet. Unique ID: ${requestPayload.nonce}`;
    const jsonString = JSON.stringify(requestPayload, (key, value)=>typeof value === "bigint" ? value.toString() : value);
    const escapedJsonString = JSON.stringify(jsonString).replace(/"/g, "&quot;") // Replace double quotes with HTML-escaped equivalent
    .replace(/'/g, "&#39;"); // Replace single quotes with HTML-escaped equivalent
    let unescapedJsonString = JSON.stringify(jsonString);
    js = escapedJsonString;
    // ...................................................
    // MESSAGE TO SIGN
    // let messageToSign = "I am logging with IusNaturalis";
    let m = `${escapedJsonString}`;
    document.getElementById("iusConnect").innerHTML = ` <div class=" responsive-svg" id="canvas"></div> 
                <svg class='copy2clipboard' id='' onclick="event.stopPropagation();copy2clipboard('${m}')" xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"> <path  fill='currentColor' d="M433.941 65.941l-51.882-51.882A48 48 0 0 0 348.118 0H176c-26.51 0-48 21.49-48 48v48H48c-26.51 0-48 21.49-48 48v320c0 26.51 21.49 48 48 48h224c26.51 0 48-21.49 48-48v-48h80c26.51 0 48-21.49 48-48V99.882a48 48 0 0 0-14.059-33.941zM266 464H54a6 6 0 0 1-6-6V150a6 6 0 0 1 6-6h74v224c0 26.51 21.49 48 48 48h96v42a6 6 0 0 1-6 6zm128-96H182a6 6 0 0 1-6-6V54a6 6 0 0 1 6-6h106v88c0 13.255 10.745 24 24 24h88v202a6 6 0 0 1-6 6zm6-256h-64V48h9.632c1.591 0 3.117.632 4.243 1.757l48.368 48.368a6 6 0 0 1 1.757 4.243V112z"/> </svg>
                 <div id="result"> </div> `;
    // Generate QR Code
    QRCode.toCanvas(m, {
        width: 256
    }, (error, canvas)=>{
        // QRCode.toCanvas(txRequest, { width: 256 }, (error, canvas) => {
        if (error) {
            console.error("Error generating QR code:", error);
            return;
        }
        qrCodeContainer.innerHTML = ""; // Clear previous QR code
        qrCodeContainer.appendChild(canvas); // Append new QR code
    });
    // Reset countdown
    remainingTime = 900;
    updateCountdown();
    // Show modal
    // paymentModal.showModal();
    // closeWalletModal();
    document.getElementById("walletModal").close();
    document.getElementById("paymentModal").showModal();
    // Start countdown
    startCountdown();
    // CONTINUE BY LISTENING TO COMM
    await listenToAllMessages(iusnaturalisxmtp1, qrCodeData);
}
// ---------------------------------------------
// Start Listening to All Messages
// ---------------------------------------------
// Global State to Track Conversations
const activeChats = new Map(); // Tracks open chat streams
let messageStore = {}; // Stores all messages grouped by address
let abortController;
async function listenToAllMessages(xmtpClient, messageInput) {
    console.log("listenToAllMessages()");
    // Create an AbortController to manage the stream
    abortController = new AbortController();
    const { signal } = abortController;
    // check address sender is not this page
    let smartcontractwallet = await contractWallet();
    let smartcontractAddr = smartcontractwallet.address;
    try {
        for await (const message of (await xmtpClient.conversations.streamAllMessages({
            signal
        }))){
            if (message.senderAddress === smartcontractAddr) {
                console.log(`\u{1F4E3} conversation from yourself`);
                continue;
            }
            console.log(`\u{1F383} New message from [${message.senderAddress}]: ${message.content}`);
            peerAddress = message.senderAddress;
            // Add message to the global message store
            if (!messageStore[message.senderAddress]) messageStore[message.senderAddress] = [];
            messageStore[message.senderAddress].push({
                content: message.content,
                timestamp: message.sent
            });
            // Notify the UI or state manager
            console.warn("MESSAGE:", message.senderAddress, message.content, messageInput);
            let recoveredAddress = ethers.verifyMessage(JSON.stringify(messageInput), message.content);
            console.warn(`Logged in as: ${recoveredAddress}`);
            peerVerifiedAddress = recoveredAddress;
            // const signer = await provider.getSigner(recoveredAddress);
            // document.getElementById("walletStatus").innerText = `Connected: ${recoveredAddress}`;
            document.getElementById("campaignDonor").innerText = `Connected: ${recoveredAddress}`;
            successMessage.innerText = `Conneted as: ${recoveredAddress}`;
            document.getElementById("paymentModalTitle").innerText = "Perfect!";
            window.iusNaturalis = new IusNaturalisProvider(recoveredAddress);
            provider = new ethers.BrowserProvider(window.iusNaturalis);
            signer = await provider.getSigner();
            ethereumProvider = window.iusNaturalis;
            window.ethereum = window.iusNaturalis;
            // ---
            // provider = new ethers.BrowserProvider(window.iusNaturalis);
            // window.iusNaturalis = await  new IusNaturalisProvider(recoveredAddress);
            // signer = await provider.getSigner();
            // ethereumProvider = window.iusNaturalis;
            // window.ethereum = window.iusNaturalis;
            // ---
            showSuccessAnimation();
            // document.getElementById('connectWalletBtn').style.display ='none'
            // CONTINUAR LOGICA DE connectWallet par ius aqui√∑
            // document.getElementById("walletStatus").innerText = `Connected: ${await signer.getAddress()}`;
            // document.getElementById("campaignDonor").innerText = `Connected: ${await signer.getAddress()}`;
            const signerAddress = await signer.getAddress();
            const donorElement = document.getElementById("campaignDonor");
            // closeWalletModal();
            updateDonateButtonState(); // Update the donate button state
            setTimeout(()=>{
                // alert('CLOSE PAYMENT MODAL...')
                document.getElementById("openBUtton").style.display = "none";
                document.getElementById("closeBUtton").style.display = "block";
                document.getElementById("paymentModal").close();
                // ..
                // Update the text content with a checkmark
                donorElement.innerText = `Connected: ${signerAddress} \u{2705}`;
                // Add the success class to trigger the animation
                donorElement.classList.add("success-text");
            // Remove the success class after the animation completes
            // setTimeout(() => {
            //   donorElement.classList.remove("success-text");
            // }, 800); // 0.5s for the animation duration
            // // Update the text content
            // donorElement.innerText = `Connected: ${signerAddress}`;
            // // Add the blinking class to trigger the animation
            // donorElement.classList.add("blink-text");
            // // Remove the blinking class after the animation completes
            // setTimeout(() => {
            //   donorElement.classList.remove("blink-text");
            // }, 1500); // 0.5s * 3 iterations = 1500ms
            // ..
            }, 1000);
            return;
        //  FILTER???
        // ....................
        }
    } catch (err) {
        if (err.name === "AbortError") console.log("Stopped listening to all messages.");
        else console.warn("Error in streamAllMessages:", err);
    }
}
// ---------------------------------------------
// INJECT PROVIDER
// ---------------------------------------------
//  import { ethers } from "ethers";
class IusNaturalisSigner extends ethers.AbstractSigner {
    // Remove type annotations and private keyword (not valid in JS)
    constructor(provider, address){
        super(provider);
        this.provider = provider;
        this._address = ethers.getAddress(address); // Validate and format the address
    }
    async getAddress() {
        alert("is naturalis getAddress");
        return this._address;
    }
    async signMessage(message) {
        const messageBytes = typeof message === "string" ? ethers.toUtf8Bytes(message) : message;
        return this.provider.send("personal_sign", [
            ethers.hexlify(messageBytes),
            this._address
        ]);
    }
    async signTransaction(transaction) {
        const tx = await ethers.resolveProperties(transaction);
        return this.provider.send("eth_signTransaction", [
            tx
        ]);
    }
    async sendTransaction(transaction) {
        const tx = await ethers.resolveProperties(transaction);
        const hash = await this.provider.send("eth_sendTransaction", [
            tx
        ]);
        return this.provider.getTransaction(hash);
    }
}
class IusNaturalisProvider {
    constructor(address){
        this.isIusNaturalis = true;
        this._events = {};
        this._address = ethers.getAddress(address); // Validate and format the address
    }
    // Core method for handling JSON-RPC requests
    async request({ method, params }) {
        // alert('_sendToWalletBackend')
        const response = await this._sendToWalletBackend(method, params);
        if (response.error) throw new Error(response.error.message);
        return response.result;
    }
    // ... (keep existing on/removeListener methods)
    async _sendToWalletBackend(method, params) {
        return {
            jsonrpc: "2.0",
            id: 1,
            result: await this._handleMethod(method, params)
        };
    }
    async _handleMethod(method, params) {
        switch(method){
            case "net_version":
                // Return the chain ID as a string (e.g., "1" for Ethereum Mainnet)
                return "1"; // Replace with the actual chain ID of your network
            case "eth_chainId":
                // alert('get eth_chainId');
                // Return the chain ID as a hex string (e.g., "0x1" for Ethereum Mainnet)
                return optionsList[0].TOKEN_CHAINID; // Replace with the actual chain ID in hex format
            // return "0x1"; // Replace with the actual chain ID in hex format
            case "eth_requestAccounts":
                return [
                    this._address
                ];
            case "eth_accounts":
                return [
                    this._address
                ];
            case "personal_sign":
                if (params[1].toLowerCase() !== this._address.toLowerCase()) throw new Error("Invalid address");
                return "0x_signed_message_hash";
            case "eth_sendTransaction":
                alert("sendign transaction!");
                params[0].from = this._address;
                return "0x_transaction_hash";
            case "eth_blockNumber":
                // Return the current block number as a hex string
                // return "0x" + (await ethers._getBlockNumber()).toString(16);
                return "0x" + (await this._getBlockNumber()).toString(16);
            default:
                throw new Error(`Method ${method} not supported`);
        }
    }
    // Helper method to fetch or mock the block number
    async _getBlockNumber() {
        // Option 1: Fetch the block number from a real Ethereum node
        console.warn("using helper method for geblocknumber");
        const fallbackProvider = new ethers.JsonRpcProvider(optionsList[0].API);
        return await fallbackProvider.getBlockNumber();
    // Option 2: Mock the block number for testing
    // return 18_000_000; // Replace with a mock block number
    }
}
// ---------------------------------------------
// UPDATE CONVERSATIONS
// ---------------------------------------------
// Conversation List UI Updates
// Maintain a list of conversations with their last message and timestamps:
async function updateConversationList(address, signature, messageInput) {
    console.log(`\u{1F646}\u{200D}\u{2642}\u{FE0F} \u{1F646}\u{200D}\u{2642}\u{FE0F} \u{1F646}\u{200D}\u{2642}\u{FE0F}Updated conversation with ${address}: ${signature}`);
    // Update the UI or state with the latest conversation data
    // let signature = lastMessage;
    sig = signature;
    msg = messageInput;
    let recoveredAddress = ethers.verifyMessage(JSON.stringify(messageInput), signature);
    // let recoveredAddress = ethers.verifyMessage(messageInput);
    rx = recoveredAddress;
    console.warn(`Logged in as: ${recoveredAddress}`);
    alert(`Logged in as: ${recoveredAddress}`);
    return;
}
function iusPayModal() {
    // modify title
    document.getElementById("paymentModalTitle").innerText = "Pay";
    // Simulate generating a transaction request or payment link
    const txRequest = "ethereum:0xYourContractAddress?value=10000000000000000"; // Example Ethereum URI
    // Generate QR Code
    QRCode.toCanvas(txRequest, {
        width: 256
    }, (error, canvas)=>{
        if (error) {
            console.error("Error generating QR code:", error);
            return;
        }
        qrCodeContainer.innerHTML = ""; // Clear previous QR code
        qrCodeContainer.appendChild(canvas); // Append new QR code
    });
    // Reset countdown
    remainingTime = 900;
    updateCountdown();
    // Show modal
    paymentModal.showModal();
    // Start countdown
    startCountdown();
}
// Function to close the modal
// function closeModal() {
//   clearInterval(countdownInterval); // Stop countdown
//   // document.getElementById("paymentModal")
//   document.getElementById("paymentModal").close(); // Close modal
// }
// Function to start the countdown
function startCountdown() {
    countdownInterval = setInterval(()=>{
        remainingTime--;
        if (remainingTime <= 0) {
            clearInterval(countdownInterval);
            closeModal();
        }
        updateCountdown();
    }, 1000);
}
// Function to update the countdown display
function updateCountdown() {
    // Select DOM elements
    // const openModalBtn = document.getElementById("openModalBtn");
    const countdownElement = document.getElementById("countdown");
    const minutes = Math.floor(remainingTime / 60);
    const seconds = remainingTime % 60;
    countdownElement.textContent = `Expires in: ${minutes}:${seconds < 10 ? "0" : ""}${seconds}`;
}
function stayInSync(ethereumProvider1) {
    console.log("stayInSync()");
    // STAY IN SYNC WITH WALLLET STATE
    // Listen for account changes
    ethereumProvider1.on("accountsChanged", async (accounts)=>{
        console.log("Accounts changed:", accounts);
        if (accounts.length === 0) console.warn("User disconnected their wallet.");
        else {
            const signer = await provider.getSigner();
            console.warn("New connected account:", await signer.getAddress());
        }
    });
    // Listen for chain changes
    ethereumProvider1.on("chainChanged", (chainId)=>{
        // alert('Network changed:', chainId, '...RELOADING');
        alert("Network changed ...RELOADING");
        // Optionally reload the page or update the app state
        window.location.reload();
    });
}
// Prepare the transaction
async function prepareTransaction() {
    try {
        // Estimate gas limit (optional but recommended)
        const gasLimit = await contract.contribute.estimateGas(tokenId, pseudonym, {
            value: contributionAmount
        });
        // Send the transaction
        const tx = await contract.contribute(tokenId, pseudonym, {
            value: contributionAmount,
            gasLimit: gasLimit // Optional: Use the estimated gas limit
        });
        console.log(`Transaction sent! Tx hash: ${tx.hash}`);
        // Wait for the transaction to be mined
        const receipt = await tx.wait();
        console.log(`Transaction mined in block ${receipt.blockNumber}`);
    } catch (error) {
        console.error("Error sending transaction:", error);
    }
}
// Prepare the transaction for signing
async function prepareTransactionForSigning(senderAddress, tokenId1, pseudonym1, contributionAmount1) {
    // Replace these with your actual values
    const CONTRACT_ADDRESS = optionsList[0].CONTRACT_ADDRESS;
    const CONTRACT_ABI = [
        "function contribute(uint256 _tokenId, string memory _pseudonym) external payable"
    ];
    provider = new ethers.JsonRpcProvider(optionsList[0].API);
    // const provider = new ethers.JsonRpcProvider(optionsList[0].API);
    // contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);
    // let tokenId;
    const queryParams = getQueryParams();
    if (queryParams.tokenId) {
        // document.getElementById("tokenId").value = queryParams.tokenId; // Pre-fill the input field
        loadCampaign(queryParams.tokenId); // Load the campaign details
        tokenId1 = queryParams.tokenId;
    } else tokenId1 = 1; //set as default
    // const pseudonym =  document.getElementById("pseudonym").value || "Anonymous"; // Example pseudonympseudonym
    // const contributionAmount = document.getElementById("amount").value; // Example contribution amount (0.1 ETH)
    // const contributionAmount = ethers.parseEther("0.1"); // Example contribution amount (0.1 ETH)
    // User's address (the sender of the transaction)
    // const userAddress = "0xUserAddress"; // Replace with the user's Ethereum address
    // Create a contract instance
    const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);
    // const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, provider);
    try {
        // Get the nonce for the sender's address
        // const senderAddress = "0xUserAddress"; // Replace with the user's address
        const nonce = await provider.getTransactionCount(senderAddress);
        console.log("NONCE:", nonce);
        // Estimate, gas limit (optional but recommended)
        const gasLimit = await contract.contribute.staticCall(tokenId1, pseudonym1, {
            value: contributionAmount1
        });
        // Encode the function call
        const data = contract.interface.encodeFunctionData("contribute", [
            tokenId1,
            pseudonym1
        ]);
        // Create the transaction object
        const tx = {
            to: CONTRACT_ADDRESS,
            value: contributionAmount1,
            data: data,
            gasLimit: gasLimit,
            nonce: nonce,
            chainId: optionsList[0].CHAIN_ID,
            type: 2,
            maxPriorityFeePerGas: ethers.parseUnits("2", "gwei"),
            maxFeePerGas: ethers.parseUnits("20", "gwei") // Optional: Set max fee
        };
        // Serialize the transactioncontributionAmount
        const serializedTx = ethers.Transaction.from(tx).serialized;
        console.log("Serialized Transaction:", serializedTx);
        // Send this serialized transaction to the user (e.g., via XMTP)
        return serializedTx;
    } catch (error) {
        console.error("Error preparing transaction:", error);
    }
}
/**
         * Function to sign a serialized transcontributionAmountaction.
        // CLIENTE !!!
         * ESTO SE HACE EN EL CLIENTE
         * @param {string} serializedTx - The serialized transaction (unsigned).
         * @param {string} privateKey - The user's private key (ensure this is secure and not exposed publicly).
         * @returns {Promise<string>} - The signed transaction (ready to be broadcasted).
         */ async function signTransaction(serializedTx, privateKey) {
    try {
        // Create a wallet instance using the private key
        const wallet = new ethers.Wallet(privateKey);
        // Parse the serialized transaction
        const tx = ethers.Transaction.from(serializedTx);
        // Sign the transaction
        const signedTx = await wallet.signTransaction(tx);
        console.log("Signed Transaction:", signedTx);
        return signedTx;
    } catch (error) {
        console.error("Error signing transaction:", error);
        throw error;
    }
}
// CLIENTE !!!
// Broadcast the signed transaction
// BROADCASTEADO AUTOMATICAMENTE POR EL CLIENTE
// SI EL CLIENTE NO TINEE INTERNET, LO PASA POR QR AL EMISO
async function broadcastTransaction(signedTx) {
    try {
        const txResponse = await provider.broadcastTransaction(signedTx);
        console.log("Transaction broadcasted! Tx hash:", txResponse.hash);
        // Wait for the transaction to be mined (optional)
        const receipt = await txResponse.wait();
        console.log(`Transaction mined in block ${receipt.blockNumber}`);
    } catch (error) {
        console.error("Error broadcasting transaction:", error);
    }
}
async function sendSignedMessage(xmtpClient, address, messageContent) {
    try {
        let conversation = await iusnaturalisxmtp.conversations.newConversation(address);
        // Send the message
        await conversation.send(messageContent);
        console.log(`Message sent to ${address}: ${messageContent}`);
        // Optionally, add the sent message to the message store
        if (!messageStore[address]) messageStore[address] = [];
        messageStore[address].push({
            content: messageContent,
            timestamp: new Date(),
            sender: "self"
        });
    // Update the chat window
    // updateChatWindow(address, messageContent);
    } catch (err) {
        console.error(`Failed to send message to ${address}:`, err);
    }
}
// -----------------------------------------
// NEW STEALTH ADDRESS FUNCTIONS
// -----------------------------------------
async function generateStealthAddress(privateKeyA, publicKeyB) {
    // privkey sender, pubkey recipient
    console.warn("\uD83C\uDFF0 generateStealthAddress()", privateKeyA, publicKeyB);
    const privateKeyHex = `0x${toHexString(privateKeyA)}`;
    a = privateKeyHex;
    b = publicKeyB;
    c = privateKeyA;
    const pubPoint = secp.ProjectivePoint.fromHex(publicKeyB);
    ppoint = pubPoint;
    const sharedSecret = pubPoint.multiply(BigInt(privateKeyHex)).toHex();
    console.log("\uD83D\uDC6BsharedSecret( at generateStealthAddress):", sharedSecret);
    const hashedSecret = ethers.keccak256("0x" + sharedSecret).slice(0, 42);
    // 1.Multiply hs by the curve generator point (G): You can use the secp256k1 generator point (which is a constant) to compute the point hs * G.
    const G = secp.ProjectivePoint.BASE; // Generator point G
    const hsBigInt = BigInt(hashedSecret); // hs should already be in hex or BigInt format
    const hsPoint = G.multiply(hsBigInt); // hs * G
    hsp = hsPoint;
    // 2.Add Bob‚Äôs public key: You now add Bob‚Äôs public key as an elliptic curve point to hs * G. Ensure Bob's public key is in the correct format for the addition.
    const point = secp.ProjectivePoint.fromHex(publicKeyB); // Bob's public key point
    const stealthPubPoint = hsPoint.add(point); // hs * G + Bob's public key
    p1 = point;
    p2 = stealthPubPoint;
    // 3.Convert the resulting point to an Ethereum address: Finally, you convert the resulting elliptic curve point to an Ethereum address. This is typically done by compressing the point to its x-coordinate, hashing it, and then converting it to an Ethereum address.
    const stealthPubKey = stealthPubPoint.toHex(); // Convert to hex
    const stealthAddress = ethers.computeAddress("0x" + stealthPubKey); // Convert to Ethereum address
    console.log("\uD83D\uDC7BStealth Address:", stealthAddress);
    return {
        stealthAddress,
        sharedSecret
    };
}
// ##################################
// CHATCODES
// Declare all chatCodes here
const chatCodeHandlers = {
    paymentSign0x22: handleSignPayment,
    paymentReceived0x21: handlePaymentReceived,
    peerGasPaymentAccepted0x21: handleGasPaymentAccepted,
    peerGasPaymentRequest0x20: handleGasPaymentRequest,
    addToken0x19: handleAddToken
};
async function handleChatCodes(message) {
    const content = message.content.trim(); // Trim whitespace for consistency
    // Extract the code from the beginning of the message
    const codeEndIndex = content.indexOf(" ");
    const code = codeEndIndex === -1 ? content : content.slice(0, codeEndIndex);
    // Check if the code exists in the handlers map
    if (chatCodeHandlers[code]) {
        // Extract the rest of the message (if any) after the code
        const remainingMessage = codeEndIndex === -1 ? "" : content.slice(codeEndIndex + 1).trim();
        // Call the corresponding handler with the full message and remaining content
        await chatCodeHandlers[code]({
            ...message,
            content: remainingMessage
        });
    } else console.warn(`Unknown chat code: ${code}`);
}
// Example handler functions
async function handleSignPayment(message) {
    console.log("Handling SIGN PAUMENT:", message);
}
async function handlePaymentReceived(message) {
    console.log("Handling payment received:", message);
}
async function handleGasPaymentAccepted() {
    console.log("Handling gas payment accepted");
}
async function handleGasPaymentRequest(message) {
    console.log("Handling gas payment request:", message);
}
async function handleAddToken(message) {
    console.log("Handling add token:", message);
}
// USAGE
// Define the code for the message type
// const chatCode = "paymentReceived0x21"; // Example: Replace with the appropriate code
// // Original message content
// const originalMessage = "Transaction successful";
// // Format the message by prepending the code
// const formattedMessage = `${chatCode} ${originalMessage}`;
// // Create a new conversation
// let conversation = await iusnaturalisxmtp.conversations.newConversation(addr);
// // Send the formatted message
// await conversation.send(formattedMessage);
// -----------------------------------------
// NEW STEALTH ADDRESS FUNCTIONS
// -----------------------------------------
async function generateStealthAddress(privateKey, publicKey) {
    // privkey sender, pubkey recipient
    console.warn("\uD83C\uDFF0 generateStealthAddress()", privateKey, publicKey);
    const privateKeyHex = `0x${toHexString(privateKey)}`;
    a = privateKeyHex;
    b = publicKey;
    c = privateKey;
    const pubPoint = secp.ProjectivePoint.fromHex(publicKey);
    ppoint = pubPoint;
    const sharedSecret = pubPoint.multiply(BigInt(privateKeyHex)).toHex();
    console.log("\uD83D\uDC6BsharedSecret( at generateStealthAddress):", sharedSecret);
    const hashedSecret = ethers.keccak256("0x" + sharedSecret).slice(0, 42);
    // 1.Multiply hs by the curve generator point (G): You can use the secp256k1 generator point (which is a constant) to compute the point hs * G.
    const G = secp.ProjectivePoint.BASE; // Generator point G
    const hsBigInt = BigInt(hashedSecret); // hs should already be in hex or BigInt format
    const hsPoint = G.multiply(hsBigInt); // hs * G
    hsp = hsPoint;
    // 2.Add Bob‚Äôs public key: You now add Bob‚Äôs public key as an elliptic curve point to hs * G. Ensure Bob's public key is in the correct format for the addition.
    const point = secp.ProjectivePoint.fromHex(publicKey); // Bob's public key point
    const stealthPubPoint = hsPoint.add(point); // hs * G + Bob's public key
    p1 = point;
    p2 = stealthPubPoint;
    // 3.Convert the resulting point to an Ethereum address: Finally, you convert the resulting elliptic curve point to an Ethereum address. This is typically done by compressing the point to its x-coordinate, hashing it, and then converting it to an Ethereum address.
    const stealthPubKey = stealthPubPoint.toHex(); // Convert to hex
    const stealthAddress = ethers.computeAddress("0x" + stealthPubKey); // Convert to Ethereum address
    console.log("\uD83D\uDC7BStealth Address:", stealthAddress);
    return {
        stealthAddress,
        sharedSecret
    };
}
function removeHexPrefix(hexString) {
    // Check if the hex string starts with '0x' and remove it
    if (hexString.startsWith("0x")) return hexString.slice(2);
    return hexString;
}
// -----------------------------------------
// STEALTH ADDRESS FUNCTIONS
// -----------------------------------------
// async function computePrivKey(bobprivateKey, alicepublicKey) {
async function computePrivKey(privateKey, publicKey) {
    console.warn("computePrivKey()", privateKey, publicKey);
    const publicKeyHexWithoutPrefix = removeHexPrefix(publicKey);
    const pubPoint = secp.ProjectivePoint.fromHex(publicKeyHexWithoutPrefix);
    const sharedSecret = pubPoint.multiply(BigInt(privateKey)).toHex();
    console.log("\uD83D\uDC6BsharedSecret  (at createStealthWallet ):", sharedSecret);
    const hashedSecret = ethers.keccak256("0x" + sharedSecret).slice(0, 42);
    // BOB can comput the private key to the stealth addres
    // b +hs
    const hprivkeyBigInt = BigInt(privateKey); // hs should already be in hex or BigInt format
    b = hprivkeyBigInt;
    const hsBigInt = BigInt(hashedSecret); // hs should already be in hex or BigInt format
    hs = hsBigInt;
    computedPrivKey = hprivkeyBigInt + hsBigInt;
    console.warn("\uD83D\uDEF0\uFE0F computedPrivKey: ", computedPrivKey);
    return computedPrivKey;
}
//  createStealthWallet(privateKey, publicKey) 
async function createStealthWallet(privateKey, publicKey) {
    console.warn("\uD83E\uDDB8\u200D\u2642\uFE0FcreateStealthWallet()", privateKey, publicKey);
    const publicKeyHexWithoutPrefix = removeHexPrefix(publicKey);
    const pubPoint = secp.ProjectivePoint.fromHex(publicKeyHexWithoutPrefix);
    const sharedSecret = pubPoint.multiply(BigInt(privateKey)).toHex();
    console.log("\uD83D\uDC6BsharedSecret  (at createStealthWallet ):", sharedSecret);
    const hashedSecret = ethers.keccak256("0x" + sharedSecret).slice(0, 42);
    // BOB can comput the private key to the stealth addres
    // b +hs
    const hprivkeyBigInt = BigInt(privateKey); // hs should already be in hex or BigInt format
    b = hprivkeyBigInt;
    const hsBigInt = BigInt(hashedSecret); // hs should already be in hex or BigInt format
    hs = hsBigInt;
    computedPrivKey = hprivkeyBigInt + hsBigInt;
    console.warn("\uD83D\uDEF0\uFE0F computedPrivKey: ", computedPrivKey);
    eth2bigint = ethers.toBigInt(computedPrivKey);
    const stealthPrivateKey = ethers.zeroPadValue(ethers.toBeHex(computedPrivKey), 32);
    console.warn(" \uD83D\uDE81 stealthPrivateKey: ", stealthPrivateKey);
    const stealthwallet = new ethers.Wallet(stealthPrivateKey);
    const derivedStealthPubKey = stealthwallet.publicKey;
    console.warn(" \uD83E\uDE82\uD83E\uDDB9\u200D\u2642\uFE0F stealthPrivateKey: ", stealthPrivateKey);
    console.warn(" \uD83E\uDE82 stealthAddress: ", stealthwallet.address);
    return stealthwallet;
}
async function claimFundsFromStealthAddress(bobPrivateKeyHex, alicePublicKeyHex, bobMainAddr) {
    console.log("claimFundsFromStealthAddress()");
    let provider = await new ethers.JsonRpcProvider(optionsList[0].API);
    let stealthPrivateKey = computePrivateKey(bobPrivateKeyHex, alicePublicKeyHex);
    // Create a wallet for the stealth address
    const stealthWallet = new ethers.Wallet(stealthPrivateKey, provider);
    console.log(`\u{1F47B}\u{1F47B}\u{1F47B}Stealth Wallet Address: ${stealthWallet.address}`);
    var error;
    return;
}
// METAMASK ONLY
function functionSelector() {
    // function contribute(uint256 _tokenId, string memory _pseudonym) external payable {
    // Contract details
    const contractAddress = optionsList[0].CONTRACT_ADDRESS;
    const functionName = "contribute";
    const parameterTypes = [
        "uint256",
        "string"
    ];
    const functionSignature = `${functionName}(${parameterTypes.join(",")})`;
    const functionSelector = ethers.id(functionSignature).slice(0, 10);
    console.log("functionSelector:", functionSelector);
    return functionSelector;
}

</script>
</body>

</html>