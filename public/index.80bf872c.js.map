{"mappings":"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","sources":["node_modules/@parcel/runtime-browser-hmr/lib/runtime-71f0ff5a02e64f24.js","node_modules/@noble/secp256k1/index.js"],"sourcesContent":["var HMR_HOST = null;var HMR_PORT = null;var HMR_SECURE = false;var HMR_ENV_HASH = \"d6ea1d42532a7575\";module.bundle.HMR_BUNDLE_ID = \"8c01001e80bf872c\";\"use strict\";\n\n/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */\n/*::\nimport type {\n  HMRAsset,\n  HMRMessage,\n} from '@parcel/reporter-dev-server/src/HMRServer.js';\ninterface ParcelRequire {\n  (string): mixed;\n  cache: {|[string]: ParcelModule|};\n  hotData: {|[string]: mixed|};\n  Module: any;\n  parent: ?ParcelRequire;\n  isParcelRequire: true;\n  modules: {|[string]: [Function, {|[string]: string|}]|};\n  HMR_BUNDLE_ID: string;\n  root: ParcelRequire;\n}\ninterface ParcelModule {\n  hot: {|\n    data: mixed,\n    accept(cb: (Function) => void): void,\n    dispose(cb: (mixed) => void): void,\n    // accept(deps: Array<string> | string, cb: (Function) => void): void,\n    // decline(): void,\n    _acceptCallbacks: Array<(Function) => void>,\n    _disposeCallbacks: Array<(mixed) => void>,\n  |};\n}\ninterface ExtensionContext {\n  runtime: {|\n    reload(): void,\n    getURL(url: string): string;\n    getManifest(): {manifest_version: number, ...};\n  |};\n}\ndeclare var module: {bundle: ParcelRequire, ...};\ndeclare var HMR_HOST: string;\ndeclare var HMR_PORT: string;\ndeclare var HMR_ENV_HASH: string;\ndeclare var HMR_SECURE: boolean;\ndeclare var chrome: ExtensionContext;\ndeclare var browser: ExtensionContext;\ndeclare var __parcel__import__: (string) => Promise<void>;\ndeclare var __parcel__importScripts__: (string) => Promise<void>;\ndeclare var globalThis: typeof self;\ndeclare var ServiceWorkerGlobalScope: Object;\n*/\nvar OVERLAY_ID = '__parcel__error__overlay__';\nvar OldModule = module.bundle.Module;\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData[moduleName],\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n  module.bundle.hotData[moduleName] = undefined;\n}\nmodule.bundle.Module = Module;\nmodule.bundle.hotData = {};\nvar checkedAssets /*: {|[string]: boolean|} */, assetsToDispose /*: Array<[ParcelRequire, string]> */, assetsToAccept /*: Array<[ParcelRequire, string]> */;\n\nfunction getHostname() {\n  return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');\n}\nfunction getPort() {\n  return HMR_PORT || location.port;\n}\n\n// eslint-disable-next-line no-redeclare\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = getHostname();\n  var port = getPort();\n  var protocol = HMR_SECURE || location.protocol == 'https:' && !['localhost', '127.0.0.1', '0.0.0.0'].includes(hostname) ? 'wss' : 'ws';\n  var ws;\n  try {\n    ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');\n  } catch (err) {\n    if (err.message) {\n      console.error(err.message);\n    }\n    ws = {};\n  }\n\n  // Web extension context\n  var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;\n\n  // Safari doesn't support sourceURL in error stacks.\n  // eval may also be disabled via CSP, so do a quick check.\n  var supportsSourceURL = false;\n  try {\n    (0, eval)('throw new Error(\"test\"); //# sourceURL=test.js');\n  } catch (err) {\n    supportsSourceURL = err.stack.includes('test.js');\n  }\n\n  // $FlowFixMe\n  ws.onmessage = async function (event /*: {data: string, ...} */) {\n    checkedAssets = {} /*: {|[string]: boolean|} */;\n    assetsToAccept = [];\n    assetsToDispose = [];\n    var data /*: HMRMessage */ = JSON.parse(event.data);\n    if (data.type === 'update') {\n      // Remove error overlay if there is one\n      if (typeof document !== 'undefined') {\n        removeErrorOverlay();\n      }\n      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH);\n\n      // Handle HMR Update\n      let handled = assets.every(asset => {\n        return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);\n      });\n      if (handled) {\n        console.clear();\n\n        // Dispatch custom event so other runtimes (e.g React Refresh) are aware.\n        if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') {\n          window.dispatchEvent(new CustomEvent('parcelhmraccept'));\n        }\n        await hmrApplyUpdates(assets);\n\n        // Dispose all old assets.\n        let processedAssets = {} /*: {|[string]: boolean|} */;\n        for (let i = 0; i < assetsToDispose.length; i++) {\n          let id = assetsToDispose[i][1];\n          if (!processedAssets[id]) {\n            hmrDispose(assetsToDispose[i][0], id);\n            processedAssets[id] = true;\n          }\n        }\n\n        // Run accept callbacks. This will also re-execute other disposed assets in topological order.\n        processedAssets = {};\n        for (let i = 0; i < assetsToAccept.length; i++) {\n          let id = assetsToAccept[i][1];\n          if (!processedAssets[id]) {\n            hmrAccept(assetsToAccept[i][0], id);\n            processedAssets[id] = true;\n          }\n        }\n      } else fullReload();\n    }\n    if (data.type === 'error') {\n      // Log parcel errors to console\n      for (let ansiDiagnostic of data.diagnostics.ansi) {\n        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;\n        console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\\n' + stack + '\\n\\n' + ansiDiagnostic.hints.join('\\n'));\n      }\n      if (typeof document !== 'undefined') {\n        // Render the fancy html overlay\n        removeErrorOverlay();\n        var overlay = createErrorOverlay(data.diagnostics.html);\n        // $FlowFixMe\n        document.body.appendChild(overlay);\n      }\n    }\n  };\n  ws.onerror = function (e) {\n    if (e.message) {\n      console.error(e.message);\n    }\n  };\n  ws.onclose = function () {\n    console.warn('[parcel] 🚨 Connection to the HMR server was lost');\n  };\n}\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n    console.log('[parcel] ✨ Error resolved');\n  }\n}\nfunction createErrorOverlay(diagnostics) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n  let errorHTML = '<div style=\"background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;\">';\n  for (let diagnostic of diagnostics) {\n    let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame) => {\n      return `${p}\n<a href=\"/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}\" style=\"text-decoration: underline; color: #888\" onclick=\"fetch(this.href); return false\">${frame.location}</a>\n${frame.code}`;\n    }, '') : diagnostic.stack;\n    errorHTML += `\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          🚨 ${diagnostic.message}\n        </div>\n        <pre>${stack}</pre>\n        <div>\n          ${diagnostic.hints.map(hint => '<div>💡 ' + hint + '</div>').join('')}\n        </div>\n        ${diagnostic.documentation ? `<div>📝 <a style=\"color: violet\" href=\"${diagnostic.documentation}\" target=\"_blank\">Learn more</a></div>` : ''}\n      </div>\n    `;\n  }\n  errorHTML += '</div>';\n  overlay.innerHTML = errorHTML;\n  return overlay;\n}\nfunction fullReload() {\n  if ('reload' in location) {\n    location.reload();\n  } else if (extCtx && extCtx.runtime && extCtx.runtime.reload) {\n    extCtx.runtime.reload();\n  }\n}\nfunction getParents(bundle, id) /*: Array<[ParcelRequire, string]> */{\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n  var parents = [];\n  var k, d, dep;\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {\n        parents.push([bundle, k]);\n      }\n    }\n  }\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n  return parents;\n}\nfunction updateLink(link) {\n  var href = link.getAttribute('href');\n  if (!href) {\n    return;\n  }\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    if (link.parentNode !== null) {\n      // $FlowFixMe\n      link.parentNode.removeChild(link);\n    }\n  };\n  newLink.setAttribute('href',\n  // $FlowFixMe\n  href.split('?')[0] + '?' + Date.now());\n  // $FlowFixMe\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      // $FlowFixMe[incompatible-type]\n      var href /*: string */ = links[i].getAttribute('href');\n      var hostname = getHostname();\n      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\\\/\\\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());\n      var absolute = /^https?:\\/\\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;\n      if (!absolute) {\n        updateLink(links[i]);\n      }\n    }\n    cssTimeout = null;\n  }, 50);\n}\nfunction hmrDownload(asset) {\n  if (asset.type === 'js') {\n    if (typeof document !== 'undefined') {\n      let script = document.createElement('script');\n      script.src = asset.url + '?t=' + Date.now();\n      if (asset.outputFormat === 'esmodule') {\n        script.type = 'module';\n      }\n      return new Promise((resolve, reject) => {\n        var _document$head;\n        script.onload = () => resolve(script);\n        script.onerror = reject;\n        (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);\n      });\n    } else if (typeof importScripts === 'function') {\n      // Worker scripts\n      if (asset.outputFormat === 'esmodule') {\n        return __parcel__import__(asset.url + '?t=' + Date.now());\n      } else {\n        return new Promise((resolve, reject) => {\n          try {\n            __parcel__importScripts__(asset.url + '?t=' + Date.now());\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        });\n      }\n    }\n  }\n}\nasync function hmrApplyUpdates(assets) {\n  global.parcelHotUpdate = Object.create(null);\n  let scriptsToRemove;\n  try {\n    // If sourceURL comments aren't supported in eval, we need to load\n    // the update from the dev server over HTTP so that stack traces\n    // are correct in errors/logs. This is much slower than eval, so\n    // we only do it if needed (currently just Safari).\n    // https://bugs.webkit.org/show_bug.cgi?id=137297\n    // This path is also taken if a CSP disallows eval.\n    if (!supportsSourceURL) {\n      let promises = assets.map(asset => {\n        var _hmrDownload;\n        return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch(err => {\n          // Web extension fix\n          if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {\n            extCtx.runtime.reload();\n            return;\n          }\n          throw err;\n        });\n      });\n      scriptsToRemove = await Promise.all(promises);\n    }\n    assets.forEach(function (asset) {\n      hmrApply(module.bundle.root, asset);\n    });\n  } finally {\n    delete global.parcelHotUpdate;\n    if (scriptsToRemove) {\n      scriptsToRemove.forEach(script => {\n        if (script) {\n          var _document$head2;\n          (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);\n        }\n      });\n    }\n  }\n}\nfunction hmrApply(bundle /*: ParcelRequire */, asset /*:  HMRAsset */) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (asset.type === 'css') {\n    reloadCSS();\n  } else if (asset.type === 'js') {\n    let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];\n    if (deps) {\n      if (modules[asset.id]) {\n        // Remove dependencies that are removed and will become orphaned.\n        // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.\n        let oldDeps = modules[asset.id][1];\n        for (let dep in oldDeps) {\n          if (!deps[dep] || deps[dep] !== oldDeps[dep]) {\n            let id = oldDeps[dep];\n            let parents = getParents(module.bundle.root, id);\n            if (parents.length === 1) {\n              hmrDelete(module.bundle.root, id);\n            }\n          }\n        }\n      }\n      if (supportsSourceURL) {\n        // Global eval. We would use `new Function` here but browser\n        // support for source maps is better with eval.\n        (0, eval)(asset.output);\n      }\n\n      // $FlowFixMe\n      let fn = global.parcelHotUpdate[asset.id];\n      modules[asset.id] = [fn, deps];\n    } else if (bundle.parent) {\n      hmrApply(bundle.parent, asset);\n    }\n  }\n}\nfunction hmrDelete(bundle, id) {\n  let modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (modules[id]) {\n    // Collect dependencies that will become orphaned when this module is deleted.\n    let deps = modules[id][1];\n    let orphans = [];\n    for (let dep in deps) {\n      let parents = getParents(module.bundle.root, deps[dep]);\n      if (parents.length === 1) {\n        orphans.push(deps[dep]);\n      }\n    }\n\n    // Delete the module. This must be done before deleting dependencies in case of circular dependencies.\n    delete modules[id];\n    delete bundle.cache[id];\n\n    // Now delete the orphans.\n    orphans.forEach(id => {\n      hmrDelete(module.bundle.root, id);\n    });\n  } else if (bundle.parent) {\n    hmrDelete(bundle.parent, id);\n  }\n}\nfunction hmrAcceptCheck(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  if (hmrAcceptCheckOne(bundle, id, depsByBundle)) {\n    return true;\n  }\n\n  // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.\n  let parents = getParents(module.bundle.root, id);\n  let accepted = false;\n  while (parents.length > 0) {\n    let v = parents.shift();\n    let a = hmrAcceptCheckOne(v[0], v[1], null);\n    if (a) {\n      // If this parent accepts, stop traversing upward, but still consider siblings.\n      accepted = true;\n    } else {\n      // Otherwise, queue the parents in the next level upward.\n      let p = getParents(module.bundle.root, v[1]);\n      if (p.length === 0) {\n        // If there are no parents, then we've reached an entry without accepting. Reload.\n        accepted = false;\n        break;\n      }\n      parents.push(...p);\n    }\n  }\n  return accepted;\n}\nfunction hmrAcceptCheckOne(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {\n    // If we reached the root bundle without finding where the asset should go,\n    // there's nothing to do. Mark as \"accepted\" so we don't reload the page.\n    if (!bundle.parent) {\n      return true;\n    }\n    return hmrAcceptCheck(bundle.parent, id, depsByBundle);\n  }\n  if (checkedAssets[id]) {\n    return true;\n  }\n  checkedAssets[id] = true;\n  var cached = bundle.cache[id];\n  assetsToDispose.push([bundle, id]);\n  if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {\n    assetsToAccept.push([bundle, id]);\n    return true;\n  }\n}\nfunction hmrDispose(bundle /*: ParcelRequire */, id /*: string */) {\n  var cached = bundle.cache[id];\n  bundle.hotData[id] = {};\n  if (cached && cached.hot) {\n    cached.hot.data = bundle.hotData[id];\n  }\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData[id]);\n    });\n  }\n  delete bundle.cache[id];\n}\nfunction hmrAccept(bundle /*: ParcelRequire */, id /*: string */) {\n  // Execute the module.\n  bundle(id);\n\n  // Run the accept callbacks in the new version of the module.\n  var cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      var assetsToAlsoAccept = cb(function () {\n        return getParents(module.bundle.root, id);\n      });\n      if (assetsToAlsoAccept && assetsToAccept.length) {\n        assetsToAlsoAccept.forEach(function (a) {\n          hmrDispose(a[0], a[1]);\n        });\n\n        // $FlowFixMe[method-unbinding]\n        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);\n      }\n    });\n  }\n}","/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n/**\n * 4KB JS implementation of secp256k1 signatures & ECDH. Compliant with RFC6979.\n * @module\n */\nconst B256 = 2n ** 256n;\nconst P = B256 - 0x1000003d1n; // curve's field prime\nconst N = B256 - 0x14551231950b75fc4402da1732fc9bebfn; // curve (group) order\nconst Gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n; // base point x\nconst Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n; // base point y\n/**\n * secp256k1 curve parameters. Equation is x³ + ax + b.\n * Gx and Gy are generator coordinates. p is field order, n is group order.\n */\nconst CURVE = {\n    p: P, n: N, a: 0n, b: 7n, Gx, Gy\n}; // exported variables incl. a, b\nconst fLen = 32; // field / group byte length\nconst curve = (x) => M(M(x * x) * x + CURVE.b); // x³ + ax + b weierstrass formula; a=0\nconst err = (m = '') => { throw new Error(m); }; // error helper, messes-up stack trace\nconst isB = (n) => typeof n === 'bigint'; // is big integer\nconst isS = (s) => typeof s === 'string'; // is string\nconst fe = (n) => isB(n) && 0n < n && n < P; // is field element (invertible)\nconst ge = (n) => isB(n) && 0n < n && n < N; // is group element\nconst isu8 = (a) => (a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array'));\nconst au8 = (a, l) => // assert is Uint8Array (of specific length)\n !isu8(a) || (typeof l === 'number' && l > 0 && a.length !== l) ?\n    err('Uint8Array expected') : a;\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst toU8 = (a, len) => au8(isS(a) ? h2b(a) : u8n(au8(a)), len); // norm(hex/u8a) to u8a\nconst M = (a, b = P) => {\n    const r = a % b;\n    return r >= 0n ? r : b + r;\n};\nconst aPoint = (p) => (p instanceof Point ? p : err('Point expected')); // is 3d point\n/** Point in 3d xyz projective coordinates. 3d takes less inversions than 2d. */\nclass Point {\n    constructor(px, py, pz) {\n        this.px = px;\n        this.py = py;\n        this.pz = pz;\n        Object.freeze(this);\n    }\n    /** Create 3d xyz point from 2d xy. (0, 0) => (0, 1, 0), not (0, 0, 1) */\n    static fromAffine(p) {\n        return ((p.x === 0n) && (p.y === 0n)) ? I : new Point(p.x, p.y, 1n);\n    }\n    /** Convert Uint8Array or hex string to Point. */\n    static fromHex(hex) {\n        hex = toU8(hex); // convert hex string to Uint8Array\n        let p = undefined;\n        const head = hex[0], tail = hex.subarray(1); // first byte is prefix, rest is data\n        const x = slc(tail, 0, fLen), len = hex.length; // next 32 bytes are x coordinate\n        if (len === 33 && [0x02, 0x03].includes(head)) { // compressed points: 33b, start\n            if (!fe(x))\n                err('Point hex invalid: x not FE'); // with byte 0x02 or 0x03. Check if 0<x<P\n            let y = sqrt(curve(x)); // x³ + ax + b is right side of equation\n            const isYOdd = (y & 1n) === 1n; // y² is equivalent left-side. Calculate y²:\n            const headOdd = (head & 1) === 1; // y = √y²; there are two solutions: y, -y\n            if (headOdd !== isYOdd)\n                y = M(-y); // determine proper solution\n            p = new Point(x, y, 1n); // create point\n        } // Uncompressed points: 65b, start with 0x04\n        if (len === 65 && head === 0x04)\n            p = new Point(x, slc(tail, fLen, 2 * fLen), 1n);\n        return p ? p.ok() : err('Point invalid: not on curve'); // Verify the result\n    }\n    /** Create point from a private key. */\n    static fromPrivateKey(k) { return G.mul(toPriv(k)); }\n    get x() { return this.aff().x; } // .x, .y will call expensive toAffine:\n    get y() { return this.aff().y; } // should be used with care.\n    /** Equality check: compare points P&Q. */\n    equals(other) {\n        const { px: X1, py: Y1, pz: Z1 } = this;\n        const { px: X2, py: Y2, pz: Z2 } = aPoint(other); // isPoint() checks class equality\n        const X1Z2 = M(X1 * Z2), X2Z1 = M(X2 * Z1);\n        const Y1Z2 = M(Y1 * Z2), Y2Z1 = M(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    /** Flip point over y coordinate. */\n    negate() { return new Point(this.px, M(-this.py), this.pz); }\n    /** Point doubling: P+P, complete formula. */\n    double() { return this.add(this); }\n    /**\n     * Point addition: P+Q, complete, exception-free formula\n     * (Renes-Costello-Batina, algo 1 of [2015/1060](https://eprint.iacr.org/2015/1060)).\n     * Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n     */\n    add(other) {\n        const { px: X1, py: Y1, pz: Z1 } = this;\n        const { px: X2, py: Y2, pz: Z2 } = aPoint(other);\n        const { a, b } = CURVE;\n        let X3 = 0n, Y3 = 0n, Z3 = 0n;\n        const b3 = M(b * 3n);\n        let t0 = M(X1 * X2), t1 = M(Y1 * Y2), t2 = M(Z1 * Z2), t3 = M(X1 + Y1); // step 1\n        let t4 = M(X2 + Y2); // step 5\n        t3 = M(t3 * t4);\n        t4 = M(t0 + t1);\n        t3 = M(t3 - t4);\n        t4 = M(X1 + Z1);\n        let t5 = M(X2 + Z2); // step 10\n        t4 = M(t4 * t5);\n        t5 = M(t0 + t2);\n        t4 = M(t4 - t5);\n        t5 = M(Y1 + Z1);\n        X3 = M(Y2 + Z2); // step 15\n        t5 = M(t5 * X3);\n        X3 = M(t1 + t2);\n        t5 = M(t5 - X3);\n        Z3 = M(a * t4);\n        X3 = M(b3 * t2); // step 20\n        Z3 = M(X3 + Z3);\n        X3 = M(t1 - Z3);\n        Z3 = M(t1 + Z3);\n        Y3 = M(X3 * Z3);\n        t1 = M(t0 + t0); // step 25\n        t1 = M(t1 + t0);\n        t2 = M(a * t2);\n        t4 = M(b3 * t4);\n        t1 = M(t1 + t2);\n        t2 = M(t0 - t2); // step 30\n        t2 = M(a * t2);\n        t4 = M(t4 + t2);\n        t0 = M(t1 * t4);\n        Y3 = M(Y3 + t0);\n        t0 = M(t5 * t4); // step 35\n        X3 = M(t3 * X3);\n        X3 = M(X3 - t0);\n        t0 = M(t3 * t1);\n        Z3 = M(t5 * Z3);\n        Z3 = M(Z3 + t0); // step 40\n        return new Point(X3, Y3, Z3);\n    }\n    mul(n, safe = true) {\n        if (!safe && n === 0n)\n            return I; // in unsafe mode, allow zero\n        if (!ge(n))\n            err('scalar invalid'); // must be 0 < n < CURVE.n\n        if (this.equals(G))\n            return wNAF(n).p; // use precomputes for base point\n        let p = I, f = G; // init result point & fake point\n        for (let d = this; n > 0n; d = d.double(), n >>= 1n) { // double-and-add ladder\n            if (n & 1n)\n                p = p.add(d); // if bit is present, add to point\n            else if (safe)\n                f = f.add(d); // if not, add to fake for timing safety\n        }\n        return p;\n    }\n    mulAddQUns(R, u1, u2) {\n        return this.mul(u1, false).add(R.mul(u2, false)).ok(); // Unsafe: do NOT use for stuff related\n    } // to private keys. Doesn't use Shamir trick\n    /** Convert point to 2d xy affine point. (x, y, z) ∋ (x=x/z, y=y/z) */\n    toAffine() {\n        const { px: x, py: y, pz: z } = this;\n        if (this.equals(I))\n            return { x: 0n, y: 0n }; // fast-path for zero point\n        if (z === 1n)\n            return { x, y }; // if z is 1, pass affine coordinates as-is\n        const iz = inv(z, P); // z^-1: invert z\n        if (M(z * iz) !== 1n)\n            err('inverse invalid'); // (z * z^-1) must be 1, otherwise bad math\n        return { x: M(x * iz), y: M(y * iz) }; // x = x*z^-1; y = y*z^-1\n    }\n    /** Checks if the point is valid and on-curve. */\n    assertValidity() {\n        const { x, y } = this.aff(); // convert to 2d xy affine point.\n        if (!fe(x) || !fe(y))\n            err('Point invalid: x or y'); // x and y must be in range 0 < n < P\n        return M(y * y) === curve(x) ? // y² = x³ + ax + b, must be equal\n            this : err('Point invalid: not on curve');\n    }\n    multiply(n) { return this.mul(n); } // Aliases to compress code\n    aff() { return this.toAffine(); }\n    ok() { return this.assertValidity(); }\n    toHex(isCompressed = true) {\n        const { x, y } = this.aff(); // convert to 2d xy affine point\n        const head = isCompressed ? ((y & 1n) === 0n ? '02' : '03') : '04'; // 0x02, 0x03, 0x04 prefix\n        return head + n2h(x) + (isCompressed ? '' : n2h(y)); // prefix||x and ||y\n    }\n    toRawBytes(isCompressed = true) {\n        return h2b(this.toHex(isCompressed)); // re-use toHex(), convert hex to bytes\n    }\n}\n/** Generator / base point */\nPoint.BASE = new Point(Gx, Gy, 1n);\n/** Identity / zero point */\nPoint.ZERO = new Point(0n, 1n, 0n);\nconst { BASE: G, ZERO: I } = Point; // Generator, identity points\nconst padh = (n, pad) => n.toString(16).padStart(pad, '0');\nconst b2h = (b) => Array.from(au8(b)).map(e => padh(e, 2)).join(''); // bytes to hex\nconst C = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }; // ASCII characters\nconst _ch = (ch) => {\n    if (ch >= C._0 && ch <= C._9)\n        return ch - C._0; // '2' => 50-48\n    if (ch >= C.A && ch <= C.F)\n        return ch - (C.A - 10); // 'B' => 66-(65-10)\n    if (ch >= C.a && ch <= C.f)\n        return ch - (C.a - 10); // 'b' => 98-(97-10)\n    return;\n};\nconst h2b = (hex) => {\n    const e = 'hex invalid';\n    if (!isS(hex))\n        return err(e);\n    const hl = hex.length, al = hl / 2;\n    if (hl % 2)\n        return err(e);\n    const array = u8n(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) { // treat each char as ASCII\n        const n1 = _ch(hex.charCodeAt(hi)); // parse first char, multiply it by 16\n        const n2 = _ch(hex.charCodeAt(hi + 1)); // parse second char\n        if (n1 === undefined || n2 === undefined)\n            return err(e);\n        array[ai] = n1 * 16 + n2; // example: 'A9' => 10*16 + 9\n    }\n    return array;\n};\nconst b2n = (b) => BigInt('0x' + (b2h(b) || '0')); // bytes to number\nconst slc = (b, from, to) => b2n(b.slice(from, to)); // slice bytes num\nconst n2b = (num) => {\n    return isB(num) && num >= 0n && num < B256 ? h2b(padh(num, 2 * fLen)) : err('bigint expected');\n};\nconst n2h = (num) => b2h(n2b(num)); // number to 32b hex\nconst concatB = (...arrs) => {\n    const r = u8n(arrs.reduce((sum, a) => sum + au8(a).length, 0)); // create u8a of summed length\n    let pad = 0; // walk through each array,\n    arrs.forEach(a => { r.set(a, pad); pad += a.length; }); // ensure they have proper type\n    return r;\n};\nconst inv = (num, md) => {\n    if (num === 0n || md <= 0n)\n        err('no inverse n=' + num + ' mod=' + md); // no neg exponent for now\n    let a = M(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;\n    while (a !== 0n) { // uses euclidean gcd algorithm\n        const q = b / a, r = b % a; // not constant-time\n        const m = x - u * q, n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    return b === 1n ? M(x, md) : err('no inverse'); // b is gcd at this point\n};\nconst sqrt = (n) => {\n    let r = 1n; // So, a special, fast case. Paper: \"Square Roots from 1;24,51,10 to Dan Shanks\".\n    for (let num = n, e = (P + 1n) / 4n; e > 0n; e >>= 1n) { // powMod: modular exponentiation.\n        if (e & 1n)\n            r = (r * num) % P; // Uses exponentiation by squaring.\n        num = (num * num) % P; // Not constant-time.\n    }\n    return M(r * r) === n ? r : err('sqrt invalid'); // check if result is valid\n};\nconst toPriv = (p) => {\n    if (!isB(p))\n        p = b2n(toU8(p, fLen)); // convert to bigint when bytes\n    return ge(p) ? p : err('private key invalid 3'); // check if bigint is in range\n};\nconst high = (n) => n > (N >> 1n); // if a number is bigger than CURVE.n/2\n/** Creates 33/65-byte public key from 32-byte private key. */\nconst getPublicKey = (privKey, isCompressed = true) => {\n    return Point.fromPrivateKey(privKey).toRawBytes(isCompressed);\n};\n/** ECDSA Signature class. Supports only compact 64-byte representation, not DER. */\nclass Signature {\n    constructor(r, s, recovery) {\n        this.r = r;\n        this.s = s;\n        this.recovery = recovery;\n        this.assertValidity(); // recovery bit is optional when\n    } // constructed outside.\n    /** Create signature from 64b compact (r || s) representation. */\n    static fromCompact(hex) {\n        hex = toU8(hex, 64); // compact repr is (32b r)||(32b s)\n        return new Signature(slc(hex, 0, fLen), slc(hex, fLen, 2 * fLen));\n    }\n    assertValidity() { return ge(this.r) && ge(this.s) ? this : err(); } // 0 < r or s < CURVE.n\n    /** Create new signature, with added recovery bit. */\n    addRecoveryBit(rec) {\n        return new Signature(this.r, this.s, rec);\n    }\n    hasHighS() { return high(this.s); }\n    normalizeS() {\n        return high(this.s) ? new Signature(this.r, M(-this.s, N), this.recovery) : this;\n    }\n    /** ECDSA public key recovery. Requires msg hash and recovery id. */\n    recoverPublicKey(msgh) {\n        const { r, s, recovery: rec } = this; // secg.org/sec1-v2.pdf 4.1.6\n        if (![0, 1, 2, 3].includes(rec))\n            err('recovery id invalid'); // check recovery id\n        const h = bits2int_modN(toU8(msgh, fLen)); // Truncate hash\n        const radj = rec === 2 || rec === 3 ? r + N : r; // If rec was 2 or 3, q.x is bigger than n\n        if (radj >= P)\n            err('q.x invalid'); // ensure q.x is still a field element\n        const head = (rec & 1) === 0 ? '02' : '03'; // head is 0x02 or 0x03\n        const R = Point.fromHex(head + n2h(radj)); // concat head + hex repr of r\n        const ir = inv(radj, N); // r^-1\n        const u1 = M(-h * ir, N); // -hr^-1\n        const u2 = M(s * ir, N); // sr^-1\n        return G.mulAddQUns(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n    }\n    /** Uint8Array 64b compact (r || s) representation. */\n    toCompactRawBytes() { return h2b(this.toCompactHex()); }\n    /** Hex string 64b compact (r || s) representation. */\n    toCompactHex() { return n2h(this.r) + n2h(this.s); }\n}\nconst bits2int = (bytes) => {\n    const delta = bytes.length * 8 - 256; // RFC suggests optional truncating via bits2octets\n    if (delta > 1024)\n        err('msg invalid'); // our CUSTOM check, \"just-in-case\"\n    const num = b2n(bytes); // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which\n    return delta > 0 ? num >> BigInt(delta) : num; // matches bits2int. bits2int can produce res>N.\n};\nconst bits2int_modN = (bytes) => {\n    return M(bits2int(bytes), N); // with 0: BAD for trunc as per RFC vectors\n};\nconst i2o = (num) => n2b(num); // int to octets\nconst cr = () => // We support: 1) browsers 2) node.js 19+ 3) deno, other envs with crypto\n typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\nlet _hmacSync; // Can be redefined by use in utils; built-ins don't provide it\nconst optS = { lowS: true }; // opts for sign()\nconst optV = { lowS: true }; // standard opts for verify()\nconst prepSig = (msgh, priv, opts = optS) => {\n    if (['der', 'recovered', 'canonical'].some(k => k in opts))\n        err('option not supported'); // legacy opts\n    let { lowS } = opts; // generates low-s sigs by default\n    if (lowS == null)\n        lowS = true; // RFC6979 3.2: we skip step A\n    const h1i = bits2int_modN(toU8(msgh)); // msg bigint\n    const h1o = i2o(h1i); // msg octets\n    const d = toPriv(priv); // validate private key, convert to bigint\n    const seed = [i2o(d), h1o]; // Step D of RFC6979 3.2\n    let ent = opts.extraEntropy; // RFC6979 3.6: additional k' (optional)\n    if (ent) // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n        seed.push(ent === true ? etc.randomBytes(fLen) : toU8(ent)); // true == fetch from CSPRNG\n    const m = h1i; // convert msg to bigint\n    const k2sig = (kBytes) => {\n        const k = bits2int(kBytes); // RFC6979 method.\n        if (!ge(k))\n            return; // Check 0 < k < CURVE.n\n        const ik = inv(k, N); // k^-1 mod n, NOT mod P\n        const q = G.mul(k).aff(); // q = Gk\n        const r = M(q.x, N); // r = q.x mod n\n        if (r === 0n)\n            return; // r=0 invalid\n        const s = M(ik * M(m + M(d * r, N), N), N); // s = k^-1(m + rd) mod n\n        if (s === 0n)\n            return; // s=0 invalid\n        let normS = s; // normalized S\n        let rec = (q.x === r ? 0 : 2) | Number(q.y & 1n); // recovery bit\n        if (lowS && high(s)) { // if lowS was passed, ensure s is always\n            normS = M(-s, N); // in the bottom half of CURVE.n\n            rec ^= 1;\n        }\n        return new Signature(r, normS, rec); // use normS, not s\n    };\n    return { seed: concatB(...seed), k2sig };\n};\nfunction hmacDrbg(asynchronous) {\n    let v = u8n(fLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(fLen); // Steps B, C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => { v.fill(1); k.fill(0); i = 0; };\n    const _e = 'drbg: tried 1000 values';\n    if (asynchronous) { // asynchronous=true\n        const h = (...b) => etc.hmacSha256Async(k, v, ...b); // hmac(k)(v, ...values)\n        const reseed = async (seed = u8n()) => {\n            k = await h(u8n([0x00]), seed); // k = hmac(K || V || 0x00 || seed)\n            v = await h(); // v = hmac(K || V)\n            if (seed.length === 0)\n                return;\n            k = await h(u8n([0x01]), seed); // k = hmac(K || V || 0x01 || seed)\n            v = await h(); // v = hmac(K || V)\n        };\n        const gen = async () => {\n            if (i++ >= 1000)\n                err(_e);\n            v = await h(); // v = hmac(K || V)\n            return v;\n        };\n        return async (seed, pred) => {\n            reset(); // the returned fn, don't, it's: 1. slower (JIT). 2. unsafe (async race conditions)\n            await reseed(seed); // Steps D-G\n            let res = undefined; // Step H: grind until k is in [1..n-1]\n            while (!(res = pred(await gen())))\n                await reseed(); // test predicate until it returns ok\n            reset();\n            return res;\n        };\n    }\n    else {\n        const h = (...b) => {\n            const f = _hmacSync;\n            if (!f)\n                err('etc.hmacSha256Sync not set');\n            return f(k, v, ...b); // hmac(k)(v, ...values)\n        };\n        const reseed = (seed = u8n()) => {\n            k = h(u8n([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n            v = h(); // v = hmac(k || v)\n            if (seed.length === 0)\n                return;\n            k = h(u8n([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n            v = h(); // v = hmac(k || v)\n        };\n        const gen = () => {\n            if (i++ >= 1000)\n                err(_e);\n            v = h(); // v = hmac(k || v)\n            return v;\n        };\n        return (seed, pred) => {\n            reset();\n            reseed(seed); // Steps D-G\n            let res = undefined; // Step H: grind until k is in [1..n-1]\n            while (!(res = pred(gen())))\n                reseed(); // test predicate until it returns ok\n            reset();\n            return res;\n        };\n    }\n}\n;\n/** ECDSA signature generation. via secg.org/sec1-v2.pdf 4.1.2 + RFC6979 deterministic k. */\n/**\n * Sign a msg hash using secp256k1. Async.\n * It is advised to use `extraEntropy: true` (from RFC6979 3.6) to prevent fault attacks.\n * Worst case: if randomness source for extraEntropy is bad, it would be as secure as if\n * the option has not been used.\n * @param msgh - message HASH, not message itself e.g. sha256(message)\n * @param priv - private key\n * @param opts - `lowS: true` to prevent malleability (s >= CURVE.n/2), `extraEntropy: boolean | Hex` to improve sig security.\n */\nconst signAsync = async (msgh, priv, opts = optS) => {\n    const { seed, k2sig } = prepSig(msgh, priv, opts); // Extract arguments for hmac-drbg\n    return hmacDrbg(true)(seed, k2sig); // Re-run drbg until k2sig returns ok\n};\n/**\n * Sign a msg hash using secp256k1.\n * It is advised to use `extraEntropy: true` (from RFC6979 3.6) to prevent fault attacks.\n * Worst case: if randomness source for extraEntropy is bad, it would be as secure as if\n * the option has not been used.\n * @param msgh - message HASH, not message itself e.g. sha256(message)\n * @param priv - private key\n * @param opts - `lowS: true` to prevent malleability (s >= CURVE.n/2), `extraEntropy: boolean | Hex` to improve sig security.\n * @example\n * const sig = sign(sha256('hello'), privKey, { extraEntropy: true }).toCompactRawBytes();\n */\nconst sign = (msgh, priv, opts = optS) => {\n    const { seed, k2sig } = prepSig(msgh, priv, opts); // Extract arguments for hmac-drbg\n    return hmacDrbg(false)(seed, k2sig); // Re-run drbg until k2sig returns ok\n};\n/**\n * Verify a signature using secp256k1.\n * @param sig - signature, 64-byte or Signature instance\n * @param msgh - message HASH, not message itself e.g. sha256(message)\n * @param pub - public key\n * @param opts - { lowS: true } is default, prohibits s >= CURVE.n/2 to prevent malleability\n */\nconst verify = (sig, msgh, pub, opts = optV) => {\n    let { lowS } = opts; // ECDSA signature verification\n    if (lowS == null)\n        lowS = true; // Default lowS=true\n    if ('strict' in opts)\n        err('option not supported'); // legacy param\n    let sig_, h, P; // secg.org/sec1-v2.pdf 4.1.4\n    const rs = sig && typeof sig === 'object' && 'r' in sig; // Previous ver supported DER sigs. We\n    if (!rs && (toU8(sig).length !== 2 * fLen)) // throw error when DER is suspected now.\n        err('signature must be 64 bytes');\n    try {\n        sig_ = rs ? new Signature(sig.r, sig.s).assertValidity() : Signature.fromCompact(sig);\n        h = bits2int_modN(toU8(msgh)); // Truncate hash\n        P = pub instanceof Point ? pub.ok() : Point.fromHex(pub); // Validate public key\n    }\n    catch (e) {\n        return false;\n    } // Check sig for validity in both cases\n    if (!sig_)\n        return false;\n    const { r, s } = sig_;\n    if (lowS && high(s))\n        return false; // lowS bans sig.s >= CURVE.n/2\n    let R;\n    try {\n        const is = inv(s, N); // s^-1\n        const u1 = M(h * is, N); // u1 = hs^-1 mod n\n        const u2 = M(r * is, N); // u2 = rs^-1 mod n\n        R = G.mulAddQUns(P, u1, u2).aff(); // R = u1⋅G + u2⋅P\n    }\n    catch (error) {\n        return false;\n    }\n    if (!R)\n        return false; // stop if R is identity / zero point\n    const v = M(R.x, N); // R.x must be in N's field, not P's\n    return v === r; // mod(R.x, n) == r\n};\n/**\n * Elliptic Curve Diffie-Hellman (ECDH) on secp256k1.\n * Result is **NOT hashed**. Use hash on it if you need.\n * @param privA private key A\n * @param pubB public key B\n * @param isCompressed 33-byte or 65-byte output\n * @returns public key C\n */\nconst getSharedSecret = (privA, pubB, isCompressed = true) => {\n    return Point.fromHex(pubB).mul(toPriv(privA)).toRawBytes(isCompressed); // ECDH\n};\nconst hashToPrivateKey = (hash) => {\n    hash = toU8(hash); // produces private keys with modulo bias\n    if (hash.length < fLen + 8 || hash.length > 1024)\n        err('expected 40-1024b'); // being neglible.\n    const num = M(b2n(hash), N - 1n); // takes n+8 bytes\n    return n2b(num + 1n); // returns (hash mod n-1)+1\n};\n/** Math, hex, byte helpers. Not in `utils` because utils share API with noble-curves. */\nconst etc = {\n    hexToBytes: h2b,\n    bytesToHex: b2h,\n    concatBytes: concatB,\n    bytesToNumberBE: b2n,\n    numberToBytesBE: n2b,\n    mod: M,\n    invert: inv, // math utilities\n    hmacSha256Async: async (key, ...msgs) => {\n        const c = cr(); // async HMAC-SHA256, no sync built-in!\n        const s = c && c.subtle; // For React Native support, see README.\n        if (!s)\n            return err('etc.hmacSha256Async or crypto.subtle must be defined'); // Uses webcrypto built-in cryptography.\n        const k = await s.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n        return u8n(await s.sign('HMAC', k, concatB(...msgs)));\n    },\n    hmacSha256Sync: _hmacSync, // For TypeScript. Actual logic is below\n    hashToPrivateKey: hashToPrivateKey,\n    randomBytes: (len = 32) => {\n        const crypto = cr(); // Must be shimmed in node.js <= 18 to prevent error. See README.\n        if (!crypto || !crypto.getRandomValues)\n            err('crypto.getRandomValues must be defined');\n        return crypto.getRandomValues(u8n(len));\n    },\n};\n/** Curve-specific utilities for private keys. */\nconst utils = {\n    normPrivateKeyToScalar: toPriv,\n    isValidPrivateKey: (key) => { try {\n        return !!toPriv(key);\n    }\n    catch (e) {\n        return false;\n    } },\n    randomPrivateKey: () => hashToPrivateKey(etc.randomBytes(fLen + 16)), // FIPS 186 B.4.1.\n    precompute: (w = 8, p = G) => { p.multiply(3n); w; return p; }, // no-op\n};\nObject.defineProperties(etc, { hmacSha256Sync: {\n        configurable: false, get() { return _hmacSync; }, set(f) { if (!_hmacSync)\n            _hmacSync = f; },\n    } });\nconst W = 8; // Precomputes-related code. W = window size\nconst precompute = () => {\n    const points = []; // 10x sign(), 2x verify(). To achieve this,\n    const windows = 256 / W + 1; // app needs to spend 40ms+ to calculate\n    let p = G, b = p; // a lot of points related to base point G.\n    for (let w = 0; w < windows; w++) { // Points are stored in array and used\n        b = p; // any time Gx multiplication is done.\n        points.push(b); // They consume 16-32 MiB of RAM.\n        for (let i = 1; i < 2 ** (W - 1); i++) {\n            b = b.add(p);\n            points.push(b);\n        }\n        p = b.double(); // Precomputes don't speed-up getSharedKey,\n    } // which multiplies user point by scalar,\n    return points; // when precomputes are using base point\n};\nlet Gpows = undefined; // precomputes for base point G\nconst wNAF = (n) => {\n    // Compared to other point mult methods,\n    const comp = Gpows || (Gpows = precompute()); // stores 2x less points using subtraction\n    const neg = (cnd, p) => { let n = p.negate(); return cnd ? n : p; }; // negate\n    let p = I, f = G; // f must be G, or could become I in the end\n    const windows = 1 + 256 / W; // W=8 17 windows\n    const wsize = 2 ** (W - 1); // W=8 128 window size\n    const mask = BigInt(2 ** W - 1); // W=8 will create mask 0b11111111\n    const maxNum = 2 ** W; // W=8 256\n    const shiftBy = BigInt(W); // W=8 8\n    for (let w = 0; w < windows; w++) {\n        const off = w * wsize;\n        let wbits = Number(n & mask); // extract W bits.\n        n >>= shiftBy; // shift number by W bits.\n        if (wbits > wsize) {\n            wbits -= maxNum;\n            n += 1n;\n        } // split if bits > max: +224 => 256-32\n        const off1 = off, off2 = off + Math.abs(wbits) - 1; // offsets, evaluate both\n        const cnd1 = w % 2 !== 0, cnd2 = wbits < 0; // conditions, evaluate both\n        if (wbits === 0) {\n            f = f.add(neg(cnd1, comp[off1])); // bits are 0: add garbage to fake point\n        }\n        else { //          ^ can't add off2, off2 = I\n            p = p.add(neg(cnd2, comp[off2])); // bits are 1: add to result point\n        }\n    }\n    return { p, f }; // return both real and fake points for JIT\n}; // !! you can disable precomputes by commenting-out call of the wNAF() inside Point#mul()\nexport { getPublicKey, sign, signAsync, verify, CURVE, // Remove the export to easily use in REPL\ngetSharedSecret, etc, utils, Point as ProjectivePoint, Signature }; // envs like browser console\n"],"names":[],"version":3,"file":"index.80bf872c.js.map","sourceRoot":"/__parcel_source_root/"}